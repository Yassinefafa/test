<!DOCTYPE html>
<html lang="en"> <!-- Changed default language to English -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Dashboard</title> <!-- Updated title for English -->
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- jsPDF CDN for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas CDN for capturing HTML content -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            direction: ltr; /* Default to LTR for English initially */
            text-align: left; /* Default to left for English initially */
            background: linear-gradient(to bottom right, #e0f2fe, #eef2ff); /* from-blue-50 to-indigo-50 equivalent */
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll when sidebar is open */
        }
        .container {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding: 1rem;
        }
        .hidden {
            display: none;
        }
        /* Custom scrollbar for table */
        .overflow-x-auto::-webkit-scrollbar {
            height: 8px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Glassmorphism effect for cards */
        .glassmorphism-card {
            background-color: rgba(255, 255, 255, 0.15); /* Slightly transparent white */
            backdrop-filter: blur(10px); /* Blur behind the element */
            -webkit-backdrop-filter: blur(10px); /* For Safari support */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle white border */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2); /* Softer shadow for depth */
            border-radius: 0.75rem; /* Matches Tailwind's rounded-lg */
        }
        /* Enhanced interactivity for cards */
        .data-card-interactive {
            transform: scale(1);
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .data-card-interactive:hover {
            transform: scale(1.03);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        /* Sidebar specific styles - Now positioned on the left */
        #sidebar {
            width: 250px; /* Default width for sidebar */
            transition: transform 0.3s ease-in-out;
            left: 0; /* Position sidebar on the left */
            transform: translateX(-250px); /* Hidden by default (off-screen to the left) */
            z-index: 50; /* Above main content */
            /* For desktop, make it relative and always visible */
            @media (min-width: 768px) {
                position: relative; 
                transform: translateX(0); /* Always visible on desktop */
                flex-shrink: 0; /* Prevent sidebar from shrinking */
            }
        }
        /* Classes for sidebar being open on mobile */
        #sidebar.open-ltr, #sidebar.open-rtl {
            transform: translateX(0); /* Visible for both LTR and RTL when open */
        }

        #mainContentWrapper {
            flex: 1; /* Take up remaining space */
            width: 100%; /* Important for flex-1 to work well */
            transition: margin-left 0.3s ease-in-out; /* Transition for margin shift */
            /* No fixed margins here for desktop, flex handles it */
        }

        /* Mobile-specific shifts for main content when sidebar is open */
        html[dir="rtl"] #mainContentWrapper.shifted-rtl-mobile-open {
            margin-left: 250px; /* Shift content to the right for RTL when sidebar is open on mobile */
            margin-right: 0; /* Ensure no right margin */
        }
        html[dir="ltr"] #mainContentWrapper.shifted-ltr-mobile-open {
            margin-left: 250px; /* Shift content to the right for LTR when sidebar is open on mobile */
            margin-right: 0; /* Ensure no right margin */
        }

        /* Overlay for mobile when sidebar is open */
        #sidebarOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 40;
            opacity: 0; /* Start hidden */
            transition: opacity 0.3s ease-in-out;
        }
        #sidebarOverlay.show {
            opacity: 1; /* Fade in */
        }
    </style>
</head>
<body class="text-gray-800">
    <!-- Sidebar Overlay for mobile -->
    <div id="sidebarOverlay" class="hidden md:hidden"></div>

    <!-- Overall Wrapper for Sidebar and Main Content -->
    <div class="flex">
        <!-- Sidebar -->
        <nav id="sidebar" class="fixed top-0 left-0 h-full bg-gradient-to-br from-blue-700 to-indigo-800 text-white p-6 shadow-xl space-y-4">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">Menu</h2>
                <button id="closeSidebarBtn" class="md:hidden text-white hover:text-gray-200 focus:outline-none">
                    <svg class="h-8 w-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <button id="latestDataBtn" class="nav-button block w-full text-left px-4 py-2 text-lg rounded-md font-semibold text-white bg-blue-600 hover:bg-blue-500 transition duration-300 transform hover:scale-105 shadow-md" data-target="latestData">
                Latest Data
            </button>
            <button id="accelGyroBtn" class="nav-button block w-full text-left px-4 py-2 text-lg rounded-md font-semibold text-white bg-blue-600 hover:bg-blue-500 transition duration-300 transform hover:scale-105 shadow-md" data-target="accelGyroData">
                Acceleration & Gyro
            </button>
            <button id="fullTableBtn" class="nav-button block w-full text-left px-4 py-2 text-lg rounded-md font-semibold text-white bg-blue-600 hover:bg-blue-500 transition duration-300 transform hover:scale-105 shadow-md" data-target="fullTable">
                Full Table
            </button>
            <button id="chartsBtn" class="nav-button block w-full text-left px-4 py-2 text-lg rounded-md font-semibold text-white bg-blue-600 hover:bg-blue-500 transition duration-300 transform hover:scale-105 shadow-md" data-target="charts">
                Charts
            </button>
            <button id="thresholdSettingsBtn" class="nav-button block w-full text-left px-4 py-2 text-lg rounded-md font-semibold text-white bg-purple-600 hover:bg-purple-500 transition duration-300 transform hover:scale-105 shadow-md" data-target="thresholdSettings">
                Settings
            </button>
            <!-- Auto Refresh Toggle Button moved here to be part of sidebar functionality -->
            <button id="autoRefreshToggleBtn" class="block w-full text-left px-4 py-2 text-lg rounded-md font-semibold text-white bg-green-600 hover:bg-green-500 transition duration-300 transform hover:scale-105 shadow-md">
                Auto Refresh: ON
            </button>
        </nav>

        <!-- Main Content Wrapper -->
        <div id="mainContentWrapper" class="flex-1 w-full min-h-screen">
            <!-- Header and Navigation (now only for title, date/time, language selector, and mobile menu button) -->
            <header class="bg-gradient-to-r from-blue-600 to-indigo-700 shadow-lg py-4 px-4 sm:px-6 md:px-8 flex justify-between items-center flex-wrap gap-4">
                <div class="flex items-center gap-4">
                    <button id="openSidebarBtn" class="md:hidden text-white hover:text-gray-200 focus:outline-none">
                        <svg class="h-8 w-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                    <h1 id="dashboardTitle" class="text-white text-2xl sm:text-3xl font-bold rounded-lg px-2 py-1 bg-opacity-20 bg-white">
                        Data Dashboard
                    </h1>
                </div>
                <!-- Current Date and Time Display -->
                <div class="flex items-center space-x-4 text-white text-base sm:text-lg font-semibold">
                    <div id="currentDate" class="px-3 py-1 rounded-full bg-blue-500 bg-opacity-40 shadow-md text-xs sm:text-base"></div>
                    <div id="currentTime" class="px-3 py-1 rounded-full bg-indigo-500 bg-opacity-40 shadow-md text-xs sm:text-base"></div>
                </div>
                <!-- Language Selector -->
                <div class="flex space-x-2">
                    <button class="lang-button px-3 py-1 text-xs sm:px-4 sm:py-2 rounded-full font-semibold text-white bg-gray-600 hover:bg-gray-500 transition duration-300" data-lang="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</button>
                    <button class="lang-button px-3 py-1 text-xs sm:px-4 sm:py-2 rounded-full font-semibold text-white bg-gray-600 hover:bg-gray-500 transition duration-300" data-lang="en">English</button>
                    <button class="lang-button px-3 py-1 text-xs sm:px-4 sm:py-2 rounded-full font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300" data-lang="fr">Fran√ßais</button>
                </div>
            </header>

            <!-- Main Content Area -->
            <main class="container my-8" id="mainContentArea">
                <div class="bg-white p-4 sm:p-8 rounded-lg shadow-xl border border-gray-200">
                    <!-- Loading Indicator -->
                    <div id="loading" class="text-center text-xl font-semibold text-blue-600 my-10 hidden">
                        <div class="flex items-center justify-center space-x-2">
                            <svg class="animate-spin h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span id="loadingText">Loading data...</span>
                        </div>
                    </div>

                    <!-- Error Message -->
                    <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative my-6 hidden" role="alert">
                        <strong id="errorTitle" class="font-bold">Error!</strong>
                        <span class="block sm:inline" id="errorText">Failed to load data. Please ensure the data source is available and Apps Script is correctly deployed.</span>
                        <span class="absolute top-0 bottom-0 right-0 px-4 py-3">
                            <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="document.getElementById('errorMessage').classList.add('hidden')">
                                <title>Close</title>
                                <path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/>
                            </svg>
                        </span>
                    </div>

                    <!-- Latest Data Section -->
                    <section id="latestData" class="page-content">
                        <h2 id="latestDataTitle" class="text-xl sm:text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                            Latest Sensor Data
                        </h2>
                        <div class="flex justify-start mb-6">
                            <button id="generateInsightBtn" class="px-4 py-2 text-sm sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-purple-600 hover:bg-purple-500 transition duration-300 transform hover:scale-105 shadow-md">
                                Generate Insight ‚ú®
                            </button>
                        </div>
                        <div id="latestDataContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            <!-- Latest data will be injected here by JavaScript -->
                        </div>
                        <div id="insightCard" class="glassmorphism-card p-4 sm:p-6 col-span-full mt-6 hidden">
                            <h3 id="insightCardTitle" class="text-lg sm:text-xl font-semibold text-purple-700 mb-4"></h3>
                            <p id="insightContent" class="text-gray-800 text-sm sm:text-base leading-relaxed"></p>
                            <div class="flex justify-end mt-4">
                                <button id="copyInsightBtn" class="px-3 py-1 sm:px-4 sm:py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 text-xs sm:text-sm">
                                    Copy Insight
                                </button>
                            </div>
                            <div id="insightLoading" class="text-center text-xs sm:text-sm text-purple-600 mt-4 hidden">
                                <svg class="animate-spin h-5 w-5 inline-block text-purple-600 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span id="insightLoadingText"></span>
                            </div>
                        </div>
                    </section>

                    <!-- Acceleration and Gyroscope Data Section -->
                    <section id="accelGyroData" class="page-content hidden">
                        <h2 id="accelGyroTitle" class="text-xl sm:text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                            Acceleration and Gyroscope Data
                        </h2>
                        <div id="accelGyroContent" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Acceleration and Gyroscope data will be injected here by JavaScript -->
                        </div>
                    </section>

                    <!-- Full Table Section -->
                    <section id="fullTable" class="page-content hidden">
                        <h2 id="fullTableTitle" class="text-xl sm:text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                            Full Data with Filters
                        </h2>

                        <!-- Filters -->
                        <div class="mb-8 p-4 sm:p-6 bg-gray-50 rounded-lg shadow-inner">
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-4">
                                <div>
                                    <label id="fromDateLabel" for="fromDate" class="block text-gray-700 text-sm font-medium mb-2">From Date:</label>
                                    <input type="date" id="fromDate" class="form-input w-full p-2 sm:p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                                </div>
                                <div>
                                    <label id="toDateLabel" for="toDate" class="block text-gray-700 text-sm font-medium mb-2">To Date:</label>
                                    <input type="date" id="toDate" class="form-input w-full p-2 sm:p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                                </div>
                                <div>
                                    <label id="fromTimeLabel" for="fromTime" class="block text-gray-700 text-sm font-medium mb-2">From Time:</label>
                                    <input type="time" id="fromTime" class="form-input w-full p-2 sm:p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                                </div>
                                <div>
                                    <label id="toTimeLabel" for="toTime" class="block text-gray-700 text-sm font-medium mb-2">To Time:</label>
                                    <input type="time" id="toTime" class="form-input w-full p-2 sm:p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                                </div>
                            </div>
                            <div class="flex justify-start space-x-2 flex-wrap">
                                <button id="applyFiltersBtn" class="px-4 py-2 text-sm sm:px-8 sm:py-3 sm:text-lg bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-300 transform hover:scale-105 shadow-lg">
                                    Apply Filter
                                </button>
                                <button id="resetFiltersBtn" class="px-4 py-2 text-sm sm:px-8 sm:py-3 sm:text-lg bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition duration-300 transform hover:scale-105 shadow-lg">
                                    Reset
                                </button>
                                <button id="exportCsvBtn" class="px-4 py-2 text-sm sm:px-8 sm:py-3 sm:text-lg bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 shadow-lg">
                                    Export CSV
                                </button>
                                <button id="exportPdfBtn" class="px-4 py-2 text-sm sm:px-8 sm:py-3 sm:text-lg bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition duration-300 transform hover:scale-105 shadow-lg">
                                    Export PDF
                                </button>
                            </div>
                        </div>

                        <!-- Data Table -->
                        <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                            <table id="dataTable" class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-100">
                                    <tr id="tableHeaderRow">
                                        <!-- Headers will be injected here -->
                                    </tr>
                                </thead>
                                <tbody id="tableBody" class="bg-white divide-y divide-gray-200">
                                    <!-- Data rows will be injected here -->
                                </tbody>
                            </table>
                            <div id="noDataFound" class="hidden text-center py-8 text-gray-500 text-lg">
                                No data to display or no data matching filter criteria.
                            </div>
                        </div>
                        <!-- Pagination Controls -->
                        <div id="paginationControls" class="flex justify-center items-center space-x-4 mt-6">
                            <button id="prevPageBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
                            <span id="pageInfo" class="text-gray-700">Page 1 of 1</span>
                            <button id="nextPageBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Next</button>
                        </div>
                    </section>

                    <!-- Charts Section -->
                    <section id="charts" class="page-content hidden">
                        <h2 id="chartsTitle" class="text-xl sm:text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                            Sensor Data Charts
                        </h2>
                        <!-- Chart Controls (Dropdown for Metric Selection) -->
                        <div class="mb-6 p-4 bg-gray-50 rounded-lg shadow-inner flex flex-col sm:flex-row items-start sm:items-center gap-4">
                            <label for="chartMetricSelect" id="chartMetricLabel" class="text-gray-700 font-medium whitespace-nowrap">Select Metric:</label>
                            <select id="chartMetricSelect" class="form-select flex-grow p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                                <!-- Options will be populated by JavaScript -->
                            </select>
                        </div>

                        <!-- Single Chart Canvas -->
                        <div id="singleChartContainer" class="glassmorphism-card p-4 sm:p-6 flex flex-col justify-center items-center">
                            <h3 id="currentChartTitle" class="text-lg sm:text-xl font-semibold text-blue-700 mb-4 text-center"></h3>
                            <canvas id="mainChartCanvas"></canvas>
                            <!-- Min/Max/Avg Display -->
                            <div id="chartStats" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-4 w-full text-center">
                                <div class="p-2 bg-blue-50 rounded-md">
                                    <p id="minVal" class="text-sm font-semibold text-gray-700">Min: N/A</p>
                                </div>
                                <div class="p-2 bg-blue-50 rounded-md">
                                    <p id="avgVal" class="text-sm font-semibold text-gray-700">Avg: N/A</p>
                                </div>
                                <div class="p-2 bg-blue-50 rounded-md">
                                    <p id="maxVal" class="text-sm font-semibold text-gray-700">Max: N/A</p>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Threshold Settings Section (New Page) -->
                    <section id="thresholdSettings" class="page-content hidden">
                        <h2 id="thresholdSettingsTitle" class="text-xl sm:text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-purple-500">
                            Alert Threshold Settings
                        </h2>
                        <div id="thresholdSettingsContent" class="grid grid-cols-1 gap-6">
                            <!-- Threshold settings will be injected here by JavaScript -->
                        </div>
                        <div class="flex justify-start mt-8 space-x-4"> <!-- Removed space-x-reverse for LTR -->
                            <button id="saveThresholdsBtn" class="px-6 py-2 text-base sm:px-8 sm:py-3 sm:text-lg bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-300 transform hover:scale-105 shadow-lg">
                                Save Thresholds
                            </button>
                            <button id="resetThresholdsBtn" class="px-6 py-2 text-base sm:px-8 sm:py-3 sm:text-lg bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 shadow-lg">
                                Reset Thresholds
                            </button>
                        </div>
                        <div id="thresholdMessage" class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative my-6 hidden" role="alert">
                            <span id="thresholdMessageText" class="block sm:inline"></span>
                            <span class="absolute top-0 bottom-0 right-0 px-4 py-3"> <!-- Changed left-0 to right-0 for LTR -->
                                <svg class="fill-current h-6 w-6 text-green-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="document.getElementById('thresholdMessage').classList.add('hidden')">
                                    <title>Close</title>
                                    <path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/>
                                </svg>
                            </span>
                        </div>
                    </section>
                </div> <!-- End of new wrapper div -->
            </main>
        </div> <!-- End of main content wrapper -->
    </div> <!-- End of overall flex wrapper -->

    <script>
        // Google Sheets API URL - Ensure this URL is correct and published to 'Anyone' access
        const GOOGLE_SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbxO7soutfxNmG1Vy6KvuZ4ZS96qWg9nJouY-vjvKt3_i-kQh4wa3hBbU0-vuqgU8jF02g/exec';

        // Global variables
        let sensorData = []; // To store ALL fetched data
        let previousLatestEntry = {}; // To store the previous latest data for change indicators
        let chartInstance = null; // Single Chart.js instance for the main chart
        let currentLanguage = 'en'; // Changed default language to English
        let autoRefreshIntervalId = null; // Stores the ID of the setInterval for auto-refresh
        let currentPage = 1;
        const itemsPerPage = 20; // Number of rows per page for the full table
        let isSidebarOpen = false; // Track sidebar state for mobile

        // DOM Elements
        const loadingIndicator = document.getElementById('loading');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorTextSpan = document.getElementById('errorText');
        const latestDataSection = document.getElementById('latestData');
        const latestDataContent = document.getElementById('latestDataContent');
        const fullTableSection = document.getElementById('fullTable');
        const chartsSection = document.getElementById('charts');
        const dataTable = document.getElementById('dataTable');
        const tableHeaderRow = document.getElementById('tableHeaderRow');
        const tableBody = document.getElementById('tableBody');
        const fromDateInput = document.getElementById('fromDate');
        const toDateInput = document.getElementById('toDate');
        const fromTimeInput = document.getElementById('fromTime');
        const toTimeInput = document.getElementById('toTime');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const noDataFoundDiv = document.getElementById('noDataFound');
        const chartsContainer = document.getElementById('chartsContainer'); // Now holds dropdown and single chart
        const mainChartCanvas = document.getElementById('mainChartCanvas'); // The single chart canvas
        const chartMetricSelect = document.getElementById('chartMetricSelect'); // Dropdown for metric selection
        const currentChartTitle = document.getElementById('currentChartTitle'); // Title for the selected chart
        const chartStats = document.getElementById('chartStats'); // Div to display min/avg/max
        const minVal = document.getElementById('minVal');
        const avgVal = document.getElementById('avgVal');
        const maxVal = document.getElementById('maxVal');

        // Elements for current date/time display
        const currentDateDisplay = document.getElementById('currentDate');
        const currentTimeDisplay = document.getElementById('currentTime');

        // Elements for language update
        const dashboardTitle = document.getElementById('dashboardTitle');
        const latestDataTitle = document.getElementById('latestDataTitle');
        const fullTableTitle = document.getElementById('fullTableTitle');
        const chartsTitle = document.getElementById('chartsTitle');
        const fromDateLabel = document.getElementById('fromDateLabel');
        const toDateLabel = document.getElementById('toDateLabel');
        const fromTimeLabel = document.getElementById('fromTimeLabel');
        const toTimeLabel = document.getElementById('toTimeLabel');
        const loadingText = document.getElementById('loadingText');
        const errorTitle = document.getElementById('errorTitle');

        // New elements for Acceleration and Gyroscope section
        const accelGyroDataSection = document.getElementById('accelGyroData');
        const accelGyroTitle = document.getElementById('accelGyroTitle');
        const accelGyroContent = document.getElementById('accelGyroContent');

        // New element for auto-refresh button
        const autoRefreshToggleBtn = document.getElementById('autoRefreshToggleBtn');

        // New elements for LLM insight
        const insightCard = document.getElementById('insightCard');
        const insightCardTitle = document.getElementById('insightCardTitle');
        const insightContent = document.getElementById('insightContent');
        const insightLoading = document.getElementById('insightLoading');
        const insightLoadingText = document.getElementById('insightLoadingText');
        const generateInsightBtn = document.getElementById('generateInsightBtn');
        const copyInsightBtn = document.getElementById('copyInsightBtn'); // New copy insight button

        // Pagination elements
        const paginationControls = document.getElementById('paginationControls');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn'); // New PDF export button

        // New elements for threshold settings page
        const thresholdSettingsBtn = document.getElementById('thresholdSettingsBtn');
        const thresholdSettingsSection = document.getElementById('thresholdSettings');
        const thresholdSettingsTitle = document.getElementById('thresholdSettingsTitle');
        const thresholdSettingsContent = document.getElementById('thresholdSettingsContent');
        const saveThresholdsBtn = document.getElementById('saveThresholdsBtn');
        const resetThresholdsBtn = document.getElementById('resetThresholdsBtn');
        const thresholdMessage = document.getElementById('thresholdMessage');
        const thresholdMessageText = document.getElementById('thresholdMessageText');

        // Sidebar and main content elements
        const sidebar = document.getElementById('sidebar');
        const openSidebarBtn = document.getElementById('openSidebarBtn');
        const closeSidebarBtn = document.getElementById('closeSidebarBtn');
        const mainContentWrapper = document.getElementById('mainContentWrapper');
        const sidebarOverlay = document.getElementById('sidebarOverlay');


        // Metrics to display as charts (including Accel & Gyro)
        const chartMetrics = [
            'Temp√©rature (¬∞C)', 
            'Humidit√© (%)', 
            'Acc√©l√©ration', // Combined metric for X, Y, Z
            'Vibration', 
            'Temp. NTC (¬∞C)', 
            'Courant (V Bruts)', 
            'Batterie (V)',
            'Gyroscope' // Combined metric for X, Y, Z
        ];

        // Define a set of appealing colors for charts
        // Expanded color palette for individual lines within combined charts
        const chartColors = [
            'rgb(75, 192, 192)', // Teal
            'rgb(255, 99, 132)', // Red
            'rgb(54, 162, 235)', // Blue
            'rgb(255, 205, 86)', // Yellow
            'rgb(153, 102, 255)',// Purple
            'rgb(255, 159, 64)', // Orange
            'rgb(201, 203, 207)',// Grey
            'rgb(102, 204, 0)',  // Lime Green
            'rgb(255, 102, 204)',// Pink
            'rgb(0, 153, 153)',  // Dark Teal
            'rgb(204, 51, 0)',   // Dark Red-Orange
            'rgb(51, 102, 255)', // Royal Blue
            'rgb(255, 0, 255)',  // Magenta (new)
            'rgb(0, 255, 255)',  // Cyan (new)
            'rgb(128, 0, 0)'     // Dark Green (new)
        ];

        // Define a set of different point styles for charts
        const pointStyles = [
            'circle',
            'triangle',
            'rect',
            'star',
            'cross',
            'crossRot',
            'dash',
            'line',
            'rectRounded',
            'rectRot',
            'triangle', // Repeat for more options if needed
            'circle', // Additional styles
            'rect',
            'star'
        ];

        // Define thresholds for sensor values (for alert indicators)
        // Store a copy of original thresholds to allow reset
        let THRESHOLDS = {
            'Temp√©rature (¬∞C)': { min: 10, max: 35, warningMin: 15, warningMax: 30 },
            'Humidit√© (%)': { min: 20, max: 80, warningMin: 30, warningMax: 70 },
            'Vibration': { min: 0, max: 100, warningMin: 50, warningMax: 80 }, // Example values
            'Temp. NTC (¬∞C)': { min: 5, max: 40, warningMin: 10, warningMax: 35 },
            'Courant (V Bruts)': { min: 0.1, max: 5.0, warningMin: 0.5, warningMax: 4.5 },
            'Batterie (V)': { min: 3.0, max: 4.2, warningMin: 3.2, warningMax: 4.0 },
            'Acc√©l√©ration X': { min: -5, max: 5, warningMin: -3, warningMax: 3 },
            'Acc√©l√©ration Y': { min: -5, max: 5, warningMin: -3, warningMax: 3 },
            'Acc√©l√©ration Z': { min: -15, max: 15, warningMin: -12, warningMax: 12 }, // Assuming Z is gravity
            'Gyroscope X': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
            'Gyroscope Y': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
            'Gyroscope Z': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
        };
        const ORIGINAL_THRESHOLDS = JSON.parse(JSON.stringify(THRESHOLDS)); // Deep copy for reset


        // Translation object
        const translations = {
            'ar': {
                dashboardTitle: 'ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™',
                latestDataBtn: 'ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿÆŸäÿ±ÿ©',
                accelGyroBtn: 'ÿ™ÿ≥ÿßÿ±ÿπ Ÿàÿ¨Ÿäÿ±Ÿàÿ≥ŸÉŸàÿ®',
                fullTableBtn: 'ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÉÿßŸÖŸÑ',
                chartsBtn: 'ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸäÿ©',
                settingsBtn: 'ÿßŸÑÿπÿØÿßÿØÿßÿ™', 
                loadingText: 'ÿ¨ÿßÿ±Ÿç ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™...',
                errorTitle: 'ÿÆÿ∑ÿ£!',
                errorText: 'ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ŸÖÿµÿØÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ™ÿßÿ≠ Ÿà Apps Script ŸÖŸÜÿ¥Ÿàÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠.',
                latestDataTitle: 'ÿ£ÿ≠ÿØÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ¥ÿπÿ±',
                accelGyroTitle: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿ≥ÿßÿ±ÿπ ŸàÿßŸÑÿ¨Ÿäÿ±Ÿàÿ≥ŸÉŸàÿ®',
                fullTableTitle: 'ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ© ŸÖÿπ ÿßŸÑÿ™ÿµŸÅŸäÿ©',
                fromDateLabel: 'ŸÖŸÜ ÿ™ÿßÿ±ŸäÿÆ:',
                toDateLabel: 'ÿ•ŸÑŸâ ÿ™ÿßÿ±ŸäÿÆ:',
                fromTimeLabel: 'ŸÖŸÜ ÿ™ŸàŸÇŸäÿ™:',
                toTimeLabel: 'ÿ•ŸÑŸâ ÿ™ŸàŸÇŸäÿ™:',
                applyFiltersBtn: 'ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ™ÿµŸÅŸäÿ©',
                resetFiltersBtn: 'ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ',
                exportCsvBtn: 'ÿ™ÿµÿØŸäÿ± CSV', 
                exportPdfBtn: 'ÿ™ÿµÿØŸäÿ± PDF',
                noDataFound: 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑÿπÿ±ÿ∂Ÿáÿß ÿ£Ÿà ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ∑ÿßÿ®ŸÇÿ© ŸÑŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ™ÿµŸÅŸäÿ©.',
                chartsTitle: 'ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸäÿ© ŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ¥ÿπÿ±',
                chartMetricLabel: 'ÿßÿÆÿ™ÿ± ÿßŸÑŸÖŸÇŸäÿßÿ≥:', 
                minLabel: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ:', 
                avgLabel: 'ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑:', 
                maxLabel: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ:', 
                invalidDate: 'ÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠',
                invalidTime: 'ŸàŸÇÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠',
                invalidValue: 'ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠',
                autoRefreshOn: 'ÿ™ÿ≠ÿØŸäÿ´ ÿ™ŸÑŸÇÿßÿ¶Ÿä: ÿ™ÿ¥ÿ∫ŸäŸÑ',
                autoRefreshOff: 'ÿ™ÿ≠ÿØŸäÿ´ ÿ™ŸÑŸÇÿßÿ¶Ÿä: ÿ•ŸäŸÇÿßŸÅ',
                generateInsightBtn: 'ÿ™ŸàŸÑŸäÿØ ÿ±ÿ§Ÿâ ‚ú®',
                insightCardTitle: 'ÿ±ÿ§Ÿâ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™',
                noDataForInsight: 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ŸÑÿ™ŸàŸÑŸäÿØ ÿ±ÿ§Ÿâ.',
                generatingInsight: 'ÿ¨ÿßÿ±Ÿç ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ±ÿ§Ÿâ...',
                insightError: 'ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ±ÿ§Ÿâ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.',
                insightFetchError: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ§Ÿâ ŸÖŸÜ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä',
                copyInsightBtn: 'ŸÜÿ≥ÿÆ ÿßŸÑÿ±ÿ§Ÿäÿ©', 
                copiedSuccess: 'ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑÿ±ÿ§Ÿäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!', 
                copyFailed: 'ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ≥ÿÆ.', 
                healthNormal: 'ÿ≠ÿßŸÑÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: ÿ∑ÿ®ŸäÿπŸäÿ© ‚úÖ', 
                healthWarning: 'ÿ≠ÿßŸÑÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: ÿ™ÿ≠ÿ∞Ÿäÿ± ‚ö†Ô∏è', 
                healthCritical: 'ÿ≠ÿßŸÑÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: ÿ≠ÿ±ÿ¨ ‚ùå', 
                healthUnknown: 'ÿ≠ÿßŸÑÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ ‚ùì', 
                totalEntries: 'ÿßŸÑÿπÿØÿØ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä ŸÑŸÑÿ•ÿØÿÆÿßŸÑÿßÿ™:', 
                criticalAlerts: 'ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ≠ÿ±ÿ¨ÿ©:', 
                warningAlerts: 'ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ™ÿ≠ÿ∞Ÿäÿ±Ÿäÿ©:', 
                thresholdSettingsTitle: 'ÿ•ÿπÿØÿßÿØÿßÿ™ ÿ≠ÿØŸàÿØ ÿßŸÑÿ™ŸÜÿ®ŸäŸá', 
                minThresholdLabel: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ÿØŸÜŸâ:', 
                maxThresholdLabel: 'ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ:', 
                warningMinThresholdLabel: 'ÿ™ÿ≠ÿ∞Ÿäÿ± (ÿ£ÿØŸÜŸâ):', 
                warningMaxThresholdLabel: 'ÿ™ÿ≠ÿ∞Ÿäÿ± (ÿ£ŸÇÿµŸâ):', 
                saveThresholdsBtn: 'ÿ≠ŸÅÿ∏ ÿßŸÑÿ≠ÿØŸàÿØ', 
                resetThresholdsBtn: 'ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≠ÿØŸàÿØ', 
                thresholdsSavedSuccess: 'ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ≠ÿØŸàÿØ ÿ®ŸÜÿ¨ÿßÿ≠!', 
                thresholdsSaveError: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ≠ÿØŸàÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÇŸäŸÖ.', 
                exportPdfError: 'ŸÅÿ¥ŸÑ ÿ™ÿµÿØŸäÿ± PDF.',
                chartLabels: {
                    'Timestamp': 'ÿßŸÑÿÆÿ™ŸÖ ÿßŸÑÿ≤ŸÖŸÜŸä',
                    'Date': 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ',
                    'Heure': 'ÿßŸÑÿ™ŸàŸÇŸäÿ™',
                    'Temp√©rature (¬∞C)': 'ÿØÿ±ÿ¨ÿ© ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ© (¬∞C)',
                    'Humidit√© (%)': 'ÿßŸÑÿ±ÿ∑Ÿàÿ®ÿ© (%)',
                    'Acc√©l√©ration': 'ÿßŸÑÿ™ÿ≥ÿßÿ±ÿπ', 
                    'Acc√©l√©ration X': 'ÿßŸÑÿ™ÿ≥ÿßÿ±ÿπ X',
                    'Acc√©l√©ration Y': 'ÿßŸÑÿ™ÿ≥ÿßÿ±ÿπ Y',
                    'Acc√©l√©ration Z': 'ÿßŸÑÿ™ÿ≥ÿßÿ±ÿπ Z',
                    'Vibration': 'ÿßŸÑÿßŸáÿ™ÿ≤ÿßÿ≤',
                    'Temp. NTC (¬∞C)': 'ÿØÿ±ÿ¨ÿ© ÿ≠ÿ±ÿßÿ±ÿ© NTC (¬∞C)',
                    'Courant (V Bruts)': 'ÿßŸÑÿ™Ÿäÿßÿ± (ŸÅŸàŸÑÿ™ ÿÆÿßŸÖ)',
                    'Batterie (V)': 'ÿßŸÑÿ®ÿ∑ÿßÿ±Ÿäÿ© (ŸÅŸàŸÑÿ™)',
                    'Gyroscope': 'ÿßŸÑÿ¨Ÿäÿ±Ÿàÿ≥ŸÉŸàÿ®', 
                    'Gyroscope X': 'ÿ¨Ÿäÿ±Ÿàÿ≥ŸÉŸàÿ® X',
                    'Gyroscope Y': 'ÿ¨Ÿäÿ±Ÿàÿ≥ŸÉŸàÿ® Y',
                    'Gyroscope Z': 'ÿ¨Ÿäÿ±Ÿàÿ≥ŸÉŸàÿ® Z'
                },
                prevPage: 'ÿßŸÑÿ≥ÿßÿ®ŸÇ',
                nextPage: 'ÿßŸÑÿ™ÿßŸÑŸä',
                pageInfo: (currentPage, totalPages) => `ÿµŸÅÿ≠ÿ© ${currentPage} ŸÖŸÜ ${totalPages}`
            },
            'en': {
                dashboardTitle: 'Data Dashboard',
                latestDataBtn: 'Latest Data',
                accelGyroBtn: 'Acceleration & Gyro',
                fullTableBtn: 'Full Table',
                chartsBtn: 'Charts',
                settingsBtn: 'Settings', 
                loadingText: 'Loading data...',
                errorTitle: 'Error!',
                errorText: 'Failed to load data. Please ensure the data source is available and Apps Script is correctly deployed.',
                latestDataTitle: 'Latest Sensor Data',
                accelGyroTitle: 'Acceleration and Gyroscope Data',
                fullTableTitle: 'Full Data with Filters',
                fromDateLabel: 'From Date:',
                toDateLabel: 'To Date:',
                fromTimeLabel: 'From Time:',
                toTimeLabel: 'To Time:',
                applyFiltersBtn: 'Apply Filter',
                resetFiltersBtn: 'Reset',
                exportCsvBtn: 'Export CSV', 
                exportPdfBtn: 'Export PDF',
                noDataFound: 'No data to display or no data matching filter criteria.',
                chartsTitle: 'Sensor Data Charts',
                chartMetricLabel: 'Select Metric:', 
                minLabel: 'Min:', 
                avgLabel: 'Avg:', 
                maxLabel: 'Max:', 
                invalidDate: 'Invalid Date',
                invalidTime: 'Invalid Time',
                invalidValue: 'Invalid',
                autoRefreshOn: 'Auto Refresh: ON',
                autoRefreshOff: 'Auto Refresh: OFF',
                generateInsightBtn: 'Generate Insight ‚ú®',
                insightCardTitle: 'Data Insight',
                noDataForInsight: 'No data available to generate insights.',
                generatingInsight: 'Generating insight...',
                insightError: 'Failed to generate insight. Please try again.',
                insightFetchError: 'Error fetching insight from AI',
                copyInsightBtn: 'Copy Insight', 
                copiedSuccess: 'Insight copied successfully!', 
                copyFailed: 'Failed to copy.', 
                healthNormal: 'Data Health: Normal ‚úÖ', 
                healthWarning: 'Data Health: Warning ‚ö†Ô∏è', 
                healthCritical: 'Data Health: Critical ‚ùå', 
                healthUnknown: 'Data Health: Unknown ‚ùì', 
                totalEntries: 'Total Entries:', 
                criticalAlerts: 'Critical Alerts:', 
                warningAlerts: 'Warning Alerts:', 
                thresholdSettingsTitle: 'Alert Threshold Settings', 
                minThresholdLabel: 'Min Threshold:', 
                maxThresholdLabel: 'Max Threshold:', 
                warningMinThresholdLabel: 'Warning (Min):', 
                warningMaxThresholdLabel: 'Warning (Max):', 
                saveThresholdsBtn: 'Save Thresholds', 
                resetThresholdsBtn: 'Reset Thresholds', 
                thresholdsSavedSuccess: 'Thresholds saved successfully!', 
                thresholdsSaveError: 'Error saving thresholds. Please check values.', 
                exportPdfError: 'Failed to export PDF.',
                chartLabels: {
                    'Timestamp': 'Timestamp',
                    'Date': 'Date',
                    'Heure': 'Time',
                    'Temp√©rature (¬∞C)': 'Temperature (¬∞C)',
                    'Humidit√© (%)': 'Humidity (%)',
                    'Acc√©l√©ration': 'Acceleration', 
                    'Acc√©l√©ration X': 'Acceleration X',
                    'Acc√©l√©ration Y': 'Acceleration Y',
                    'Acc√©l√©ration Z': 'Acceleration Z',
                    'Vibration': 'Vibration',
                    'Temp. NTC (¬∞C)': 'NTC Temp (¬∞C)',
                    'Courant (V Bruts)': 'Current (Raw V)',
                    'Batterie (V)': 'Battery (V)',
                    'Gyroscope': 'Gyroscope', 
                    'Gyroscope X': 'Gyroscope X',
                    'Gyroscope Y': 'Gyroscope Y',
                    'Gyroscope Z': 'Gyroscope Z'
                },
                prevPage: 'Previous',
                nextPage: 'Next',
                pageInfo: (currentPage, totalPages) => `Page ${currentPage} of ${totalPages}`
            },
            'fr': {
                dashboardTitle: 'Tableau de Bord des Donn√©es',
                latestDataBtn: 'Derni√®res Donn√©es',
                accelGyroBtn: 'Acc√©l√©ration & Gyro',
                fullTableBtn: 'Tableau Complet',
                chartsBtn: 'Graphiques',
                settingsBtn: 'Param√®tres', 
                loadingText: 'Chargement des donn√©es...',
                errorTitle: 'Erreur!',
                errorText: '√âchec du chargement des donn√©es. Veuillez vous assurer que la source de donn√©es est disponible et que le script Apps Script est correctement d√©ploye.',
                latestDataTitle: 'Derni√®res Donn√©es des Capteurs',
                accelGyroTitle: 'Donn√©es d\'Acc√©l√©ration et de Gyroscope',
                fullTableTitle: 'Tableau Complet des Donn√©es avec Filtres',
                fromDateLabel: 'Du Date:',
                toDateLabel: 'Au Date:',
                fromTimeLabel: 'Du Temps:',
                toTimeLabel: 'Au Temps:',
                applyFiltersBtn: 'Appliquer le Filtre',
                resetFiltersBtn: 'R√©initialiser',
                exportCsvBtn: 'Exporter CSV', 
                exportPdfBtn: 'Exporter PDF',
                noDataFound: 'Aucune donn√©e √† afficher ou aucune donn√©e ne correspond aux crit√®res de filtre.',
                chartsTitle: 'Graphiques des Donn√©es des Capteurs',
                chartMetricLabel: 'S√©lectionner une m√©trique:', 
                minLabel: 'Min:', 
                avgLabel: 'Moy:', 
                maxLabel: 'Max:', 
                invalidDate: 'Date Invalide',
                invalidTime: 'Heure Invalide',
                invalidValue: 'Invalide',
                autoRefreshOn: 'Actualisation automatique: ON',
                autoRefreshOff: 'Actualisation automatique: OFF',
                generateInsightBtn: 'G√©n√©rer une perspicacit√© ‚ú®',
                insightCardTitle: 'Perspicacit√© des Donn√©es',
                noDataForInsight: 'Aucune donn√©e disponible pour g√©n√©rer des perspicacit√©s.',
                generatingInsight: 'G√©n√©ration de la perspicacit√©...',
                insightError: '√âchec de la g√©n√©ration de la perspicacit√©. Veuillez r√©essayer.',
                insightFetchError: 'Erreur lors de la r√©cup√©ration de la perspicacit√© ŸÖŸÜ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä',
                copyInsightBtn: 'Copier la perspicacit√©', 
                copiedSuccess: 'Perspicacit√© copi√©e ÿ®ŸÜÿ¨ÿßÿ≠!', 
                copyFailed: '√âchec de la copie.', 
                healthNormal: '√âtat des donn√©es: Normal ‚úÖ', 
                healthWarning: '√âtat des donn√©es: Avertissement ‚ö†Ô∏è', 
                healthCritical: '√âtat des donn√©es: Critique ‚ùå', 
                healthUnknown: '√âtat des donn√©es: Inconnu ‚ùì', 
                totalEntries: 'Total des entr√©es:', 
                criticalAlerts: 'Alertes critiques:', 
                warningAlerts: 'Alertes d\'avertissement:', 
                thresholdSettingsTitle: 'Param√®tres des seuils d\'alerte', 
                minThresholdLabel: 'Seuil Min:', 
                maxThresholdLabel: 'Seuil Max:', 
                warningMinThresholdLabel: 'Avertissement (Min):', 
                warningMaxThresholdLabel: 'Avertissement (Max):', 
                saveThresholdsBtn: 'Enregistrer les seuils', 
                resetThresholdsBtn: 'R√©initialiser les seuils', 
                thresholdsSavedSuccess: 'Seuils enregistr√©s avec succ√®s!', 
                thresholdsSaveError: 'Erreur lors de l\'enregistrement des seuils. Veuillez v√©rifier les valeurs.', 
                exportPdfError: '√âchec de l\'exportation PDF.',
                chartLabels: {
                    'Timestamp': 'Horodatage',
                    'Date': 'Date',
                    'Heure': 'Heure',
                    'Temp√©rature (¬∞C)': 'Temp√©rature (¬∞C)',
                    'Humidit√© (%)': 'Humidit√© (%)',
                    'Acc√©l√©ration': 'Acc√©l√©ration', 
                    'Acc√©l√©ration X': 'Acc√©l√©ration X',
                    'Acc√©l√©ration Y': 'Acc√©l√©ration Y',
                    'Acc√©l√©ration Z': 'Acc√©l√©ration Z',
                    'Vibration': 'Vibration',
                    'Temp. NTC (¬∞C)': 'Temp. NTC (¬∞C)',
                    'Courant (V Bruts)': 'Courant (V bruts)',
                    'Batterie (V)': 'Batterie (V)',
                    'Gyroscope': 'Gyroscope', 
                    'Gyroscope X': 'Gyroscope X',
                    'Gyroscope Y': 'Gyroscope Y',
                    'Gyroscope Z': 'Gyroscope Z'
                },
                prevPage: 'Pr√©c√©dent',
                nextPage: 'Suivant',
                pageInfo: (currentPage, totalPages) => `Page ${currentPage} sur ${totalPages}`
            }
        };

        /**
         * Helper function to parse a date/time string into a Date object.
         * This function assumes the input dateString is in 'YYYY-MM-DD' format and timeString is 'HH:MM:SS'.
         * It constructs an ISO 8601 string and creates a Date object.
         * The 'Z' indicates UTC, so JavaScript will convert it to the local timezone automatically.
         * @param {string} dateString - The date part (e.g., "2025-06-22").
         * @param {string} timeString - The time part (e.g., "17:27:03").
         * @returns {Date | null} A Date object in local timezone, or null if invalid.
         */
        function parseDateTimeToLocalDate(dateString, timeString) {
            // Ensure dateString is justgetFullYear-MM-DD
            let parsedDatePart = String(dateString).split('T')[0];
            // Ensure timeString is just HH:MM:SS
            let parsedTimePart = String(timeString);
            if (parsedTimePart.includes('T')) {
                parsedTimePart = parsedTimePart.split('T')[1].substring(0, 8);
            } else {
                parsedTimePart = parsedTimePart.substring(0, 8);
            }

            // Combine and assume UTC for parsing, then JS converts to local time
            const isoString = `${parsedDatePart}T${parsedTimePart}Z`;
            const date = new Date(isoString);

            return isNaN(date.getTime()) ? null : date;
        }


        /**
         * Helper function to get only the date part formatted for local display.
         * @param {string} dateValue - The original date string from 'Date' column.
         * @param {string} timeValue - The original time string from 'Heure' column.
         * @returns {string} Formatted local date string (e.g., "06/27/2025" for en-US).
         */
        function getFormattedDateForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Use currentLanguage for locale formatting (e.g., 'fr' for dd/mm/yyyy)
                return dateObj.toLocaleDateString(currentLanguage, { year: 'numeric', month: '2-digit', day: '2-digit' });
            }
            return translations[currentLanguage].invalidDate;
        }

        /**
         * Helper function to get only the time part formatted for local display.
         * @param {string} dateValue - The original date string from 'Date' column.
         * @param {string} timeValue - The original time string from 'Heure' column.
         * @returns {string} Formatted local time string (e.g., "14:02:03").
         */
        function getFormattedTimeForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Use currentLanguage for locale formatting (e.g., 'fr' for 24-hour format)
                return dateObj.toLocaleTimeString(currentLanguage, { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
            return translations[currentLanguage].invalidTime;
        }
        
        /**
         * Helper function to format numeric values (e.g., temperature, humidity, acceleration).
         * @param {string | number} value - The numeric value.
         * @param {number} [decimalPlaces=2] - Number of decimal places to format to.
         * @returns {string} Formatted number string or 'Invalid'.
         */
        function formatNumericValue(value, decimalPlaces = 2) {
            const parsedValue = parseFloat(value);
            if (!isNaN(parsedValue)) {
                // Use currentLanguage for locale-specific number formatting (e.g., French uses comma for decimal)
                return parsedValue.toLocaleString(currentLanguage, { minimumFractionDigits: decimalPlaces, maximumFractionDigits: decimalPlaces });
            }
            return translations[currentLanguage].invalidValue;
        }

        /**
         * Updates the display with the current local date and time based on currentLanguage.
         */
        function updateCurrentDateTimeDisplay() {
            const now = new Date();
            const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

            currentDateDisplay.textContent = now.toLocaleDateString(currentLanguage, dateOptions);
            currentTimeDisplay.textContent = now.toLocaleTimeString(currentLanguage, timeOptions);
        }

        /**
         * Shows a specific page section and hides others.
         * Destroys existing chart instances to prevent memory leaks when switching away from charts.
         * @param {string} pageId - The ID of the page section to show.
         */
        function showPage(pageId) {
            // Hide all content sections
            document.querySelectorAll('.page-content').forEach(section => {
                section.classList.add('hidden');
            });
            // Show the requested content section
            document.getElementById(pageId).classList.remove('hidden');

            // Destroy existing single chart instance when leaving charts page
            if (pageId !== 'charts' && chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            
            // Re-render the specific section that is now visible to apply any latest data or language changes
            const filteredData = getFilteredSensorData(); // Get filtered data for the current UI state
            if (pageId === 'latestData') {
                renderLatestData(sensorData); // Latest data always uses full data to find last entry
            } else if (pageId === 'fullTable') {
                currentPage = 1; // Reset to first page when navigating to table
                renderFullTable(filteredData); // Render table with filtered data
            } else if (pageId === 'charts') {
                // Render the selected chart based on the dropdown, or the first one by default
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, filteredData); // Render charts with filtered data
            } else if (pageId === 'accelGyroData') {
                renderAccelGyroData(sensorData);
            } else if (pageId === 'thresholdSettings') {
                renderThresholdSettings(); // Render the settings page
            }

            // Close sidebar if on mobile
            if (window.innerWidth < 768) { // Tailwind's md breakpoint is 768px
                closeSidebar();
            }
        }

        /**
         * Fetches all data from the Google Sheets API.
         * No longer accepts filters, always fetches full dataset.
         */
        async function fetchData() {
            loadingIndicator.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');

            try {
                const response = await fetch(GOOGLE_SHEETS_API_URL); // Fetch all data
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                const data = await response.json();
                
                let actualData = [];
                if (Array.isArray(data) && data.length > 0) {
                    actualData = data;
                } else if (data && Array.isArray(data.data) && data.data.length > 0) {
                    actualData = data.data;
                } else {
                    actualData = []; 
                    console.warn('Data format is invalid or no data found.');
                }
                
                // Sort the data by 'Date' then 'Heure' to ensure the latest data is at the end
                actualData.sort((a, b) => {
                    const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                    const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                    if (!dateA || isNaN(dateA.getTime())) return 1;
                    if (!dateB || isNaN(dateB.getTime())) return -1;
                    return dateA.getTime() - dateB.getTime();
                });

                // Store previous latest entry for comparison before updating sensorData
                if (sensorData.length > 0) {
                    previousLatestEntry = sensorData[sensorData.length - 1];
                } else {
                    previousLatestEntry = {};
                }

                sensorData = actualData; // Store the FULL fetched data
                
                // Re-render based on the currently active page after fetching new data
                const activePageId = document.querySelector('.page-content:not(.hidden)').id;
                const filteredData = getFilteredSensorData(); // Get filtered data for active page if needed

                if (activePageId === 'latestData') {
                    renderLatestData(sensorData);
                } else if (activePageId === 'fullTable') {
                    // Re-render table, staying on the current page if possible
                    renderFullTable(filteredData); 
                } else if (activePageId === 'charts') {
                    const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                    renderChart(selectedMetric, filteredData); // Render selected chart with new data
                } else if (activePageId === 'accelGyroData') {
                    renderAccelGyroData(sensorData);
                }

            } catch (error) {
                console.error('Error fetching data:', error); // Log the full error object
                errorTextSpan.textContent = translations[currentLanguage].errorText + ` (${error.message || error})`;
                errorMessageDiv.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Determines the status of a value against its thresholds.
         * @param {string} metricName - The name of the metric.
         * @param {number} value - The current value.
         * @returns {string} 'normal', 'warning', 'critical', or 'unknown'.
         */
        function getValueStatus(metricName, value) {
            const thresholds = THRESHOLDS[metricName];
            if (!thresholds || isNaN(value)) {
                return 'unknown';
            }

            if (value < thresholds.min || value > thresholds.max) {
                return 'critical';
            } else if (value < thresholds.warningMin || value > thresholds.warningMax) {
                return 'warning';
            } else {
                return 'normal';
            }
        }

        /**
         * Renders the latest sensor data on the main page.
         * Includes value change indicators and threshold alerts.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderLatestData(data) {
            latestDataContent.innerHTML = '';
            
            if (data.length === 0) {
                latestDataContent.innerHTML = `<p class="text-gray-500 text-center col-span-full">${translations[currentLanguage].noDataFound}</p>`;
                insightCard.classList.add('hidden');
                return;
            }

            const latestEntry = data[data.length - 1];
            const labels = translations[currentLanguage].chartLabels;

            // Calculate overall data health and alerts
            let criticalAlertCount = 0;
            let warningAlertCount = 0;
            let overallHealth = 'normal';

            data.forEach(entry => {
                for (const key in entry) {
                    if (entry.hasOwnProperty(key) && THRESHOLDS[key]) {
                        const value = parseFloat(entry[key]);
                        const status = getValueStatus(key, value);
                        if (status === 'critical') {
                            criticalAlertCount++;
                        } else if (status === 'warning') {
                            warningAlertCount++;
                        }
                    }
                }
            });

            if (criticalAlertCount > 0) {
                overallHealth = 'critical';
            } else if (warningAlertCount > 0) {
                overallHealth = 'warning';
            }

            // Create and append Total Entries card
            const totalEntriesCard = document.createElement('div');
            totalEntriesCard.className = 'glassmorphism-card p-6 data-card-interactive';
            totalEntriesCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-2">${translations[currentLanguage].totalEntries}</h3>
                <p class="text-2xl font-bold text-gray-900">${data.length}</p>
            `;
            latestDataContent.appendChild(totalEntriesCard);

            // Create and append Data Health card
            const dataHealthCard = document.createElement('div');
            let healthText = '';
            let healthColor = '';
            if (overallHealth === 'critical') {
                healthText = translations[currentLanguage].healthCritical;
                healthColor = 'text-red-600';
            } else if (overallHealth === 'warning') {
                healthText = translations[currentLanguage].healthWarning;
                healthColor = 'text-orange-500';
            } else {
                healthText = translations[currentLanguage].healthNormal;
                healthColor = 'text-green-600';
            }

            dataHealthCard.className = 'glassmorphism-card p-6 data-card-interactive';
            dataHealthCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-2">Overall Data Health</h3>
                <p class="text-2xl font-bold ${healthColor} mb-2">${healthText}</p>
                <p class="text-lg text-gray-800">${translations[currentLanguage].criticalAlerts} <span class="font-bold text-red-600">${criticalAlertCount}</span></p>
                <p class="text-lg text-gray-800">${translations[currentLanguage].warningAlerts} <span class="font-bold text-orange-500">${warningAlertCount}</span></p>
            `;
            latestDataContent.appendChild(dataHealthCard);


            for (const key in latestEntry) {
                // Exclude the individual Accel and Gyro components from this section, as they are now grouped
                if (latestEntry.hasOwnProperty(key) && 
                    !['Acc√©l√©ration X', 'Acc√©l√©ration Y', 'Acc√©l√©ration Z', 
                       'Gyroscope X', 'Gyroscope Y', 'Gyroscope Z', 'Timestamp', 'Date', 'Heure'].includes(key) &&
                    !['Acc√©l√©ration', 'Gyroscope'].includes(key) // Also exclude the combined metrics to avoid duplicates
                    ) {
                    let valueToDisplay = latestEntry[key];
                    let changeIndicator = '';
                    let alertIndicator = '';

                    const displayLabel = labels[key] || key;

                    if (chartMetrics.includes(key) || 
                                (key.startsWith('Acc√©l√©ration') && chartMetrics.includes('Acc√©l√©ration')) ||
                                (key.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        const numericValue = parseFloat(valueToDisplay);
                        valueToDisplay = formatNumericValue(numericValue);

                        // Value Change Indicator
                        if (previousLatestEntry[key] !== undefined && !isNaN(parseFloat(previousLatestEntry[key]))) {
                            const prevValue = parseFloat(previousLatestEntry[key]);
                            const change = numericValue - prevValue;
                            if (prevValue !== 0) { // Avoid division by zero
                                const percentageChange = (change / prevValue) * 100;
                                let arrow = '';
                                let color = 'text-gray-500';
                                if (change > 0) {
                                    arrow = '‚ñ≤'; // Up arrow
                                    color = 'text-green-500';
                                } else if (change < 0) {
                                    arrow = '‚ñº'; // Down arrow
                                    color = 'text-red-500';
                                }
                                changeIndicator = `<span class="${color} text-sm font-semibold ml-2">${arrow} ${Math.abs(percentageChange).toFixed(1)}%</span>`;
                            }
                        }

                        // Threshold Alert Indicator
                        const status = getValueStatus(key, numericValue);
                        if (status === 'warning') {
                            alertIndicator = '<span class="text-orange-500 ml-2 text-xl" title="Warning: Value near limit">‚ö†Ô∏è</span>';
                        } else if (status === 'critical') {
                            alertIndicator = '<span class="text-red-600 ml-2 text-xl" title="Critical: Value out of limit">‚ùå</span>';
                        }
                    } else if (key === 'Date') {
                        valueToDisplay = getFormattedDateForDisplay(valueToDisplay, latestEntry['Heure']);
                    } else if (key === 'Heure') {
                        valueToDisplay = getFormattedTimeForDisplay(latestEntry['Date'], valueToDisplay);
                    }

                    const dataCard = document.createElement('div');
                    // Added data-card-interactive for animations
                    dataCard.className = 'glassmorphism-card p-6 data-card-interactive';
                    dataCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-blue-700 mb-2">${displayLabel}</h3>
                        <p class="text-2xl font-bold text-gray-900 flex items-center">
                            ${valueToDisplay}
                            ${changeIndicator}
                            ${alertIndicator}
                        </p>
                    `;
                    latestDataContent.appendChild(dataCard);
                }
            }
            insightCard.classList.add('hidden');
            insightContent.textContent = '';
        }

        /**
         * Renders acceleration and gyroscope data in dedicated cards.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderAccelGyroData(data) {
            accelGyroContent.innerHTML = '';
            if (data.length === 0) {
                accelGyroContent.innerHTML = `<p class="text-gray-500 text-center col-span-full">${translations[currentLanguage].noDataFound}</p>`;
                return;
            }

            const latestEntry = data[data.length - 1];
            const labels = translations[currentLanguage].chartLabels;

            // Create Acceleration Card
            const accelCard = document.createElement('div');
            // Added data-card-interactive for animations
            accelCard.className = 'glassmorphism-card p-6 data-card-interactive';
            accelCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-4">${labels['Acc√©l√©ration']}</h3>
                <div class="space-y-2">
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Acc√©l√©ration X']}:</span> ${formatNumericValue(latestEntry['Acc√©l√©ration X'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Acc√©l√©ration X')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Acc√©l√©ration Y']}:</span> ${formatNumericValue(latestEntry['Acc√©l√©ration Y'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Acc√©l√©ration Y')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Acc√©l√©ration Z']}:</span> ${formatNumericValue(latestEntry['Acc√©l√©ration Z'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Acc√©l√©ration Z')}</p>
                </div>
            `;
            accelGyroContent.appendChild(accelCard);

            // Create Gyroscope Card
            const gyroCard = document.createElement('div');
            // Added data-card-interactive for animations
            gyroCard.className = 'glassmorphism-card p-6 data-card-interactive';
            gyroCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-4">${labels['Gyroscope']}</h3>
                <div class="space-y-2">
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope X']}:</span> ${formatNumericValue(latestEntry['Gyroscope X'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope X')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope Y']}:</span> ${formatNumericValue(latestEntry['Gyroscope Y'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope Y')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope Z']}:</span> ${formatNumericValue(latestEntry['Gyroscope Z'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope Z')}</p>
                </div>
            `;
            accelGyroContent.appendChild(gyroCard);
        }

        /**
         * Helper function to generate change indicator and alert for a metric.
         * @param {Object} currentData - The current data entry.
         * @param {Object} prevData - The previous data entry.
         * @param {string} key - The metric key.
         * @returns {string} HTML string for change and alert indicators.
         */
        function getChangeAndAlert(currentData, prevData, key) {
            let changeIndicator = '';
            let alertIndicator = '';
            const numericValue = parseFloat(currentData[key]);

            // Value Change Indicator
            if (prevData[key] !== undefined && !isNaN(parseFloat(prevData[key]))) {
                const prevValue = parseFloat(prevData[key]);
                const change = numericValue - prevValue;
                if (prevValue !== 0) {
                    const percentageChange = (change / prevValue) * 100;
                    let arrow = '';
                    let color = 'text-gray-500';
                    if (change > 0) {
                        arrow = '‚ñ≤';
                        color = 'text-green-500';
                    } else if (change < 0) {
                        arrow = '‚ñº';
                        color = 'text-red-500';
                    }
                    changeIndicator = `<span class="${color} text-sm font-semibold mr-1">${arrow} ${Math.abs(percentageChange).toFixed(1)}%</span>`;
                }
            }

            // Threshold Alert Indicator
            const status = getValueStatus(key, numericValue);
            if (status === 'warning') {
                alertIndicator = '<span class="text-orange-500 ml-1 text-xl" title="Warning: Value near limit">‚ö†Ô∏è</span>';
            } else if (status === 'critical') {
                alertIndicator = '<span class="text-red-600 ml-1 text-xl" title="Critical: Value out of limit">‚ùå</span>';
            }
            return `${changeIndicator}${alertIndicator}`;
        }

        /**
         * Returns a filtered subset of sensorData based on current filter inputs.
         * This function centralizes the filtering logic for both table and charts.
         * @returns {Array<Object>} The filtered data.
         */
        function getFilteredSensorData() {
            let filteredClientData = [...sensorData]; // Start with a copy of all data
            const fromDateVal = fromDateInput.value;
            const toDateVal = toDateInput.value;
            const fromTimeVal = fromTimeInput.value;
            const toTimeVal = toTimeInput.value;

            if (fromDateVal || toDateVal || fromTimeVal || toTimeVal) {
                let filterStartDateTime = null;
                let filterEndDateTime = null;

                // Construct filter start date/time
                if (fromDateVal) {
                    const timePart = fromTimeVal || '00:00:00'; // Default to start of day if no time
                    filterStartDateTime = parseDateTimeToLocalDate(fromDateVal, timePart);
                    if (isNaN(filterStartDateTime.getTime())) filterStartDateTime = null;
                } else if (fromTimeVal) {
                    const today = new Date().toISOString().split('T')[0];
                    filterStartDateTime = parseDateTimeToLocalDate(today, fromTimeVal);
                    if (isNaN(filterStartDateTime.getTime())) filterStartDateTime = null;
                }

                // Construct filter end date/time
                if (toDateVal) {
                    const timePart = toTimeVal || '23:59:59'; // Default to end of day if no time
                    filterEndDateTime = parseDateTimeToLocalDate(toDateVal, timePart);
                    if (isNaN(filterEndDateTime.getTime())) filterEndDateTime = null;
                } else if (toTimeVal) {
                    const today = new Date().toISOString().split('T')[0];
                    filterEndDateTime = parseDateTimeToLocalDate(today, toTimeVal);
                    if (isNaN(filterEndDateTime.getTime())) filterEndDateTime = null;
                }

                filteredClientData = filteredClientData.filter(row => {
                    const rowDateTime = parseDateTimeToLocalDate(row.Date, row.Heure);

                    if (!rowDateTime || isNaN(rowDateTime.getTime())) {
                        return false;
                    }

                    let pass = true;
                    if (filterStartDateTime && rowDateTime < filterStartDateTime) {
                        pass = false;
                    }
                    if (pass && filterEndDateTime && rowDateTime > filterEndDateTime) {
                        pass = false;
                    }
                    return pass;
                });
            }
            return filteredClientData;
        }

        /**
         * Renders the full data table, applying client-side filters and pagination.
         * @param {Array<Object>} dataToRender - The data (already filtered by getFilteredSensorData).
         */
        function renderFullTable(dataToRender) {
            tableHeaderRow.innerHTML = '';
            tableBody.innerHTML = '';
            noDataFoundDiv.classList.add('hidden');

            if (dataToRender.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="100%" class="text-center py-4 text-gray-500">${translations[currentLanguage].noDataFound}</td></tr>`;
                noDataFoundDiv.classList.remove('hidden');
                paginationControls.classList.add('hidden');
                return;
            }

            const headers = Object.keys(dataToRender[0]);
            const translatedHeaders = translations[currentLanguage].chartLabels;

            // Render headers only once
            if (tableHeaderRow.children.length === 0) {
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-left'; // Changed text-right to text-left
                    th.textContent = translatedHeaders[header] || header;
                    tableHeaderRow.appendChild(th);
                });
            }

            // Implement pagination
            const totalPages = Math.ceil(dataToRender.length / itemsPerPage);
            currentPage = Math.min(Math.max(1, currentPage), totalPages); // Ensure currentPage is valid

            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedData = dataToRender.slice(startIndex, endIndex);

            paginatedData.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-900';
                    
                    let cellValue = row[header];
                    if (header === 'Date') {
                        cellValue = getFormattedDateForDisplay(cellValue, row['Heure']);
                    } else if (header === 'Heure') {
                        cellValue = getFormattedTimeForDisplay(row['Date'], cellValue);
                    } else if (chartMetrics.includes(header) || 
                                (header.startsWith('Acc√©l√©ration') && chartMetrics.includes('Acc√©l√©ration')) ||
                                (header.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        cellValue = formatNumericValue(cellValue);
                    }
                    td.textContent = cellValue;
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });

            // Update pagination controls
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;
            pageInfo.textContent = translations[currentLanguage].pageInfo(currentPage, totalPages);
            paginationControls.classList.remove('hidden');
        }

        /**
         * Applies filters by re-rendering the currently active relevant page (table or charts).
         */
        function applyFilters() {
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            const filteredData = getFilteredSensorData(); // Get newly filtered data

            if (activePageId === 'fullTable') {
                currentPage = 1; // Reset to first page on filter change
                renderFullTable(filteredData); // Re-render table
            } else if (activePageId === 'charts') {
                const selectedMetric = chartMetricSelect.value || chartMetrics[0]; // Use current selection or default
                renderChart(selectedMetric, filteredData); // Re-render charts
            }
        }

        /**
         * Resets all filter inputs and re-renders the relevant page with all data.
         */
        function resetFilters() {
            fromDateInput.value = '';
            toDateInput.value = '';
            fromTimeInput.value = '';
            toTimeInput.value = '';
            
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            // When resetting, we effectively want to show all data, so filter with empty criteria
            const allData = getFilteredSensorData(); // This will return sensorData as inputs are empty
            
            if (activePageId === 'fullTable') {
                currentPage = 1; // Reset to first page on filter reset
                renderFullTable(allData); // Re-render table with all data
            } else if (activePageId === 'charts') {
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, allData); // Re-render charts with all data
            }
        }

        /**
         * Populates the chart metric dropdown.
         */
        function populateChartMetricSelect() {
            chartMetricSelect.innerHTML = ''; // Clear existing options
            // Combine chartMetrics with individual Accel/Gyro axes
            const allMetrics = [...new Set(chartMetrics.concat(
                Object.keys(sensorData.length > 0 ? sensorData[0] : {}).filter(key => 
                    key.startsWith('Acc√©l√©ration') || key.startsWith('Gyroscope')
                )
            ))].filter(m => m !== 'Timestamp' && m !== 'Date' && m !== 'Heure'); // Filter out date/time for dropdown
            
            // Reorder to put combined metrics first if they exist
            const orderedMetrics = [];
            if (allMetrics.includes('Acc√©l√©ration')) orderedMetrics.push('Acc√©l√©ration');
            if (allMetrics.includes('Gyroscope')) orderedMetrics.push('Gyroscope');

            // Add other unique metrics that are not combined
            allMetrics.forEach(metric => {
                if (!orderedMetrics.includes(metric) && !metric.startsWith('Acc√©l√©ration ') && !metric.startsWith('Gyroscope ')) {
                    orderedMetrics.push(metric);
                }
            });
            // Add individual Accel/Gyro axes at the end
            allMetrics.forEach(metric => {
                if (!orderedMetrics.includes(metric) && (metric.startsWith('Acc√©l√©ration ') || metric.startsWith('Gyroscope '))) {
                    orderedMetrics.push(metric);
                }
            });


            orderedMetrics.forEach(metric => {
                const option = document.createElement('option');
                option.value = metric;
                option.textContent = translations[currentLanguage].chartLabels[metric] || metric;
                chartMetricSelect.appendChild(option);
            });

            // Set default selection if a value was previously selected
            if (chartMetricSelect.dataset.selected) {
                chartMetricSelect.value = chartMetricSelect.dataset.selected;
            } else {
                chartMetricSelect.value = orderedMetrics[0] || '';
            }
        }


        /**
         * Renders a single chart for the specified metric.
         * @param {string} selectedMetric - The metric to render (e.g., 'Temp√©rature (¬∞C)', 'Acc√©l√©ration').
         * @param {Array<Object>} dataToRender - The data to use for rendering the chart (already filtered).
         */
        function renderChart(selectedMetric, dataToRender) {
            if (dataToRender.length === 0) {
                mainChartCanvas.classList.add('hidden');
                currentChartTitle.textContent = translations[currentLanguage].noDataFound;
                chartStats.classList.add('hidden');
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                return;
            } else {
                mainChartCanvas.classList.remove('hidden');
                chartStats.classList.remove('hidden');
            }

            const sortedData = [...dataToRender].sort((a, b) => {
                const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                if (!dateA || isNaN(dateA.getTime())) return 1;
                if (!dateB || isNaN(dateB.getTime())) return -1;
                return dateA.getTime() - dateB.getTime();
            });

            const labels = sortedData.map(entry => {
                const date = parseDateTimeToLocalDate(entry.Date, entry.Heure);
                if (date && !isNaN(date.getTime())) {
                    return date.toLocaleString(currentLanguage, {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false
                    });
                }
                return translations[currentLanguage].invalidDate + '/' + translations[currentLanguage].invalidTime;
            });

            let datasets = [];
            let chartMetricLabel = translations[currentLanguage].chartLabels[selectedMetric] || selectedMetric;
            currentChartTitle.textContent = chartMetricLabel;

            let values = []; // To store values for min/max/avg calculation

            if (selectedMetric === 'Acc√©l√©ration') {
                ['X', 'Y', 'Z'].forEach((axis, i) => {
                    const componentMetric = `Acc√©l√©ration ${axis}`;
                    const color = chartColors[i % chartColors.length]; // Use limited colors for combined chart
                    const pointStyle = pointStyles[i % pointStyles.length];

                    const dataForAxis = sortedData.map(entry => {
                        const val = parseFloat(entry[componentMetric]);
                        if (!isNaN(val)) values.push(val); // Add to values for stats
                        return val || 0;
                    });

                    datasets.push({
                        label: translations[currentLanguage].chartLabels[componentMetric] || componentMetric,
                        data: dataForAxis,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3, // Smaller points for multi-line
                        pointBackgroundColor: color,
                        pointStyle: pointStyle,
                        fill: false
                    });
                });
            } else if (selectedMetric === 'Gyroscope') {
                ['X', 'Y', 'Z'].forEach((axis, i) => {
                    const componentMetric = `Gyroscope ${axis}`;
                    const color = chartColors[(i + 3) % chartColors.length]; // Offset colors
                    const pointStyle = pointStyles[(i + 3) % pointStyles.length];

                    const dataForAxis = sortedData.map(entry => {
                        const val = parseFloat(entry[componentMetric]);
                        if (!isNaN(val)) values.push(val); // Add to values for stats
                        return val || 0;
                    });

                    datasets.push({
                        label: translations[currentLanguage].chartLabels[componentMetric] || componentMetric,
                        data: dataForAxis,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3, // Smaller points for multi-line
                        pointBackgroundColor: color,
                        pointStyle: pointStyle,
                        fill: false
                    });
                });
            } else {
                // Single metric chart
                const color = chartColors[0]; // Use first color for single charts
                const pointStyle = pointStyles[0];

                const dataForMetric = sortedData.map(entry => {
                    const val = parseFloat(entry[selectedMetric]);
                    if (!isNaN(val)) values.push(val); // Add to values for stats
                    return val || 0;
                });

                datasets.push({
                    label: chartMetricLabel,
                    data: dataForMetric,
                    borderColor: color,
                    backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 5,
                    pointBackgroundColor: color,
                    pointStyle: pointStyle,
                    fill: true
                });
            }

            // Calculate Min, Max, Average
            let min = values.length > 0 ? Math.min(...values) : NaN;
            let max = values.length > 0 ? Math.max(...values) : NaN;
            let sum = values.reduce((a, b) => a + b, 0);
            let avg = values.length > 0 ? sum / values.length : NaN;

            minVal.textContent = `${translations[currentLanguage].minLabel} ${formatNumericValue(min)}`;
            avgVal.textContent = `${translations[currentLanguage].avgLabel} ${formatNumericValue(avg)}`;
            maxVal.textContent = `${translations[currentLanguage].maxLabel} ${formatNumericValue(max)}`;


            if (chartInstance) {
                chartInstance.destroy();
            }

            const ctx = mainChartCanvas.getContext('2d');
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true, // Changed to true for responsiveness
                    maintainAspectRatio: true, // Changed to true for responsiveness
                    plugins: {
                        legend: {
                            display: (selectedMetric === 'Acc√©l√©ration' || selectedMetric === 'Gyroscope'), // Only display legend for combined charts
                            rtl: (currentLanguage === 'ar'),
                            labels: {
                                font: {
                                    size: 12
                                },
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `${translations[currentLanguage].chartLabels['Timestamp']}: ${context[0].label}`;
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toLocaleString(currentLanguage, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                }
                            },
                            rtl: (currentLanguage === 'ar')
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: translations[currentLanguage].chartLabels['Timestamp'],
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 10,
                                font: { size: 10 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: chartMetricLabel,
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                font: { size: 10 },
                                callback: function(value) {
                                    return value.toLocaleString(currentLanguage);
                                }
                            }
                        }
                    },
                    indexAxis: 'x',
                    rtl: (currentLanguage === 'ar') 
                }
            });
        }

        /**
         * Renders the threshold settings page.
         */
        function renderThresholdSettings() {
            thresholdSettingsContent.innerHTML = ''; // Clear previous content
            thresholdMessage.classList.add('hidden'); // Hide any previous messages

            const labels = translations[currentLanguage].chartLabels;
            const t = translations[currentLanguage];

            for (const metric in THRESHOLDS) {
                if (THRESHOLDS.hasOwnProperty(metric)) {
                    const thresholds = THRESHOLDS[metric];
                    const metricLabel = labels[metric] || metric;

                    const metricCard = document.createElement('div');
                    metricCard.className = 'glassmorphism-card p-6 data-card-interactive';
                    metricCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-blue-700 mb-4">${metricLabel}</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="${metric}-min" class="block text-gray-700 text-sm font-medium mb-2">${t.minThresholdLabel}</label>
                                <input type="number" id="${metric}-min" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.min}" step="any">
                            </div>
                            <div>
                                <label for="${metric}-max" class="block text-gray-700 text-sm font-medium mb-2">${t.maxThresholdLabel}</label>
                                <input type="number" id="${metric}-max" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.max}" step="any">
                            </div>
                            <div>
                                <label for="${metric}-warning-min" class="block text-gray-700 text-sm font-medium mb-2">${t.warningMinThresholdLabel}</label>
                                <input type="number" id="${metric}-warning-min" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.warningMin}" step="any">
                            </div>
                            <div>
                                <label for="${metric}-warning-max" class="block text-gray-700 text-sm font-medium mb-2">${t.warningMaxThresholdLabel}</label>
                                <input type="number" id="${metric}-warning-max" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.warningMax}" step="any">
                            </div>
                        </div>
                    `;
                    thresholdSettingsContent.appendChild(metricCard);
                }
            }
        }

        /**
         * Saves the updated thresholds from the input fields.
         */
        function saveThresholds() {
            let allValid = true;
            const newThresholds = {};
            const t = translations[currentLanguage];

            for (const metric in THRESHOLDS) {
                if (THRESHOLDS.hasOwnProperty(metric)) {
                    const minVal = parseFloat(document.getElementById(`${metric}-min`).value);
                    const maxVal = parseFloat(document.getElementById(`${metric}-max`).value);
                    const warningMinVal = parseFloat(document.getElementById(`${metric}-warning-min`).value);
                    const warningMaxVal = parseFloat(document.getElementById(`${metric}-warning-max`).value);

                    // Basic validation: ensure numbers and min <= warningMin <= warningMax <= max
                    if (isNaN(minVal) || isNaN(maxVal) || isNaN(warningMinVal) || isNaN(warningMaxVal) ||
                        minVal > warningMinVal || warningMinVal > warningMaxVal || warningMaxVal > maxVal) {
                        allValid = false;
                        // Optionally, highlight invalid fields or show specific error per field
                        console.error(`Invalid thresholds for ${metric}`);
                        // Break if any invalid, or collect all errors
                        // For now, just mark allValid as false and continue to show general error
                    }

                    newThresholds[metric] = {
                        min: minVal,
                        max: maxVal,
                        warningMin: warningMinVal,
                        warningMax: warningMaxVal
                    };
                }
            }

            if (allValid) {
                THRESHOLDS = newThresholds; // Update the global THRESHOLDS object
                // In a real application, you'd save this to local storage or a backend
                // For now, we update in memory and re-render.
                
                showThresholdMessage(t.thresholdsSavedSuccess, 'success');
                // Re-render the relevant sections to apply new thresholds
                renderLatestData(sensorData);
                const activePageId = document.querySelector('.page-content:not(.hidden)').id;
                if (activePageId === 'charts') {
                    renderChart(chartMetricSelect.value || chartMetrics[0], getFilteredSensorData());
                }
                renderThresholdSettings(); // Re-render settings to show updated values
            } else {
                showThresholdMessage(t.thresholdsSaveError, 'error');
            }
        }

        /**
         * Resets the thresholds to their original default values.
         */
        function resetThresholds() {
            THRESHOLDS = JSON.parse(JSON.stringify(ORIGINAL_THRESHOLDS)); // Restore from original copy
            renderThresholdSettings(); // Re-render the settings page with original values
            
            // Re-render the relevant sections to apply reset thresholds
            renderLatestData(sensorData);
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            if (activePageId === 'charts') {
                renderChart(chartMetricSelect.value || chartMetrics[0], getFilteredSensorData());
            }
            showThresholdMessage(translations[currentLanguage].thresholdsSavedSuccess, 'success'); // Re-using success message for reset
        }


        /**
         * Displays a temporary message (success or error) on the threshold settings page.
         * @param {string} message - The message to display.
         * @param {'success' | 'error'} type - The type of message to determine styling.
         */
        function showThresholdMessage(message, type) {
            thresholdMessageText.textContent = message;
            thresholdMessage.classList.remove('hidden', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-red-100', 'border-red-400', 'text-red-700');
            
            if (type === 'success') {
                thresholdMessage.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
            } else if (type === 'error') {
                thresholdMessage.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            }
            // Automatically hide message after 5 seconds
            setTimeout(() => {
                thresholdMessage.classList.add('hidden');
            }, 5000);
        }

        /**
         * Exports the current active content section to a PDF file.
         */
        async function exportToPDF() {
            try {
                // Determine which section is currently visible
                const activeSection = document.querySelector('.page-content:not(.hidden)');
                if (!activeSection) {
                    alert('No content to export to PDF.');
                    return;
                }

                // If the active section is 'charts', we need to capture the canvas directly
                // to ensure high-quality chart image in the PDF.
                if (activeSection.id === 'charts' && chartInstance) {
                    const chartCanvas = document.getElementById('mainChartCanvas');
                    if (chartCanvas) {
                        const imgData = chartCanvas.toDataURL('image/png');
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF('p', 'mm', 'a4'); // 'p' for portrait, 'mm' for millimeters, 'a4' for A4 size

                        const imgWidth = 200; // A4 width approx 210mm, leave some margin
                        const pageHeight = pdf.internal.pageSize.height;
                        const imgHeight = (chartCanvas.height * imgWidth) / chartCanvas.width;
                        let heightLeft = imgHeight;

                        let position = 10; // Initial Y position for image

                        pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;

                        while (heightLeft >= 0) {
                            position = heightLeft - imgHeight + 10;
                            pdf.addPage();
                            pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                            heightLeft -= pageHeight;
                        }
                        pdf.save('sensor_chart.pdf');
                        return;
                    }
                }

                // For other sections, use html2canvas to capture the active section
                // and then add it to PDF.
                const canvas = await html2canvas(activeSection, {
                    scale: 2, // Increase scale for better resolution
                    logging: false, // Disable logging
                    useCORS: true // Enable CORS for images if any
                });

                const imgData = canvas.toDataURL('image/png');
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4'); // 'p' for portrait, 'mm' for millimeters, 'a4' for A4 size

                const imgWidth = 200; // A4 width approx 210mm, leave some margin
                const pageHeight = pdf.internal.pageSize.height;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                let heightLeft = imgHeight;

                let position = 10; // Initial Y position for image

                pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;

                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight + 10;
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }

                const filename = `${activeSection.id}_report.pdf`;
                pdf.save(filename);

            } catch (error) {
                console.error('Error exporting to PDF:', error);
                alert(translations[currentLanguage].exportPdfError + `\n${error.message}`);
            }
        }


        /**
         * Toggles auto-refresh functionality.
         */
        function toggleAutoRefresh() {
            if (autoRefreshIntervalId) {
                // If auto-refresh is active, stop it
                clearInterval(autoRefreshIntervalId);
                autoRefreshIntervalId = null;
                autoRefreshToggleBtn.textContent = translations[currentLanguage].autoRefreshOff;
                autoRefreshToggleBtn.classList.remove('bg-green-600'); 
                autoRefreshToggleBtn.classList.add('bg-red-600'); 
            } else {
                // If auto-refresh is inactive, start it
                // Fetch data every 15 seconds
                autoRefreshIntervalId = setInterval(fetchData, 15000); 
                autoRefreshToggleBtn.textContent = translations[currentLanguage].autoRefreshOn;
                autoRefreshToggleBtn.classList.remove('bg-red-600'); 
                autoRefreshToggleBtn.classList.add('bg-green-600'); 
            }
        }
        
        /**
         * Translates all text content in the UI based on the selected language.
         * @param {string} lang - The language code ('ar', 'en', 'fr').
         */
        function updateUIForLanguage(lang) {
            currentLanguage = lang;
            const t = translations[currentLanguage];

            // Update header and navigation buttons
            dashboardTitle.textContent = t.dashboardTitle;
            // Sidebar buttons (they are nav-buttons too)
            document.getElementById('latestDataBtn').textContent = t.latestDataBtn;
            document.getElementById('accelGyroBtn').textContent = t.accelGyroBtn;
            document.getElementById('fullTableBtn').textContent = t.fullTableBtn;
            document.getElementById('chartsBtn').textContent = t.chartsBtn;
            document.getElementById('thresholdSettingsBtn').textContent = t.settingsBtn;

            // Update main content titles
            latestDataTitle.textContent = t.latestDataTitle;
            accelGyroTitle.textContent = t.accelGyroTitle;
            fullTableTitle.textContent = t.fullTableTitle;
            chartsTitle.textContent = t.chartsTitle;
            thresholdSettingsTitle.textContent = t.thresholdSettingsTitle;

            // Update filter labels and buttons
            fromDateLabel.textContent = t.fromDateLabel;
            toDateLabel.textContent = t.toDateLabel;
            fromTimeLabel.textContent = t.fromTimeLabel;
            toTimeLabel.textContent = t.toTimeLabel;
            applyFiltersBtn.textContent = t.applyFiltersBtn;
            resetFiltersBtn.textContent = t.resetFiltersBtn;
            exportCsvBtn.textContent = t.exportCsvBtn;
            exportPdfBtn.textContent = t.exportPdfBtn;

            // Update loading and error messages
            loadingText.textContent = t.loadingText;
            errorTitle.textContent = t.errorTitle;
            errorTextSpan.textContent = t.errorText;
            noDataFoundDiv.textContent = t.noDataFound;

            // Update chart labels and stats
            chartMetricSelect.labels = t.chartMetricLabel; // This might not work directly, adjust if needed
            minVal.textContent = `${t.minLabel} N/A`; // Reset and update on renderChart
            avgVal.textContent = `${t.avgLabel} N/A`;
            maxVal.textContent = `${t.maxLabel} N/A`;
            // Ensure the select's label is updated
            document.getElementById('chartMetricLabel').textContent = t.chartMetricLabel;


            // Update auto-refresh button text
            if (autoRefreshIntervalId) {
                autoRefreshToggleBtn.textContent = t.autoRefreshOn;
            } else {
                autoRefreshToggleBtn.textContent = t.autoRefreshOff;
            }

            // Update LLM insight elements
            generateInsightBtn.textContent = t.generateInsightBtn;
            insightCardTitle.textContent = t.insightCardTitle;
            insightLoadingText.textContent = t.generatingInsight;
            copyInsightBtn.textContent = t.copyInsightBtn;

            // Update threshold settings buttons
            saveThresholdsBtn.textContent = t.saveThresholdsBtn;
            resetThresholdsBtn.textContent = t.resetThresholdsBtn;

            // Adjust text alignment and direction based on language
            const html = document.documentElement;
            const body = document.body;
            if (lang === 'ar') {
                html.setAttribute('dir', 'rtl');
                body.style.textAlign = 'right';
                // For RTL, menu buttons are right-aligned
                document.querySelectorAll('.nav-button').forEach(button => {
                    button.classList.remove('text-left');
                    button.classList.add('text-right');
                });
                document.querySelector('h2').textContent = 'ÿßŸÑŸÇÿßÿ¶ŸÖÿ©'; // Update sidebar title
            } else {
                html.setAttribute('dir', 'ltr');
                body.style.textAlign = 'left';
                // For LTR, menu buttons are left-aligned
                document.querySelectorAll('.nav-button').forEach(button => {
                    button.classList.remove('text-right');
                    button.classList.add('text-left');
                });
                document.querySelector('h2').textContent = 'Menu'; // Update sidebar title
            }
            
            // Handle sidebar and main content positioning based on sidebar state and language
            if (window.innerWidth >= 768) { // Desktop view
                // On desktop, sidebar is part of the flex flow, no need for explicit margins on main content wrapper
                mainContentWrapper.classList.remove('shifted-rtl-mobile-open', 'shifted-ltr-mobile-open');
                mainContentWrapper.style.marginLeft = '0'; 
                mainContentWrapper.style.marginRight = '0'; 

                // Sidebar itself should be visible
                sidebar.classList.remove('translate-x-full', '-translate-x-full');
                sidebar.classList.remove('open-rtl', 'open-ltr');
                sidebarOverlay.classList.add('hidden', 'opacity-0');
                isSidebarOpen = true; // For desktop, logically sidebar is always "open"
            } else { // Mobile view
                // On mobile, sidebar is hidden by default and opened/closed by buttons
                mainContentWrapper.classList.remove('shifted-rtl-mobile-open', 'shifted-ltr-mobile-open');
                // Ensure the sidebar is in its correct hidden state based on language
                if (lang === 'ar') {
                    sidebar.classList.add('-translate-x-full'); // Hidden to the left for RTL
                    sidebar.classList.remove('open-rtl');
                } else {
                    sidebar.classList.add('-translate-x-full'); // Hidden to the left for LTR
                    sidebar.classList.remove('open-ltr');
                }
                mainContentWrapper.style.marginLeft = '0'; 
                mainContentWrapper.style.marginRight = '0'; 
                sidebarOverlay.classList.add('hidden', 'opacity-0');
                isSidebarOpen = false; // Reset mobile state
                // If the sidebar was open before resizing to mobile, ensure it closes
                if (sidebar.classList.contains('open-ltr') || sidebar.classList.contains('open-rtl')) {
                    closeSidebar();
                }
            }


            // Re-render current page to apply language changes to dynamic content
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            const filteredData = getFilteredSensorData(); // Get filtered data for active page if needed

            if (activePageId === 'latestData') {
                renderLatestData(sensorData);
            } else if (activePageId === 'fullTable') {
                // Re-render table headers and content
                tableHeaderRow.innerHTML = ''; // Clear existing headers before re-rendering
                const headers = Object.keys(sensorData.length > 0 ? sensorData[0] : {});
                headers.forEach(header => {
                    const th = document.createElement('th');
                    // Set text align based on language for headers
                    th.className = `px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider ${lang === 'ar' ? 'text-right' : 'text-left'}`;
                    th.textContent = t.chartLabels[header] || header;
                    tableHeaderRow.appendChild(th);
                });
                renderFullTable(filteredData);
            } else if (activePageId === 'charts') {
                populateChartMetricSelect(); // Re-populate dropdown with translated options
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, filteredData);
            } else if (activePageId === 'accelGyroData') {
                renderAccelGyroData(sensorData);
            } else if (activePageId === 'thresholdSettings') {
                renderThresholdSettings();
            }

            // Update pagination text
            const totalPages = Math.ceil(getFilteredSensorData().length / itemsPerPage);
            pageInfo.textContent = t.pageInfo(currentPage, totalPages);
        }

        // Functions for LLM insight
        async function generateInsight() {
            if (sensorData.length === 0) {
                insightContent.textContent = translations[currentLanguage].noDataForInsight;
                insightCard.classList.remove('hidden');
                return;
            }

            insightLoading.classList.remove('hidden');
            insightLoadingText.textContent = translations[currentLanguage].generatingInsight;
            insightContent.textContent = '';
            insightCard.classList.remove('hidden'); // Show card during loading

            const latestData = sensorData[sensorData.length - 1];
            const dataToAnalyze = {
                temperature: latestData['Temp√©rature (¬∞C)'],
                humidity: latestData['Humidit√© (%)'],
                vibration: latestData['Vibration'],
                ntcTemp: latestData['Temp. NTC (¬∞C)'],
                current: latestData['Courant (V Bruts)'],
                battery: latestData['Batterie (V)'],
                accelX: latestData['Acc√©l√©ration X'],
                accelY: latestData['Acc√©l√©ration Y'],
                accelZ: latestData['Acc√©l√©ration Z'],
                gyroX: latestData['Gyroscope X'],
                gyroY: latestData['Gyroscope Y'],
                gyroZ: latestData['Gyroscope Z'],
                timestamp: `${latestData['Date']} ${latestData['Heure']}`
            };

            const prompt = `Based on the following sensor data, provide a concise and insightful summary of the current status of the system. Highlight any anomalies, trends, or critical readings. Also, mention the overall health of the system based on these readings. Data: ${JSON.stringify(dataToAnalyze)}.
            Use a helpful and professional tone. Keep it within 3-4 sentences.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(`API error: ${response.status} - ${JSON.stringify(errorResponse)}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const insightText = result.candidates[0].content.parts[0].text;
                    insightContent.textContent = insightText;
                } else {
                    insightContent.textContent = translations[currentLanguage].insightError;
                    console.error('Unexpected API response structure:', result);
                }
            } catch (error) {
                console.error('Error fetching insight from AI:', error);
                insightContent.textContent = translations[currentLanguage].insightFetchError;
            } finally {
                insightLoading.classList.add('hidden');
            }
        }

        function exportToCSV() {
            if (sensorData.length === 0) {
                alert(translations[currentLanguage].noDataFound);
                return;
            }

            const filteredData = getFilteredSensorData(); // Use filtered data for CSV export
            if (filteredData.length === 0) {
                alert(translations[currentLanguage].noDataFound);
                return;
            }

            // Get headers from the first object, and map them to translated headers
            const headers = Object.keys(filteredData[0]);
            const translatedHeaders = headers.map(header => translations[currentLanguage].chartLabels[header] || header);
            
            let csvContent = translatedHeaders.join(',') + '\n';

            filteredData.forEach(row => {
                const rowValues = headers.map(header => {
                    let value = row[header];
                    if (header === 'Date') {
                        value = getFormattedDateForDisplay(value, row['Heure']);
                    } else if (header === 'Heure') {
                        value = getFormattedTimeForDisplay(row['Date'], value);
                    } else if (typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)))) {
                        value = formatNumericValue(value);
                    }
                    // Handle commas within values by enclosing them in double quotes
                    if (typeof value === 'string' && value.includes(',')) {
                        value = `"${value.replace(/"/g, '""')}"`; // Escape double quotes and enclose
                    }
                    return value;
                });
                csvContent += rowValues.join(',') + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'sensor_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Function to copy insight to clipboard
        function copyInsight() {
            const insightText = insightContent.textContent;
            if (!insightText) {
                return;
            }

            // Use document.execCommand('copy') as navigator.clipboard.writeText() might not work in some iframe environments
            const textArea = document.createElement('textarea');
            textArea.value = insightText;
            textArea.style.position = 'fixed'; // Prevents scrolling to bottom
            textArea.style.opacity = '0'; // Make it invisible
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showThresholdMessage(translations[currentLanguage].copiedSuccess, 'success');
                } else {
                    showThresholdMessage(translations[currentLanguage].copyFailed, 'error');
                }
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showThresholdMessage(translations[currentLanguage].copyFailed, 'error');
            } finally {
                document.body.removeChild(textArea);
            }
        }

        /**
         * Opens the sidebar.
         */
        function openSidebar() {
            isSidebarOpen = true;
            if (currentLanguage === 'ar') {
                sidebar.classList.remove('-translate-x-full'); 
                sidebar.classList.add('open-rtl');
                // Apply mobile shift only if on mobile
                if (window.innerWidth < 768) {
                    mainContentWrapper.classList.add('shifted-rtl-mobile-open');
                }
            } else {
                sidebar.classList.remove('-translate-x-full'); 
                sidebar.classList.add('open-ltr');
                // Apply mobile shift only if on mobile
                if (window.innerWidth < 768) {
                    mainContentWrapper.classList.add('shifted-ltr-mobile-open');
                }
            }
            sidebarOverlay.classList.remove('hidden');
            sidebarOverlay.classList.add('show'); // Use 'show' class for opacity transition
        }

        /**
         * Closes the sidebar.
         */
        function closeSidebar() {
            isSidebarOpen = false;
            if (currentLanguage === 'ar') {
                sidebar.classList.add('-translate-x-full'); 
                sidebar.classList.remove('open-rtl');
                mainContentWrapper.classList.remove('shifted-rtl-mobile-open'); // Always remove on close
            } else {
                sidebar.classList.add('-translate-x-full');
                sidebar.classList.remove('open-ltr');
                mainContentWrapper.classList.remove('shifted-ltr-mobile-open'); // Always remove on close
            }
            sidebarOverlay.classList.remove('show'); // Remove 'show' class to fade out
            setTimeout(() => sidebarOverlay.classList.add('hidden'), 300); // Hide overlay after transition
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initial UI update before anything else, so translations are applied early
            updateUIForLanguage(currentLanguage);

            fetchData(); // Fetch all data on page load
            showPage('latestData'); // Show the latest data page by default

            populateChartMetricSelect(); // Populate chart dropdown on load

            // Start auto-refresh by default AFTER toggleAutoRefresh is defined
            toggleAutoRefresh();

            setInterval(updateCurrentDateTimeDisplay, 1000); // Update current date and time every second 

            // Navigation buttons (now in sidebar)
            document.querySelectorAll('.nav-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const targetPage = event.target.dataset.target;
                    showPage(targetPage);
                });
            });

            document.querySelectorAll('.lang-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const lang = event.target.dataset.lang;
                    updateUIForLanguage(lang);
                });
            });

            autoRefreshToggleBtn.addEventListener('click', toggleAutoRefresh);
            generateInsightBtn.addEventListener('click', generateInsight);
            copyInsightBtn.addEventListener('click', copyInsight); // New event listener for copy insight

            applyFiltersBtn.addEventListener('click', applyFilters); // Client-side filter application
            resetFiltersBtn.addEventListener('click', resetFilters); // Client-side filter reset
            exportCsvBtn.addEventListener('click', exportToCSV); // New event listener for CSV export
            exportPdfBtn.addEventListener('click', exportToPDF); // New event listener for PDF export

            // Pagination event listeners
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderFullTable(getFilteredSensorData());
                }
            });
            nextPageBtn.addEventListener('click', () => {
                const filteredData = getFilteredSensorData();
                const totalPages = Math.ceil(filteredData.length / itemsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderFullTable(filteredData);
                }
            });

            // Chart metric selection event listener
            chartMetricSelect.addEventListener('change', () => {
                const selectedMetric = chartMetricSelect.value;
                chartMetricSelect.dataset.selected = selectedMetric; // Store selection
                renderChart(selectedMetric, getFilteredSensorData());
            });

            // Event listeners for threshold settings page
            saveThresholdsBtn.addEventListener('click', saveThresholds);
            resetThresholdsBtn.addEventListener('click', resetThresholds);

            // Sidebar toggle events
            openSidebarBtn.addEventListener('click', openSidebar);
            closeSidebarBtn.addEventListener('click', closeSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar); // Close sidebar when clicking overlay
            
            // Adjust sidebar positioning on window resize for responsiveness
            window.addEventListener('resize', () => {
                if (window.innerWidth >= 768) { // Desktop view
                    // On desktop, sidebar is part of the flex flow, no need for explicit margins on main content wrapper
                    mainContentWrapper.classList.remove('shifted-rtl-mobile-open', 'shifted-ltr-mobile-open');
                    mainContentWrapper.style.marginLeft = '0'; 
                    mainContentWrapper.style.marginRight = '0'; 

                    // Sidebar itself should be visible
                    sidebar.classList.remove('translate-x-full', '-translate-x-full');
                    sidebar.classList.remove('open-rtl', 'open-ltr');
                    sidebarOverlay.classList.add('hidden', 'opacity-0');
                    isSidebarOpen = true; // For desktop, logically sidebar is always "open"
                } else { // Mobile view
                    // On mobile, sidebar is hidden by default and opened/closed by buttons
                    mainContentWrapper.classList.remove('shifted-rtl-mobile-open', 'shifted-ltr-mobile-open');
                    // Ensure the sidebar is in its correct hidden state based on language
                    if (currentLanguage === 'ar') {
                        sidebar.classList.add('-translate-x-full'); // Hidden to the left for RTL
                        sidebar.classList.remove('open-rtl');
                    } else {
                        sidebar.classList.add('-translate-x-full'); // Hidden to the left for LTR
                        sidebar.classList.remove('open-ltr');
                    }
                    mainContentWrapper.style.marginLeft = '0'; 
                    mainContentWrapper.style.marginRight = '0'; 
                    sidebarOverlay.classList.add('hidden', 'opacity-0');
                    isSidebarOpen = false; // Reset mobile state
                    // If the sidebar was open before resizing to mobile, ensure it closes
                    if (sidebar.classList.contains('open-ltr') || sidebar.classList.contains('open-rtl')) {
                        closeSidebar();
                    }
                }
                updateUIForLanguage(currentLanguage); // Re-apply language specific styles and re-render charts
            });
        });

    </script>
</body>
</html>
