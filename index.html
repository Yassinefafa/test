<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>لوحة تحكم بيانات المستشعر</title>
    <!-- Favicon - Added to fix 404 error -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📊</text></svg>">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            direction: rtl; /* Default to RTL for Arabic initially, will be changed by JS for LTR languages */
            text-align: right; /* Default to right for Arabic, will be changed by JS for LTR languages */
            /* Modern gradient background for the body */
            background: linear-gradient(to bottom right, #e0f2fe, #eef2ff); /* from-blue-50 to-indigo-50 equivalent */
            min-height: 100vh; /* Ensure the gradient covers the entire viewport height */
        }
        .container {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding: 1rem;
        }
        .hidden {
            display: none;
        }
        /* Custom scrollbar for table */
        .overflow-x-auto::-webkit-scrollbar {
            height: 8px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Glassmorphism effect for cards */
        .glassmorphism-card {
            background-color: rgba(255, 255, 255, 0.15); /* Slightly transparent white */
            backdrop-filter: blur(10px); /* Blur behind the element */
            -webkit-backdrop-filter: blur(10px); /* For Safari support */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle white border */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2); /* Softer shadow for depth */
            border-radius: 0.75rem; /* Matches Tailwind's rounded-lg */
        }
        /* Enhanced interactivity for cards */
        .data-card-interactive {
            transform: scale(1);
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .data-card-interactive:hover {
            transform: scale(1.03);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body class="text-gray-800"> <!-- Removed bg-gray-100 as custom gradient is applied -->
    <!-- Header and Navigation -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 shadow-lg py-4">
        <nav class="container flex justify-between items-center flex-wrap gap-4">
            <h1 id="dashboardTitle" class="text-white text-3xl font-bold rounded-lg px-3 py-1 bg-opacity-20 bg-white">
                لوحة تحكم البيانات
            </h1>
            <!-- Current Date and Time Display -->
            <div class="flex items-center space-x-4 space-x-reverse text-white text-lg font-semibold">
                <div id="currentDate" class="px-3 py-1 rounded-full bg-blue-500 bg-opacity-40 shadow-md"></div>
                <div id="currentTime" class="px-3 py-1 rounded-full bg-indigo-500 bg-opacity-40 shadow-md"></div>
            </div>
            <!-- Language Selector -->
            <div class="flex space-x-2">
                <button class="lang-button px-4 py-2 rounded-full text-sm font-semibold text-white bg-gray-600 hover:bg-gray-500 transition duration-300" data-lang="ar">العربية</button>
                <button class="lang-button px-4 py-2 rounded-full text-sm font-semibold text-white bg-gray-600 hover:bg-gray-500 transition duration-300" data-lang="en">English</button>
                <button class="lang-button px-4 py-2 rounded-full text-sm font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300" data-lang="fr">Français</button>
            </div>
            <div class="flex space-x-4 space-x-reverse"> <!-- space-x-reverse for RTL -->
                <button id="latestDataBtn" class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="latestData">
                    البيانات الأخيرة
                </button>
                <button id="accelGyroBtn" class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="accelGyroData">
                    تسارع وجيروسكوب
                </button>
                <button id="fullTableBtn" class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="fullTable">
                    الجدول الكامل
                </button>
                <button id="chartsBtn" class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="charts">
                    الرسوم البيانية
                </button>
                <!-- Auto Refresh Toggle Button -->
                <button id="autoRefreshToggleBtn" class="px-6 py-2 rounded-full text-lg font-semibold text-white bg-green-500 hover:bg-green-400 transition duration-300 transform hover:scale-105 shadow-md">
                    تحديث تلقائي: تشغيل
                </button>
            </div>
        </nav>
    </header>

    <!-- Main Content Area -->
    <main class="container my-8">
        <!-- New wrapper div for main content styling -->
        <div class="bg-white p-8 rounded-lg shadow-xl border border-gray-200">
            <!-- Loading Indicator -->
            <div id="loading" class="text-center text-xl font-semibold text-blue-600 my-10 hidden">
                <div class="flex items-center justify-center space-x-2 space-x-reverse">
                    <svg class="animate-spin h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="loadingText">جارٍ تحميل البيانات...</span>
                </div>
            </div>

            <!-- Error Message -->
            <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative my-6 hidden" role="alert">
                <strong id="errorTitle" class="font-bold">خطأ!</strong>
                <span class="block sm:inline" id="errorText">تعذر تحميل البيانات. يرجى التأكد من أن مصدر البيانات متاح و Apps Script منشور بشكل صحيح.</span>
                <span class="absolute top-0 bottom-0 left-0 px-4 py-3">
                    <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="document.getElementById('errorMessage').classList.add('hidden')">
                        <title>إغلاق</title>
                        <path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/>
                    </svg>
                </span>
            </div>

            <!-- Latest Data Section -->
            <section id="latestData" class="page-content"> <!-- Removed bg-white, p-8 etc. as they are on the parent wrapper -->
                <h2 id="latestDataTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    أحدث بيانات المستشعر
                </h2>
                <div class="flex justify-start mb-6"> <!-- Aligned to right for RTL, left for LTR -->
                    <button id="generateInsightBtn" class="px-6 py-2 rounded-full text-lg font-semibold text-white bg-purple-600 hover:bg-purple-500 transition duration-300 transform hover:scale-105 shadow-md">
                        Generate Insight ✨
                    </button>
                </div>
                <div id="latestDataContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Latest data will be injected here by JavaScript -->
                </div>
                <!-- This div will be shown/hidden by JS when insight is generated -->
                <!-- Glassmorphism applied to insight card -->
                <div id="insightCard" class="glassmorphism-card p-6 col-span-full mt-6 hidden">
                    <h3 id="insightCardTitle" class="text-xl font-semibold text-purple-700 mb-4"></h3>
                    <p id="insightContent" class="text-gray-800 text-base leading-relaxed"></p>
                    <div class="flex justify-end mt-4">
                        <button id="copyInsightBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 text-sm">
                            نسخ الرؤية
                        </button>
                    </div>
                    <div id="insightLoading" class="text-center text-sm text-purple-600 mt-4 hidden">
                        <svg class="animate-spin h-5 w-5 inline-block text-purple-600 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span id="insightLoadingText"></span>
                    </div>
                </div>
            </section>

            <!-- Acceleration and Gyroscope Data Section -->
            <section id="accelGyroData" class="page-content hidden"> <!-- Removed bg-white, p-8 etc. -->
                <h2 id="accelGyroTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    بيانات التسارع والجيروسكوب
                </h2>
                <div id="accelGyroContent" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Acceleration and Gyroscope data will be injected here by JavaScript -->
                </div>
            </section>

            <!-- Full Table Section -->
            <section id="fullTable" class="page-content hidden"> <!-- Removed bg-white, p-8 etc. -->
                <h2 id="fullTableTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    البيانات الكاملة مع التصفية
                </h2>

                <!-- Filters -->
                <div class="mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-4"> <!-- Restored 4 columns for time filters -->
                        <div>
                            <label id="fromDateLabel" for="fromDate" class="block text-gray-700 text-sm font-medium mb-2">من تاريخ:</label>
                            <input type="date" id="fromDate" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                        <div>
                            <label id="toDateLabel" for="toDate" class="block text-gray-700 text-sm font-medium mb-2">إلى تاريخ:</label>
                            <input type="date" id="toDate" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                        <div>
                            <label id="fromTimeLabel" for="fromTime" class="block text-gray-700 text-sm font-medium mb-2">من توقيت:</label>
                            <input type="time" id="fromTime" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                        <div>
                            <label id="toTimeLabel" for="toTime" class="block text-gray-700 text-sm font-medium mb-2">إلى توقيت:</label>
                            <input type="time" id="toTime" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                    </div>
                    <div class="flex justify-start space-x-4 space-x-reverse">
                        <button id="applyFiltersBtn" class="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-300 transform hover:scale-105 shadow-lg">
                            تطبيق التصفية
                        </button>
                        <button id="resetFiltersBtn" class="px-8 py-3 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition duration-300 transform hover:scale-105 shadow-lg">
                            إعادة تعيين
                        </button>
                        <button id="exportCsvBtn" class="px-8 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 shadow-lg">
                            تصدير CSV
                        </button>
                    </div>
                </div>

                <!-- Data Table -->
                <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                    <table id="dataTable" class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-100">
                            <tr id="tableHeaderRow">
                                <!-- Headers will be injected here -->
                            </tr>
                        </thead>
                        <tbody id="tableBody" class="bg-white divide-y divide-gray-200">
                            <!-- Data rows will be injected here -->
                        </tbody>
                    </table>
                    <div id="noDataFound" class="hidden text-center py-8 text-gray-500 text-lg">
                        لا توجد بيانات مطابقة لمعايير التصفية.
                    </div>
                </div>
                <!-- Pagination Controls -->
                <div id="paginationControls" class="flex justify-center items-center space-x-4 mt-6">
                    <button id="prevPageBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">السابق</button>
                    <span id="pageInfo" class="text-gray-700">صفحة 1 من 1</span>
                    <button id="nextPageBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">التالي</button>
                </div>
            </section>

            <!-- Charts Section -->
            <section id="charts" class="page-content hidden"> <!-- Removed bg-white, p-8 etc. -->
                <h2 id="chartsTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    الرسوم البيانية لبيانات المستشعر
                </h2>
                <!-- Chart Controls (Dropdown for Metric Selection) -->
                <div class="mb-6 p-4 bg-gray-50 rounded-lg shadow-inner flex flex-col sm:flex-row items-start sm:items-center gap-4">
                    <label for="chartMetricSelect" id="chartMetricLabel" class="text-gray-700 font-medium whitespace-nowrap">اختر المقياس:</label>
                    <select id="chartMetricSelect" class="form-select flex-grow p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>

                <!-- Single Chart Canvas -->
                <div id="singleChartContainer" class="glassmorphism-card p-6 flex flex-col justify-center items-center">
                    <h3 id="currentChartTitle" class="text-xl font-semibold text-blue-700 mb-4 text-center"></h3>
                    <canvas id="mainChartCanvas" width="350" height="288"></canvas>
                    <!-- Min/Max/Avg Display -->
                    <div id="chartStats" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-4 w-full text-center">
                        <div class="p-2 bg-blue-50 rounded-md">
                            <p id="minVal" class="text-sm font-semibold text-gray-700">الحد الأدنى: N/A</p>
                        </div>
                        <div class="p-2 bg-blue-50 rounded-md">
                            <p id="avgVal" class="text-sm font-semibold text-gray-700">المتوسط: N/A</p>
                        </div>
                        <div class="p-2 bg-blue-50 rounded-md">
                            <p id="maxVal" class="text-sm font-semibold text-gray-700">الحد الأقصى: N/A</p>
                        </div>
                    </div>
                </div>
            </section>
        </div> <!-- End of new wrapper div -->
    </main>

    <script>
        // Google Sheets API URL - Ensure this URL is correct and published to 'Anyone' access
        // Replace 'YOUR_GOOGLE_SHEETS_API_URL_HERE' with your actual deployed Google Apps Script URL.
        // It should look something like: 'https://script.google.com/macros/s/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/exec'
        const GOOGLE_SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbxO7soutfxNmG1Vy6KvuZ4ZS96qWg9nJouY-vjvKt3_i-kQh4wa3hBbU0-vuqgU8jF02g/exec';

        // Global variables
        let sensorData = []; // To store ALL fetched data
        let previousLatestEntry = {}; // To store the previous latest data for change indicators
        let chartInstance = null; // Single Chart.js instance for the main chart
        let currentLanguage = 'ar'; // Default language is Arabic
        let autoRefreshIntervalId = null; // Stores the ID of the setInterval for auto-refresh
        let currentPage = 1;
        const itemsPerPage = 20; // Number of rows per page for the full table

        // DOM Elements
        const loadingIndicator = document.getElementById('loading');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorTextSpan = document.getElementById('errorText');
        const latestDataSection = document.getElementById('latestData');
        const latestDataContent = document.getElementById('latestDataContent');
        const fullTableSection = document.getElementById('fullTable');
        const chartsSection = document.getElementById('charts');
        const dataTable = document.getElementById('dataTable');
        const tableHeaderRow = document.getElementById('tableHeaderRow');
        const tableBody = document.getElementById('tableBody');
        const fromDateInput = document.getElementById('fromDate');
        const toDateInput = document.getElementById('toDate');
        const fromTimeInput = document.getElementById('fromTime');
        const toTimeInput = document.getElementById('toTime');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const noDataFoundDiv = document.getElementById('noDataFound');
        const chartsContainer = document.getElementById('chartsContainer'); // Now holds dropdown and single chart
        const mainChartCanvas = document.getElementById('mainChartCanvas'); // The single chart canvas
        const chartMetricSelect = document.getElementById('chartMetricSelect'); // Dropdown for metric selection
        const currentChartTitle = document.getElementById('currentChartTitle'); // Title for the selected chart
        const chartStats = document.getElementById('chartStats'); // Div to display min/avg/max
        const minVal = document.getElementById('minVal');
        const avgVal = document.getElementById('avgVal');
        const maxVal = document.getElementById('maxVal');


        // Elements for current date/time display
        const currentDateDisplay = document.getElementById('currentDate');
        const currentTimeDisplay = document.getElementById('currentTime');

        // Elements for language update
        const dashboardTitle = document.getElementById('dashboardTitle');
        const latestDataTitle = document.getElementById('latestDataTitle');
        const fullTableTitle = document.getElementById('fullTableTitle');
        const chartsTitle = document.getElementById('chartsTitle');
        const fromDateLabel = document.getElementById('fromDateLabel');
        const toDateLabel = document.getElementById('toDateLabel');
        const fromTimeLabel = document.getElementById('fromTimeLabel');
        const toTimeLabel = document.getElementById('toTimeLabel');
        const loadingText = document.getElementById('loadingText');
        const errorTitle = document.getElementById('errorTitle');

        // New elements for Acceleration and Gyroscope section
        const accelGyroDataSection = document.getElementById('accelGyroData');
        const accelGyroTitle = document.getElementById('accelGyroTitle');
        const accelGyroContent = document.getElementById('accelGyroContent');

        // New element for auto-refresh button
        const autoRefreshToggleBtn = document.getElementById('autoRefreshToggleBtn');

        // New elements for LLM insight
        const insightCard = document.getElementById('insightCard');
        const insightCardTitle = document.getElementById('insightCardTitle');
        const insightContent = document.getElementById('insightContent');
        const insightLoading = document.getElementById('insightLoading');
        const insightLoadingText = document.getElementById('insightLoadingText');
        const generateInsightBtn = document.getElementById('generateInsightBtn');
        const copyInsightBtn = document.getElementById('copyInsightBtn'); // New copy insight button

        // Pagination elements
        const paginationControls = document.getElementById('paginationControls');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const exportCsvBtn = document.getElementById('exportCsvBtn');


        // Metrics to display as charts (including Accel & Gyro)
        const chartMetrics = [
            'Température (°C)', 
            'Humidité (%)', 
            'Accélération', // Combined metric for X, Y, Z
            'Vibration', 
            'Temp. NTC (°C)', 
            'Courant (V Bruts)', 
            'Batterie (V)',
            'Gyroscope' // Combined metric for X, Y, Z
        ];

        // Define a set of appealing colors for charts
        // Expanded color palette for individual lines within combined charts
        const chartColors = [
            'rgb(75, 192, 192)', // Teal
            'rgb(255, 99, 132)', // Red
            'rgb(54, 162, 235)', // Blue
            'rgb(255, 205, 86)', // Yellow
            'rgb(153, 102, 255)',// Purple
            'rgb(255, 159, 64)', // Orange
            'rgb(201, 203, 207)',// Grey
            'rgb(102, 204, 0)',  // Lime Green
            'rgb(255, 102, 204)',// Pink
            'rgb(0, 153, 153)',  // Dark Teal
            'rgb(204, 51, 0)',   // Dark Red-Orange
            'rgb(51, 102, 255)', // Royal Blue
            'rgb(255, 0, 255)',  // Magenta (new)
            'rgb(0, 255, 255)',  // Cyan (new)
            'rgb(128, 0, 0)',    // Maroon (new)
            'rgb(0, 128, 0)'     // Dark Green (new)
        ];

        // Define a set of different point styles for charts
        const pointStyles = [
            'circle',
            'triangle',
            'rect',
            'star',
            'cross',
            'crossRot',
            'dash',
            'line',
            'rectRounded',
            'rectRot',
            'triangle', // Repeat for more options if needed
            'circle', // Additional styles
            'rect',
            'star'
        ];

        // Define thresholds for sensor values (for alert indicators)
        const THRESHOLDS = {
            'Température (°C)': { min: 10, max: 35, warningMin: 15, warningMax: 30 },
            'Humidité (%)': { min: 20, max: 80, warningMin: 30, warningMax: 70 },
            'Vibration': { min: 0, max: 100, warningMin: 50, warningMax: 80 }, // Example values
            'Temp. NTC (°C)': { min: 5, max: 40, warningMin: 10, warningMax: 35 },
            'Courant (V Bruts)': { min: 0.1, max: 5.0, warningMin: 0.5, warningMax: 4.5 },
            'Batterie (V)': { min: 3.0, max: 4.2, warningMin: 3.2, warningMax: 4.0 },
            // For acceleration and gyroscope, define thresholds for individual components if desired,
            // or a combined magnitude threshold. For simplicity, we can alert on extremes of individual axes.
            'Accélération X': { min: -5, max: 5, warningMin: -3, warningMax: 3 },
            'Accélération Y': { min: -5, max: 5, warningMin: -3, warningMax: 3 },
            'Accélération Z': { min: -15, max: 15, warningMin: -12, warningMax: 12 }, // Assuming Z is gravity
            'Gyroscope X': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
            'Gyroscope Y': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
            'Gyroscope Z': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
        };


        // Translation object
        const translations = {
            'ar': {
                dashboardTitle: 'لوحة تحكم البيانات',
                latestDataBtn: 'البيانات الأخيرة',
                accelGyroBtn: 'تسارع وجيروسكوب',
                fullTableBtn: 'الجدول الكامل',
                chartsBtn: 'الرسوم البيانية',
                loadingText: 'جارٍ تحميل البيانات...',
                errorTitle: 'خطأ!',
                errorText: 'تعذر تحميل البيانات. يرجى التأكد من أن مصدر البيانات متاح و Apps Script منشور بشكل صحيح.',
                latestDataTitle: 'أحدث بيانات المستشعر',
                accelGyroTitle: 'بيانات التسارع والجيروسكوب',
                fullTableTitle: 'البيانات الكاملة مع التصفية',
                fromDateLabel: 'من تاريخ:',
                toDateLabel: 'إلى تاريخ:',
                fromTimeLabel: 'من توقيت:',
                toTimeLabel: 'إلى توقيت:',
                applyFiltersBtn: 'تطبيق التصفية',
                resetFiltersBtn: 'إعادة تعيين',
                exportCsvBtn: 'تصدير CSV', // New translation
                noDataFound: 'لا توجد بيانات لعرضها أو لا توجد بيانات مطابقة لمعايير التصفية.',
                chartsTitle: 'الرسوم البيانية لبيانات المستشعر',
                chartMetricLabel: 'اختر المقياس:', // New translation
                minLabel: 'الحد الأدنى:', // New translation
                avgLabel: 'المتوسط:', // New translation
                maxLabel: 'الحد الأقصى:', // New translation
                invalidDate: 'تاريخ غير صالح',
                invalidTime: 'وقت غير صالح',
                invalidValue: 'غير صالح',
                autoRefreshOn: 'تحديث تلقائي: تشغيل',
                autoRefreshOff: 'تحديث تلقائي: إيقاف',
                generateInsightBtn: 'توليد رؤى ✨',
                insightCardTitle: 'رؤى البيانات',
                noDataForInsight: 'لا توجد بيانات متاحة لتوليد رؤى.',
                generatingInsight: 'جارٍ توليد الرؤى...',
                insightError: 'فشل توليد الرؤى. يرجى المحاولة مرة أخرى.',
                insightFetchError: 'خطأ في جلب الرؤى من الذكاء الاصطناعي',
                copyInsightBtn: 'نسخ الرؤية', // New translation
                copiedSuccess: 'تم نسخ الرؤية بنجاح!', // New translation
                copyFailed: 'فشل النسخ.', // New translation
                healthNormal: 'حالة البيانات: طبيعية ✅', // New translation
                healthWarning: 'حالة البيانات: تحذير ⚠️', // New translation
                healthCritical: 'حالة البيانات: حرج ❌', // New translation
                healthUnknown: 'حالة البيانات: غير معروف ❓', // New translation
                chartLabels: {
                    'Timestamp': 'الختم الزمني',
                    'Date': 'التاريخ',
                    'Heure': 'التوقيت',
                    'Température (°C)': 'درجة الحرارة (°C)',
                    'Humidité (%)': 'الرطوبة (%)',
                    'Accélération': 'التسارع', // Combined label
                    'Accélération X': 'التسارع X',
                    'Accélération Y': 'التسارع Y',
                    'Accélération Z': 'التسارع Z',
                    'Vibration': 'الاهتزاز',
                    'Temp. NTC (°C)': 'درجة حرارة NTC (°C)',
                    'Courant (V Bruts)': 'التيار (فولت خام)',
                    'Batterie (V)': 'البطارية (فولت)',
                    'Gyroscope': 'الجيروسكوب', // Combined label
                    'Gyroscope X': 'جيروسكوب X',
                    'Gyroscope Y': 'جيروسكوب Y',
                    'Gyroscope Z': 'جيروسكوب Z'
                },
                prevPage: 'السابق',
                nextPage: 'التالي',
                pageInfo: (currentPage, totalPages) => `صفحة ${currentPage} من ${totalPages}`
            },
            'en': {
                dashboardTitle: 'Data Dashboard',
                latestDataBtn: 'Latest Data',
                accelGyroBtn: 'Acceleration & Gyro',
                fullTableBtn: 'Full Table',
                chartsBtn: 'Charts',
                loadingText: 'Loading data...',
                errorTitle: 'Error!',
                errorText: 'Failed to load data. Please ensure the data source is available and Apps Script is correctly deployed.',
                latestDataTitle: 'Latest Sensor Data',
                accelGyroTitle: 'Acceleration and Gyroscope Data',
                fullTableTitle: 'Full Data with Filters',
                fromDateLabel: 'From Date:',
                toDateLabel: 'To Date:',
                fromTimeLabel: 'From Time:',
                toTimeLabel: 'To Time:',
                applyFiltersBtn: 'Apply Filter',
                resetFiltersBtn: 'Reset',
                exportCsvBtn: 'Export CSV', // New translation
                noDataFound: 'No data to display or no data matching filter criteria.',
                chartsTitle: 'Sensor Data Charts',
                chartMetricLabel: 'Select Metric:', // New translation
                minLabel: 'Min:', // New translation
                avgLabel: 'Avg:', // New translation
                maxLabel: 'Max:', // New translation
                invalidDate: 'Invalid Date',
                invalidTime: 'Invalid Time',
                invalidValue: 'Invalid',
                autoRefreshOn: 'Auto Refresh: ON',
                autoRefreshOff: 'Auto Refresh: OFF',
                generateInsightBtn: 'Generate Insight ✨',
                insightCardTitle: 'Data Insight',
                noDataForInsight: 'No data available to generate insights.',
                generatingInsight: 'Generating insight...',
                insightError: 'Failed to generate insight. Please try again.',
                insightFetchError: 'Error fetching insight from AI',
                copyInsightBtn: 'Copy Insight', // New translation
                copiedSuccess: 'Insight copied successfully!', // New translation
                copyFailed: 'Failed to copy.', // New translation
                healthNormal: 'Data Health: Normal ✅', // New translation
                healthWarning: 'Data Health: Warning ⚠️', // New translation
                healthCritical: 'Data Health: Critical ❌', // New translation
                healthUnknown: 'Data Health: Unknown ❓', // New translation
                chartLabels: {
                    'Timestamp': 'Timestamp',
                    'Date': 'Date',
                    'Heure': 'Time',
                    'Température (°C)': 'Temperature (°C)',
                    'Humidité (%)': 'Humidity (%)',
                    'Accélération': 'Acceleration', // Combined label
                    'Accélération X': 'Acceleration X',
                    'Accélération Y': 'Acceleration Y',
                    'Accélération Z': 'Acceleration Z',
                    'Vibration': 'Vibration',
                    'Temp. NTC (°C)': 'NTC Temp (°C)',
                    'Courant (V Bruts)': 'Current (Raw V)',
                    'Batterie (V)': 'Battery (V)',
                    'Gyroscope': 'Gyroscope', // Combined label
                    'Gyroscope X': 'Gyroscope X',
                    'Gyroscope Y': 'Gyroscope Y',
                    'Gyroscope Z': 'Gyroscope Z'
                },
                prevPage: 'Previous',
                nextPage: 'Next',
                pageInfo: (currentPage, totalPages) => `Page ${currentPage} of ${totalPages}`
            },
            'fr': {
                dashboardTitle: 'Tableau de Bord des Données',
                latestDataBtn: 'Dernières Données',
                accelGyroBtn: 'Accélération & Gyro',
                fullTableBtn: 'Tableau Complet',
                chartsBtn: 'Graphiques',
                loadingText: 'Chargement des données...',
                errorTitle: 'Erreur!',
                errorText: 'Échec du chargement des données. Veuillez vous assurer que la source de données est disponible et que le script Apps Script est correctement déployé.',
                latestDataTitle: 'Dernières Données des Capteurs',
                accelGyroTitle: 'Données d\'Accélération et de Gyroscope',
                fullTableTitle: 'Tableau Complet des Données avec Filtres',
                fromDateLabel: 'Du Date:',
                toDateLabel: 'Au Date:',
                fromTimeLabel: 'Du Temps:',
                toTimeLabel: 'Au Temps:',
                applyFiltersBtn: 'Appliquer le Filtre',
                resetFiltersBtn: 'Réinitialiser',
                exportCsvBtn: 'Exporter CSV', // New translation
                noDataFound: 'Aucune donnée à afficher ou aucune donnée ne correspond aux critères de filtre.',
                chartsTitle: 'Graphiques des Données des Capteurs',
                chartMetricLabel: 'Sélectionner une métrique:', // New translation
                minLabel: 'Min:', // New translation
                avgLabel: 'Moy:', // New translation
                maxLabel: 'Max:', // New translation
                invalidDate: 'Date Invalide',
                invalidTime: 'Heure Invalide',
                invalidValue: 'Invalide',
                autoRefreshOn: 'Actualisation automatique: ON',
                autoRefreshOff: 'Actualisation automatique: OFF',
                generateInsightBtn: 'Générer une perspicacité ✨',
                insightCardTitle: 'Perspicacité des Données',
                noDataForInsight: 'Aucune donnée disponible pour générer des perspicacités.',
                generatingInsight: 'Génération de la perspicacité...',
                insightError: 'Échec de la génération de la perspicacité. Veuillez réessayer.',
                insightFetchError: 'Erreur lors de la récupération de la perspicacité de l\'IA',
                copyInsightBtn: 'Copier la perspicacité', // New translation
                copiedSuccess: 'Perspicacité copiée avec succès!', // New translation
                copyFailed: 'Échec de la copie.', // New translation
                healthNormal: 'État des données: Normal ✅', // New translation
                healthWarning: 'État des données: Avertissement ⚠️', // New translation
                healthCritical: 'État des données: Critique ❌', // New translation
                healthUnknown: 'État des données: Inconnu ❓', // New translation
                chartLabels: {
                    'Timestamp': 'Horodatage',
                    'Date': 'Date',
                    'Heure': 'Heure',
                    'Température (°C)': 'Température (°C)',
                    'Humidité (%)': 'Humidité (%)',
                    'Accélération': 'Accélération', // Combined label
                    'Accélération X': 'Accélération X',
                    'Accélération Y': 'Accélération Y',
                    'Accélération Z': 'Accélération Z',
                    'Vibration': 'Vibration',
                    'Temp. NTC (°C)': 'Temp. NTC (°C)',
                    'Courant (V Bruts)': 'Courant (V bruts)',
                    'Batterie (V)': 'Batterie (V)',
                    'Gyroscope': 'Gyroscope', // Combined label
                    'Gyroscope X': 'Gyroscope X',
                    'Gyroscope Y': 'Gyroscope Y',
                    'Gyroscope Z': 'Gyroscope Z'
                },
                prevPage: 'Précédent',
                nextPage: 'Suivant',
                pageInfo: (currentPage, totalPages) => `Page ${currentPage} sur ${totalPages}`
            }
        };

        /**
         * Helper function to parse a date/time string into a Date object.
         * This function assumes the input dateString is in 'YYYY-MM-DD' format and timeString is 'HH:MM:SS'.
         * It constructs an ISO 8601 string and creates a Date object.
         * The 'Z' indicates UTC, so JavaScript will convert it to the local timezone automatically.
         * @param {string} dateString - The date part (e.g., "2025-06-22").
         * @param {string} timeString - The time part (e.g., "17:27:03").
         * @returns {Date | null} A Date object in local timezone, or null if invalid.
         */
        function parseDateTimeToLocalDate(dateString, timeString) {
            // Ensure dateString is justgetFullYear-MM-DD
            let parsedDatePart = String(dateString).split('T')[0];
            // Ensure timeString is just HH:MM:SS
            let parsedTimePart = String(timeString);
            if (parsedTimePart.includes('T')) {
                parsedTimePart = parsedTimePart.split('T')[1].substring(0, 8);
            } else {
                parsedTimePart = parsedTimePart.substring(0, 8);
            }

            // Combine and assume UTC for parsing, then JS converts to local time
            const isoString = `${parsedDatePart}T${parsedTimePart}Z`;
            const date = new Date(isoString);

            return isNaN(date.getTime()) ? null : date;
        }


        /**
         * Helper function to get only the date part formatted for local display.
         * @param {string} dateValue - The original date string from 'Date' column.
         * @param {string} timeValue - The original time string from 'Heure' column.
         * @returns {string} Formatted local date string (e.g., "06/27/2025" for en-US).
         */
        function getFormattedDateForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Use currentLanguage for locale formatting (e.g., 'fr' for dd/mm/yyyy)
                return dateObj.toLocaleDateString(currentLanguage, { year: 'numeric', month: '2-digit', day: '2-digit' });
            }
            return translations[currentLanguage].invalidDate;
        }

        /**
         * Helper function to get only the time part formatted for local display.
         * @param {string} dateValue - The original date string from 'Date' column.
         * @param {string} timeValue - The original time string from 'Heure' column.
         * @returns {string} Formatted local time string (e.g., "14:02:03").
         */
        function getFormattedTimeForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Use currentLanguage for locale formatting (e.g., 'fr' for 24-hour format)
                return dateObj.toLocaleTimeString(currentLanguage, { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
            return translations[currentLanguage].invalidTime;
        }
        
        /**
         * Helper function to format numeric values (e.g., temperature, humidity, acceleration).
         * @param {string | number} value - The numeric value.
         * @param {number} [decimalPlaces=2] - Number of decimal places to format to.
         * @returns {string} Formatted number string or 'Invalid'.
         */
        function formatNumericValue(value, decimalPlaces = 2) {
            const parsedValue = parseFloat(value);
            if (!isNaN(parsedValue)) {
                // Use currentLanguage for locale-specific number formatting (e.g., French uses comma for decimal)
                return parsedValue.toLocaleString(currentLanguage, { minimumFractionDigits: decimalPlaces, maximumFractionDigits: decimalPlaces });
            }
            return translations[currentLanguage].invalidValue;
        }

        /**
         * Updates the display with the current local date and time based on currentLanguage.
         */
        function updateCurrentDateTimeDisplay() {
            const now = new Date();
            const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

            currentDateDisplay.textContent = now.toLocaleDateString(currentLanguage, dateOptions);
            currentTimeDisplay.textContent = now.toLocaleTimeString(currentLanguage, timeOptions);
        }

        /**
         * Shows a specific page section and hides others.
         * Destroys existing chart instances to prevent memory leaks when switching away from charts.
         * @param {string} pageId - The ID of the page section to show.
         */
        function showPage(pageId) {
            // Hide all content sections
            document.querySelectorAll('.page-content').forEach(section => {
                section.classList.add('hidden');
            });
            // Show the requested content section
            document.getElementById(pageId).classList.remove('hidden');

            // Destroy existing single chart instance when leaving charts page
            if (pageId !== 'charts' && chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            
            // Re-render the specific section that is now visible to apply any latest data or language changes
            const filteredData = getFilteredSensorData(); // Get filtered data for the current UI state
            if (pageId === 'latestData') {
                renderLatestData(sensorData); // Latest data always uses full data to find last entry
            } else if (pageId === 'fullTable') {
                currentPage = 1; // Reset to first page when navigating to table
                renderFullTable(filteredData); // Render table with filtered data
            } else if (pageId === 'charts') {
                // Render the selected chart based on the dropdown, or the first one by default
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, filteredData); // Render charts with filtered data
            } else if (pageId === 'accelGyroData') {
                renderAccelGyroData(sensorData); // Accel/Gyro also uses full data to find last entry
            }
        }

        /**
         * Fetches all data from the Google Sheets API.
         * No longer accepts filters, always fetches full dataset.
         */
        async function fetchData() {
            loadingIndicator.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');

            // Check if the API URL is still the placeholder
            if (GOOGLE_SHEETS_API_URL === 'YOUR_GOOGLE_SHEETS_API_URL_HERE') {
                const errorMsg = 'Error: GOOGLE_SHEETS_API_URL is still the placeholder. Please replace it with your actual Google Apps Script URL.';
                console.error(errorMsg);
                errorTextSpan.textContent = translations[currentLanguage].errorText + ` (${errorMsg})`;
                errorMessageDiv.classList.remove('hidden');
                loadingIndicator.classList.add('hidden');
                return; // Stop execution if URL is not set
            }

            try {
                const response = await fetch(GOOGLE_SHEETS_API_URL); // Fetch all data
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                const data = await response.json();
                
                let actualData = [];
                if (Array.isArray(data) && data.length > 0) {
                    actualData = data;
                } else if (data && Array.isArray(data.data) && data.data.length > 0) {
                    actualData = data.data;
                } else {
                    actualData = []; 
                    console.warn('Data format is invalid or no data found.');
                }
                
                // Sort the data by 'Date' then 'Heure' to ensure the latest data is at the end
                actualData.sort((a, b) => {
                    const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                    const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                    if (!dateA || isNaN(dateA.getTime())) return 1;
                    if (!dateB || isNaN(dateB.getTime())) return -1;
                    return dateA.getTime() - dateB.getTime();
                });

                // Store previous latest entry for comparison before updating sensorData
                if (sensorData.length > 0) {
                    previousLatestEntry = sensorData[sensorData.length - 1];
                } else {
                    previousLatestEntry = {};
                }

                sensorData = actualData; // Store the FULL fetched data
                
                // Re-render based on the currently active page after fetching new data
                const activePageId = document.querySelector('.page-content:not(.hidden)').id;
                const filteredData = getFilteredSensorData(); // Get filtered data for active page if needed

                if (activePageId === 'latestData') {
                    renderLatestData(sensorData);
                } else if (activePageId === 'fullTable') {
                    // Re-render table, staying on the current page if possible
                    renderFullTable(filteredData); 
                } else if (activePageId === 'charts') {
                    const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                    renderChart(selectedMetric, filteredData); // Render selected chart with new data
                } else if (activePageId === 'accelGyroData') {
                    renderAccelGyroData(sensorData);
                }

            } catch (error) {
                console.error('Error fetching data:', error); // Log the full error object
                errorTextSpan.textContent = translations[currentLanguage].errorText + ` (${error.message || error})`;
                errorMessageDiv.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Determines the status of a value against its thresholds.
         * @param {string} metricName - The name of the metric.
         * @param {number} value - The current value.
         * @returns {string} 'normal', 'warning', 'critical', or 'unknown'.
         */
        function getValueStatus(metricName, value) {
            const thresholds = THRESHOLDS[metricName];
            if (!thresholds || isNaN(value)) {
                return 'unknown';
            }

            if (value < thresholds.min || value > thresholds.max) {
                return 'critical';
            } else if (value < thresholds.warningMin || value > thresholds.warningMax) {
                return 'warning';
            } else {
                return 'normal';
            }
        }

        /**
         * Renders the latest sensor data on the main page.
         * Includes value change indicators and threshold alerts.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderLatestData(data) {
            latestDataContent.innerHTML = '';
            
            if (data.length === 0) {
                latestDataContent.innerHTML = `<p class="text-gray-500 text-center col-span-full">${translations[currentLanguage].noDataFound}</p>`;
                insightCard.classList.add('hidden');
                return;
            }

            const latestEntry = data[data.length - 1];

            const labels = translations[currentLanguage].chartLabels;

            // Check overall data health
            let overallHealth = 'normal';
            for (const key in latestEntry) {
                if (latestEntry.hasOwnProperty(key) && THRESHOLDS[key]) {
                    const value = parseFloat(latestEntry[key]);
                    const status = getValueStatus(key, value);
                    if (status === 'critical') {
                        overallHealth = 'critical';
                        break;
                    } else if (status === 'warning' && overallHealth === 'normal') {
                        overallHealth = 'warning';
                    }
                }
            }
            
            // Display overall data health (optional, could be in a dedicated card or header)
            // For now, let's keep it simple and just console log or add a global status bar later.

            for (const key in latestEntry) {
                // Exclude the individual Accel and Gyro components from this section, as they are now grouped
                if (latestEntry.hasOwnProperty(key) && 
                    !['Accélération X', 'Accélération Y', 'Accélération Z', 
                       'Gyroscope X', 'Gyroscope Y', 'Gyroscope Z', 'Timestamp', 'Date', 'Heure'].includes(key) &&
                    !['Accélération', 'Gyroscope'].includes(key) // Also exclude the combined metrics to avoid duplicates
                    ) {
                    let valueToDisplay = latestEntry[key];
                    let changeIndicator = '';
                    let alertIndicator = '';

                    const displayLabel = labels[key] || key;

                    if (chartMetrics.includes(key) || 
                                (key.startsWith('Accélération') && chartMetrics.includes('Accélération')) ||
                                (key.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        const numericValue = parseFloat(valueToDisplay);
                        valueToDisplay = formatNumericValue(numericValue);

                        // Value Change Indicator
                        if (previousLatestEntry[key] !== undefined && !isNaN(parseFloat(previousLatestEntry[key]))) {
                            const prevValue = parseFloat(previousLatestEntry[key]);
                            const change = numericValue - prevValue;
                            if (prevValue !== 0) { // Avoid division by zero
                                const percentageChange = (change / prevValue) * 100;
                                let arrow = '';
                                let color = 'text-gray-500';
                                if (change > 0) {
                                    arrow = '▲'; // Up arrow
                                    color = 'text-green-500';
                                } else if (change < 0) {
                                    arrow = '▼'; // Down arrow
                                    color = 'text-red-500';
                                }
                                changeIndicator = `<span class="${color} text-sm font-semibold ml-2">${arrow} ${Math.abs(percentageChange).toFixed(1)}%</span>`;
                            }
                        }

                        // Threshold Alert Indicator
                        const status = getValueStatus(key, numericValue);
                        if (status === 'warning') {
                            alertIndicator = '<span class="text-orange-500 ml-2 text-xl" title="Warning: Value near limit">⚠️</span>';
                        } else if (status === 'critical') {
                            alertIndicator = '<span class="text-red-600 ml-2 text-xl" title="Critical: Value out of limit">❌</span>';
                        }
                    } else if (key === 'Date') {
                        valueToDisplay = getFormattedDateForDisplay(valueToDisplay, latestEntry['Heure']);
                    } else if (key === 'Heure') {
                        valueToDisplay = getFormattedTimeForDisplay(latestEntry['Date'], valueToDisplay);
                    }

                    const dataCard = document.createElement('div');
                    // Added data-card-interactive for animations
                    dataCard.className = 'glassmorphism-card p-6 data-card-interactive';
                    dataCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-blue-700 mb-2">${displayLabel}</h3>
                        <p class="text-2xl font-bold text-gray-900 flex items-center">
                            ${valueToDisplay}
                            ${changeIndicator}
                            ${alertIndicator}
                        </p>
                    `;
                    latestDataContent.appendChild(dataCard);
                }
            }
            insightCard.classList.add('hidden');
            insightContent.textContent = '';
        }

        /**
         * Renders acceleration and gyroscope data in dedicated cards.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderAccelGyroData(data) {
            accelGyroContent.innerHTML = '';
            if (data.length === 0) {
                accelGyroContent.innerHTML = `<p class="text-gray-500 text-center col-span-full">${translations[currentLanguage].noDataFound}</p>`;
                return;
            }

            const latestEntry = data[data.length - 1];
            const labels = translations[currentLanguage].chartLabels;

            // Create Acceleration Card
            const accelCard = document.createElement('div');
            // Added data-card-interactive for animations
            accelCard.className = 'glassmorphism-card p-6 data-card-interactive';
            accelCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-4">${labels['Accélération']}</h3>
                <div class="space-y-2">
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Accélération X']}:</span> ${formatNumericValue(latestEntry['Accélération X'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Accélération X')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Accélération Y']}:</span> ${formatNumericValue(latestEntry['Accélération Y'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Accélération Y')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Accélération Z']}:</span> ${formatNumericValue(latestEntry['Accélération Z'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Accélération Z')}</p>
                </div>
            `;
            accelGyroContent.appendChild(accelCard);

            // Create Gyroscope Card
            const gyroCard = document.createElement('div');
            // Added data-card-interactive for animations
            gyroCard.className = 'glassmorphism-card p-6 data-card-interactive';
            gyroCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-4">${labels['Gyroscope']}</h3>
                <div class="space-y-2">
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope X']}:</span> ${formatNumericValue(latestEntry['Gyroscope X'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope X')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope Y']}:</span> ${formatNumericValue(latestEntry['Gyroscope Y'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope Y')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope Z']}:</span> ${formatNumericValue(latestEntry['Gyroscope Z'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope Z')}</p>
                </div>
            `;
            accelGyroContent.appendChild(gyroCard);
        }

        /**
         * Helper function to generate change indicator and alert for a metric.
         * @param {Object} currentData - The current data entry.
         * @param {Object} prevData - The previous data entry.
         * @param {string} key - The metric key.
         * @returns {string} HTML string for change and alert indicators.
         */
        function getChangeAndAlert(currentData, prevData, key) {
            let changeIndicator = '';
            let alertIndicator = '';
            const numericValue = parseFloat(currentData[key]);

            // Value Change Indicator
            if (prevData[key] !== undefined && !isNaN(parseFloat(prevData[key]))) {
                const prevValue = parseFloat(prevData[key]);
                const change = numericValue - prevValue;
                if (prevValue !== 0) {
                    const percentageChange = (change / prevValue) * 100;
                    let arrow = '';
                    let color = 'text-gray-500';
                    if (change > 0) {
                        arrow = '▲';
                        color = 'text-green-500';
                    } else if (change < 0) {
                        arrow = '▼';
                        color = 'text-red-500';
                    }
                    changeIndicator = `<span class="${color} text-sm font-semibold mr-1">${arrow} ${Math.abs(percentageChange).toFixed(1)}%</span>`;
                }
            }

            // Threshold Alert Indicator
            const status = getValueStatus(key, numericValue);
            if (status === 'warning') {
                alertIndicator = '<span class="text-orange-500 ml-1 text-xl" title="Warning: Value near limit">⚠️</span>';
            } else if (status === 'critical') {
                alertIndicator = '<span class="text-red-600 ml-1 text-xl" title="Critical: Value out of limit">❌</span>';
            }
            return `${changeIndicator}${alertIndicator}`;
        }

        /**
         * Returns a filtered subset of sensorData based on current filter inputs.
         * This function centralizes the filtering logic for both table and charts.
         * @returns {Array<Object>} The filtered data.
         */
        function getFilteredSensorData() {
            let filteredClientData = [...sensorData]; // Start with a copy of all data
            const fromDateVal = fromDateInput.value;
            const toDateVal = toDateInput.value;
            const fromTimeVal = fromTimeInput.value;
            const toTimeVal = toTimeInput.value;

            if (fromDateVal || toDateVal || fromTimeVal || toTimeVal) {
                let filterStartDateTime = null;
                let filterEndDateTime = null;

                // Construct filter start date/time
                if (fromDateVal) {
                    const timePart = fromTimeVal || '00:00:00'; // Default to start of day if no time
                    filterStartDateTime = parseDateTimeToLocalDate(fromDateVal, timePart);
                    if (isNaN(filterStartDateTime.getTime())) filterStartDateTime = null;
                } else if (fromTimeVal) {
                    const today = new Date().toISOString().split('T')[0];
                    filterStartDateTime = parseDateTimeToLocalDate(today, fromTimeVal);
                    if (isNaN(filterStartDateTime.getTime())) filterStartDateTime = null;
                }

                // Construct filter end date/time
                if (toDateVal) {
                    const timePart = toTimeVal || '23:59:59'; // Default to end of day if no time
                    filterEndDateTime = parseDateTimeToLocalDate(toDateVal, timePart);
                    if (isNaN(filterEndDateTime.getTime())) filterEndDateTime = null;
                } else if (toTimeVal) {
                    const today = new Date().toISOString().split('T')[0];
                    filterEndDateTime = parseDateTimeToLocalDate(today, toTimeVal);
                    if (isNaN(filterEndDateTime.getTime())) filterEndDateTime = null;
                }

                filteredClientData = filteredClientData.filter(row => {
                    const rowDateTime = parseDateTimeToLocalDate(row.Date, row.Heure);

                    if (!rowDateTime || isNaN(rowDateTime.getTime())) {
                        return false;
                    }

                    let pass = true;
                    if (filterStartDateTime && rowDateTime < filterStartDateTime) {
                        pass = false;
                    }
                    if (pass && filterEndDateTime && rowDateTime > filterEndDateTime) {
                        pass = false;
                    }
                    return pass;
                });
            }
            return filteredClientData;
        }

        /**
         * Renders the full data table, applying client-side filters and pagination.
         * @param {Array<Object>} dataToRender - The data (already filtered by getFilteredSensorData).
         */
        function renderFullTable(dataToRender) {
            tableHeaderRow.innerHTML = '';
            tableBody.innerHTML = '';
            noDataFoundDiv.classList.add('hidden');

            if (dataToRender.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="100%" class="text-center py-4 text-gray-500">${translations[currentLanguage].noDataFound}</td></tr>`;
                noDataFoundDiv.classList.remove('hidden');
                paginationControls.classList.add('hidden');
                return;
            }

            const headers = Object.keys(dataToRender[0]);
            const translatedHeaders = translations[currentLanguage].chartLabels;

            // Render headers only once
            if (tableHeaderRow.children.length === 0) {
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-right';
                    th.textContent = translatedHeaders[header] || header;
                    tableHeaderRow.appendChild(th);
                });
            }

            // Implement pagination
            const totalPages = Math.ceil(dataToRender.length / itemsPerPage);
            currentPage = Math.min(Math.max(1, currentPage), totalPages); // Ensure currentPage is valid

            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedData = dataToRender.slice(startIndex, endIndex);

            paginatedData.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-900';
                    
                    let cellValue = row[header];
                    if (header === 'Date') {
                        cellValue = getFormattedDateForDisplay(cellValue, row['Heure']);
                    } else if (header === 'Heure') {
                        cellValue = getFormattedTimeForDisplay(row['Date'], cellValue);
                    } else if (chartMetrics.includes(header) || 
                                (header.startsWith('Accélération') && chartMetrics.includes('Accélération')) ||
                                (header.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        cellValue = formatNumericValue(cellValue);
                    }
                    td.textContent = cellValue;
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });

            // Update pagination controls
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;
            pageInfo.textContent = translations[currentLanguage].pageInfo(currentPage, totalPages);
            paginationControls.classList.remove('hidden');
        }

        /**
         * Applies filters by re-rendering the currently active relevant page (table or charts).
         */
        function applyFilters() {
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            const filteredData = getFilteredSensorData(); // Get newly filtered data

            if (activePageId === 'fullTable') {
                currentPage = 1; // Reset to first page on filter change
                renderFullTable(filteredData); // Re-render table
            } else if (activePageId === 'charts') {
                const selectedMetric = chartMetricSelect.value || chartMetrics[0]; // Use current selection or default
                renderChart(selectedMetric, filteredData); // Re-render charts
            }
        }

        /**
         * Resets all filter inputs and re-renders the relevant page with all data.
         */
        function resetFilters() {
            fromDateInput.value = '';
            toDateInput.value = '';
            fromTimeInput.value = '';
            toTimeInput.value = '';
            
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            // When resetting, we effectively want to show all data, so filter with empty criteria
            const allData = getFilteredSensorData(); // This will return sensorData as inputs are empty
            
            if (activePageId === 'fullTable') {
                currentPage = 1; // Reset to first page on filter reset
                renderFullTable(allData); // Re-render table with all data
            } else if (activePageId === 'charts') {
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, allData); // Re-render charts with all data
            }
        }

        /**
         * Populates the chart metric dropdown.
         */
        function populateChartMetricSelect() {
            chartMetricSelect.innerHTML = ''; // Clear existing options
            const allMetrics = [...new Set(chartMetrics.concat(
                Object.keys(sensorData.length > 0 ? sensorData[0] : {}).filter(key => 
                    key.startsWith('Accélération') || key.startsWith('Gyroscope')
                )
            ))].filter(m => m !== 'Timestamp' && m !== 'Date' && m !== 'Heure'); // Filter out date/time for dropdown
            
            // Reorder to put combined metrics first if they exist
            const orderedMetrics = [];
            if (allMetrics.includes('Accélération')) orderedMetrics.push('Accélération');
            if (allMetrics.includes('Gyroscope')) orderedMetrics.push('Gyroscope');

            allMetrics.forEach(metric => {
                if (!orderedMetrics.includes(metric)) {
                    orderedMetrics.push(metric);
                }
            });

            orderedMetrics.forEach(metric => {
                const option = document.createElement('option');
                option.value = metric;
                option.textContent = translations[currentLanguage].chartLabels[metric] || metric;
                chartMetricSelect.appendChild(option);
            });

            // Set default selection if a value was previously selected
            if (chartMetricSelect.dataset.selected) {
                chartMetricSelect.value = chartMetricSelect.dataset.selected;
            } else {
                chartMetricSelect.value = orderedMetrics[0] || '';
            }
        }


        /**
         * Renders a single chart for the specified metric.
         * @param {string} selectedMetric - The metric to render (e.g., 'Température (°C)', 'Accélération').
         * @param {Array<Object>} dataToRender - The data to use for rendering the chart (already filtered).
         */
        function renderChart(selectedMetric, dataToRender) {
            if (dataToRender.length === 0) {
                mainChartCanvas.classList.add('hidden');
                currentChartTitle.textContent = translations[currentLanguage].noDataFound;
                chartStats.classList.add('hidden');
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                return;
            } else {
                mainChartCanvas.classList.remove('hidden');
                chartStats.classList.remove('hidden');
            }

            const sortedData = [...dataToRender].sort((a, b) => {
                const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                if (!dateA || isNaN(dateA.getTime())) return 1;
                if (!dateB || isNaN(dateB.getTime())) return -1;
                return dateA.getTime() - dateB.getTime();
            });

            const labels = sortedData.map(entry => {
                const date = parseDateTimeToLocalDate(entry.Date, entry.Heure);
                if (date && !isNaN(date.getTime())) {
                    return date.toLocaleString(currentLanguage, {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false
                    });
                }
                return translations[currentLanguage].invalidDate + '/' + translations[currentLanguage].invalidTime;
            });

            let datasets = [];
            let chartMetricLabel = translations[currentLanguage].chartLabels[selectedMetric] || selectedMetric;
            currentChartTitle.textContent = chartMetricLabel;

            let values = []; // To store values for min/max/avg calculation

            if (selectedMetric === 'Accélération') {
                ['X', 'Y', 'Z'].forEach((axis, i) => {
                    const componentMetric = `Accélération ${axis}`;
                    const color = chartColors[i % chartColors.length]; // Use limited colors for combined chart
                    const pointStyle = pointStyles[i % pointStyles.length];

                    const dataForAxis = sortedData.map(entry => {
                        const val = parseFloat(entry[componentMetric]);
                        if (!isNaN(val)) values.push(val); // Add to values for stats
                        return val || 0;
                    });

                    datasets.push({
                        label: translations[currentLanguage].chartLabels[componentMetric] || componentMetric,
                        data: dataForAxis,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3, // Smaller points for multi-line
                        pointBackgroundColor: color,
                        pointStyle: pointStyle,
                        fill: false
                    });
                });
            } else if (selectedMetric === 'Gyroscope') {
                ['X', 'Y', 'Z'].forEach((axis, i) => {
                    const componentMetric = `Gyroscope ${axis}`;
                    const color = chartColors[(i + 3) % chartColors.length]; // Offset colors
                    const pointStyle = pointStyles[(i + 3) % pointStyles.length];

                    const dataForAxis = sortedData.map(entry => {
                        const val = parseFloat(entry[componentMetric]);
                        if (!isNaN(val)) values.push(val); // Add to values for stats
                        return val || 0;
                    });

                    datasets.push({
                        label: translations[currentLanguage].chartLabels[componentMetric] || componentMetric,
                        data: dataForAxis,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3, // Smaller points for multi-line
                        pointBackgroundColor: color,
                        pointStyle: pointStyle,
                        fill: false
                    });
                });
            } else {
                // Single metric chart
                const color = chartColors[0]; // Use first color for single charts
                const pointStyle = pointStyles[0];

                const dataForMetric = sortedData.map(entry => {
                    const val = parseFloat(entry[selectedMetric]);
                    if (!isNaN(val)) values.push(val); // Add to values for stats
                    return val || 0;
                });

                datasets.push({
                    label: chartMetricLabel,
                    data: dataForMetric,
                    borderColor: color,
                    backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 5,
                    pointBackgroundColor: color,
                    pointStyle: pointStyle,
                    fill: true
                });
            }

            // Calculate Min, Max, Average
            let min = values.length > 0 ? Math.min(...values) : NaN;
            let max = values.length > 0 ? Math.max(...values) : NaN;
            let sum = values.reduce((a, b) => a + b, 0);
            let avg = values.length > 0 ? sum / values.length : NaN;

            minVal.textContent = `${translations[currentLanguage].minLabel} ${formatNumericValue(min)}`;
            avgVal.textContent = `${translations[currentLanguage].avgLabel} ${formatNumericValue(avg)}`;
            maxVal.textContent = `${translations[currentLanguage].maxLabel} ${formatNumericValue(max)}`;


            if (chartInstance) {
                chartInstance.destroy();
            }

            const ctx = mainChartCanvas.getContext('2d');
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: false, // Keep responsive false for fixed dimensions
                    maintainAspectRatio: false, // Keep this as false
                    plugins: {
                        legend: {
                            display: (selectedMetric === 'Accélération' || selectedMetric === 'Gyroscope'), // Only display legend for combined charts
                            rtl: (currentLanguage === 'ar'),
                            labels: {
                                font: {
                                    size: 12
                                },
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `${translations[currentLanguage].chartLabels['Timestamp']}: ${context[0].label}`;
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toLocaleString(currentLanguage, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                }
                            },
                            rtl: (currentLanguage === 'ar')
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: translations[currentLanguage].chartLabels['Timestamp'],
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 10,
                                font: { size: 10 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: chartMetricLabel,
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                font: { size: 10 },
                                callback: function(value) {
                                    return value.toLocaleString(currentLanguage);
                                }
                            }
                        }
                    },
                    indexAxis: 'x',
                    rtl: (currentLanguage === 'ar') 
                }
            });
        }

        /**
         * Updates all UI elements based on the selected language.
         * @param {string} lang - The language code ('ar', 'en', 'fr').
         */
        function updateUIForLanguage(lang) {
            currentLanguage = lang;
            const t = translations[currentLanguage];

            document.body.style.direction = (lang === 'ar') ? 'rtl' : 'ltr';
            document.body.style.textAlign = (lang === 'ar') ? 'right' : 'left';

            dashboardTitle.textContent = t.dashboardTitle;
            document.title = t.dashboardTitle;

            latestDataBtn.textContent = t.latestDataBtn;
            accelGyroBtn.textContent = t.accelGyroBtn;
            fullTableBtn.textContent = t.fullTableBtn;
            chartsBtn.textContent = t.chartsBtn;

            loadingText.textContent = t.loadingText;
            errorTitle.textContent = t.errorTitle;
            errorTextSpan.textContent = t.errorText;

            latestDataTitle.textContent = t.latestDataTitle;
            accelGyroTitle.textContent = t.accelGyroTitle;
            fullTableTitle.textContent = t.fullTableTitle;
            chartsTitle.textContent = t.chartsTitle;

            fromDateLabel.textContent = t.fromDateLabel;
            toDateLabel.textContent = t.toDateLabel;
            fromTimeLabel.textContent = t.fromTimeLabel;
            toTimeLabel.textContent = t.toTimeLabel;
            applyFiltersBtn.textContent = t.applyFiltersBtn;
            resetFiltersBtn.textContent = t.resetFiltersBtn;
            exportCsvBtn.textContent = t.exportCsvBtn; // Update CSV button text
            
            noDataFoundDiv.textContent = t.noDataFound;
            
            autoRefreshToggleBtn.textContent = autoRefreshIntervalId ? t.autoRefreshOn : t.autoRefreshOff;

            generateInsightBtn.textContent = t.generateInsightBtn;
            insightCardTitle.textContent = t.insightCardTitle;
            insightLoadingText.textContent = t.generatingInsight;
            copyInsightBtn.textContent = t.copyInsightBtn; // Update copy button text

            // Update pagination button texts
            prevPageBtn.textContent = t.prevPage;
            nextPageBtn.textContent = t.nextPage;
            
            // Update chart labels and dropdown
            populateChartMetricSelect(); // Re-populate with translated labels
            chartMetricSelect.dataset.selected = chartMetricSelect.value; // Store current selection
            chartMetricLabel.textContent = t.chartMetricLabel; // Update dropdown label

            // Re-render relevant sections to apply new language formatting and filters
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            const filteredData = getFilteredSensorData(); // Get filtered data based on current UI state
            if (activePageId === 'latestData') {
                renderLatestData(sensorData); // Latest data always uses full data to find last entry
            } else if (activePageId === 'fullTable') {
                renderFullTable(filteredData); // Re-render table with filtered data (maintaining page)
            } else if (activePageId === 'charts') {
                // Ensure the selected metric in dropdown is preserved, then render that chart
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, filteredData);
            } else if (activePageId === 'accelGyroData') {
                renderAccelGyroData(sensorData); // Accel/Gyro also uses full data to find last entry
            }

            // Update min/avg/max labels
            minVal.textContent = `${t.minLabel} ${formatNumericValue(parseFloat(minVal.textContent.split(': ')[1]))}`;
            avgVal.textContent = `${t.avgLabel} ${formatNumericValue(parseFloat(avgVal.textContent.split(': ')[1]))}`;
            maxVal.textContent = `${t.maxLabel} ${formatNumericValue(parseFloat(maxVal.textContent.split(': ')[1]))}`;


            updateCurrentDateTimeDisplay();
        }

        /**
         * Toggles the auto-refresh functionality.
         */
        function toggleAutoRefresh() {
            if (autoRefreshIntervalId) {
                clearInterval(autoRefreshIntervalId);
                autoRefreshIntervalId = null;
                autoRefreshToggleBtn.textContent = translations[currentLanguage].autoRefreshOff;
                autoRefreshToggleBtn.classList.remove('bg-green-500', 'hover:bg-green-400');
                autoRefreshToggleBtn.classList.add('bg-red-500', 'hover:bg-red-400');
            } else {
                autoRefreshIntervalId = setInterval(() => {
                    fetchData(); // Fetch new data
                }, 30000); // 30 seconds
                autoRefreshToggleBtn.textContent = translations[currentLanguage].autoRefreshOn;
                autoRefreshToggleBtn.classList.remove('bg-red-500', 'hover:bg-red-400');
                autoRefreshToggleBtn.classList.add('bg-green-500', 'hover:bg-green-400');
                fetchData(); // Fetch data immediately when starting
            }
        }

        /**
         * Generates an insight from the latest sensor data using the Gemini API.
         */
        async function generateInsight() {
            if (sensorData.length === 0) {
                insightCard.classList.remove('hidden');
                insightContent.textContent = translations[currentLanguage].noDataForInsight;
                return;
            }

            insightContent.textContent = '';
            insightLoadingText.textContent = translations[currentLanguage].generatingInsight;
            insightLoading.classList.remove('hidden');
            insightCard.classList.remove('hidden');
            generateInsightBtn.disabled = true;
            generateInsightBtn.classList.add('opacity-50', 'cursor-not-allowed');

            const latestEntry = sensorData[sensorData.length - 1];
            let formattedData = "";
            const labels = translations[currentLanguage].chartLabels;

            for (const key in latestEntry) {
                if (latestEntry.hasOwnProperty(key)) {
                    let valueToDisplay = latestEntry[key];
                    if (key === 'Date') {
                        valueToDisplay = getFormattedDateForDisplay(valueToDisplay, latestEntry['Heure']);
                    } else if (key === 'Heure') {
                        valueToDisplay = getFormattedTimeForDisplay(latestEntry['Date'], valueToDisplay);
                    } else if (
                        ['Température (°C)', 'Humidité (%)', 'Vibration', 'Temp. NTC (°C)', 'Courant (V Bruts)', 'Batterie (V)'].includes(key) ||
                        key.startsWith('Accélération') || key.startsWith('Gyroscope')
                    ) {
                        valueToDisplay = formatNumericValue(valueToDisplay);
                    }
                    formattedData += `${labels[key] || key}: ${valueToDisplay}\n`;
                }
            }

            const prompt = `Analyze the following sensor data and provide a concise summary of the latest readings. Highlight any unusual values or noticeable trends. Ensure the response is in ${currentLanguage === 'ar' ? 'Arabic' : (currentLanguage === 'en' ? 'English' : 'French')}.

Latest Sensor Data:
${formattedData}

Provide insights in a clear, easy-to-understand paragraph.`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    insightContent.textContent = text;
                } else {
                    insightContent.textContent = translations[currentLanguage].insightError;
                    console.error("Gemini API response structure unexpected:", result);
                }
            } catch (error) {
                insightContent.textContent = translations[currentLanguage].insightFetchError + `: ${error.message}`;
                console.error("Error calling Gemini API:", error);
            } finally {
                insightLoading.classList.add('hidden');
                generateInsightBtn.disabled = false;
                generateInsightBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Copies the insight text to the clipboard.
         */
        function copyInsight() {
            const textToCopy = insightContent.textContent;
            if (textToCopy) {
                // Use the older document.execCommand('copy') for broader iframe compatibility
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert(translations[currentLanguage].copiedSuccess); // Use alert for simplicity, could be custom modal
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    alert(translations[currentLanguage].copyFailed); // Use alert for simplicity
                }
                document.body.removeChild(textArea);
            }
        }

        /**
         * Exports the current filtered data from the table to a CSV file.
         */
        function exportToCSV() {
            const dataToExport = getFilteredSensorData(); // Get data based on current filters

            if (dataToExport.length === 0) {
                alert(translations[currentLanguage].noDataFound);
                return;
            }

            const headers = Object.keys(dataToExport[0]);
            const translatedHeaders = headers.map(header => translations[currentLanguage].chartLabels[header] || header);

            let csv = translatedHeaders.join(',') + '\n'; // CSV header

            dataToExport.forEach(row => {
                const rowValues = headers.map(header => {
                    let cellValue = row[header];
                    if (header === 'Date') {
                        cellValue = getFormattedDateForDisplay(cellValue, row['Heure']);
                    } else if (header === 'Heure') {
                        cellValue = getFormattedTimeForDisplay(row['Date'], cellValue);
                    } else if (chartMetrics.includes(header) || 
                                (header.startsWith('Accélération') && chartMetrics.includes('Accélération')) ||
                                (header.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        cellValue = formatNumericValue(cellValue);
                    }
                    // Escape commas and double quotes for CSV format
                    return `"${String(cellValue).replace(/"/g, '""')}"`;
                });
                csv += rowValues.join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.setAttribute('download', 'sensor_data_filtered.csv');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }


        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            fetchData(); // Fetch all data on page load
            showPage('latestData'); // Show the latest data page by default

            populateChartMetricSelect(); // Populate chart dropdown on load

            updateUIForLanguage(currentLanguage); // Initial call to update UI for default language
            toggleAutoRefresh(); // Start auto-refresh by default

            setInterval(updateCurrentDateTimeDisplay, 1000); // Update current date and time every second 

            document.querySelectorAll('.nav-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const targetPage = event.target.dataset.target;
                    showPage(targetPage);
                });
            });

            document.querySelectorAll('.lang-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const lang = event.target.dataset.lang;
                    updateUIForLanguage(lang);
                });
            });

            autoRefreshToggleBtn.addEventListener('click', toggleAutoRefresh);
            generateInsightBtn.addEventListener('click', generateInsight);
            copyInsightBtn.addEventListener('click', copyInsight); // New event listener for copy insight

            applyFiltersBtn.addEventListener('click', applyFilters); // Client-side filter application
            resetFiltersBtn.addEventListener('click', resetFilters); // Client-side filter reset
            exportCsvBtn.addEventListener('click', exportToCSV); // New event listener for CSV export

            // Pagination event listeners
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderFullTable(getFilteredSensorData());
                }
            });
            nextPageBtn.addEventListener('click', () => {
                const filteredData = getFilteredSensorData();
                const totalPages = Math.ceil(filteredData.length / itemsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderFullTable(filteredData);
                }
            });

            // Chart metric selection event listener
            chartMetricSelect.addEventListener('change', () => {
                const selectedMetric = chartMetricSelect.value;
                chartMetricSelect.dataset.selected = selectedMetric; // Store selection
                renderChart(selectedMetric, getFilteredSensorData());
            });
        });

    </script>
</body>
</html>
