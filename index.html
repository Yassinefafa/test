<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>لوحة تحكم بيانات المستشعر</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            direction: rtl; /* Set text direction to right-to-left for Arabic */
            text-align: right; /* Align text to the right for Arabic */
        }
        .container {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding: 1rem;
        }
        .hidden {
            display: none;
        }
        /* Custom scrollbar for table */
        .overflow-x-auto::-webkit-scrollbar {
            height: 8px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <!-- Header and Navigation -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 shadow-lg py-4">
        <nav class="container flex justify-between items-center">
            <h1 class="text-white text-3xl font-bold rounded-lg px-3 py-1 bg-opacity-20 bg-white">
                لوحة تحكم البيانات
            </h1>
            <div class="flex space-x-4 space-x-reverse"> <!-- space-x-reverse for RTL -->
                <button class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="latestData">
                    البيانات الأخيرة
                </button>
                <button class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="fullTable">
                    الجدول الكامل
                </button>
                <button class="nav-button px-6 py-2 rounded-full text-lg font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="charts">
                    الرسوم البيانية
                </button>
            </div>
        </nav>
    </header>

    <!-- Main Content Area -->
    <main class="container my-8">
        <!-- Loading Indicator -->
        <div id="loading" class="text-center text-xl font-semibold text-blue-600 my-10 hidden">
            <div class="flex items-center justify-center space-x-2 space-x-reverse">
                <svg class="animate-spin h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>جارٍ تحميل البيانات...</span>
            </div>
        </div>

        <!-- Error Message -->
        <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative my-6 hidden" role="alert">
            <strong class="font-bold">خطأ!</strong>
            <span class="block sm:inline" id="errorText">تعذر تحميل البيانات. يرجى المحاولة مرة أخرى لاحقًا.</span>
            <span class="absolute top-0 bottom-0 left-0 px-4 py-3">
                <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="document.getElementById('errorMessage').classList.add('hidden')">
                    <title>إغلاق</title>
                    <path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/>
                </svg>
            </span>
        </div>

        <!-- Latest Data Section -->
        <section id="latestData" class="page-content bg-white p-8 rounded-lg shadow-xl border border-gray-200">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                أحدث بيانات المستشعر
            </h2>
            <div id="latestDataContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Latest data will be injected here by JavaScript -->
            </div>
        </section>

        <!-- Full Table Section -->
        <section id="fullTable" class="page-content hidden bg-white p-8 rounded-lg shadow-xl border border-gray-200">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                البيانات الكاملة مع التصفية
            </h2>

            <!-- Filters -->
            <div class="mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-4">
                    <div>
                        <label for="fromDate" class="block text-gray-700 text-sm font-medium mb-2">من تاريخ:</label>
                        <input type="date" id="fromDate" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    </div>
                    <div>
                        <label for="toDate" class="block text-gray-700 text-sm font-medium mb-2">إلى تاريخ:</label>
                        <input type="date" id="toDate" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    </div>
                    <div>
                        <label for="fromTime" class="block text-gray-700 text-sm font-medium mb-2">من توقيت:</label>
                        <input type="time" id="fromTime" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    </div>
                    <div>
                        <label for="toTime" class="block text-gray-700 text-sm font-medium mb-2">إلى توقيت:</label>
                        <input type="time" id="toTime" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    </div>
                </div>
                <div class="flex justify-start space-x-4 space-x-reverse">
                    <button id="applyFiltersBtn" class="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-300 transform hover:scale-105 shadow-lg">
                        تطبيق التصفية
                    </button>
                    <button id="resetFiltersBtn" class="px-8 py-3 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition duration-300 transform hover:scale-105 shadow-lg">
                        إعادة تعيين
                    </button>
                </div>
            </div>

            <!-- Data Table -->
            <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                <table id="dataTable" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-100">
                        <tr id="tableHeaderRow">
                            <!-- Headers will be injected here -->
                        </tr>
                    </thead>
                    <tbody id="tableBody" class="bg-white divide-y divide-gray-200">
                        <!-- Data rows will be injected here -->
                    </tbody>
                </table>
                <div id="noDataFound" class="hidden text-center py-8 text-gray-500 text-lg">
                    لا توجد بيانات مطابقة لمعايير التصفية.
                </div>
            </div>
        </section>

        <!-- Charts Section -->
        <section id="charts" class="page-content hidden bg-white p-8 rounded-lg shadow-xl border border-gray-200">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                الرسوم البيانية لبيانات المستشعر
            </h2>
            <div id="chartsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- Charts will be injected here by JavaScript -->
            </div>
        </section>
    </main>

    <script>
        // Google Sheets API URL
        const GOOGLE_SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbxO7soutfxNmG1Vy6KvuZ4ZS96qWg9nJouY-vjvKt3_i-kQh4wa3hBbU0-vuqgU8jF02g/exec';

        // Global variables
        let sensorData = []; // To store all fetched data
        const chartInstances = {}; // To keep track of Chart.js instances

        // DOM Elements
        const loadingIndicator = document.getElementById('loading');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorTextSpan = document.getElementById('errorText');
        const latestDataSection = document.getElementById('latestData');
        const latestDataContent = document.getElementById('latestDataContent');
        const fullTableSection = document.getElementById('fullTable');
        const chartsSection = document.getElementById('charts');
        const dataTable = document.getElementById('dataTable');
        const tableHeaderRow = document.getElementById('tableHeaderRow');
        const tableBody = document.getElementById('tableBody');
        const fromDateInput = document.getElementById('fromDate');
        const toDateInput = document.getElementById('toDate');
        const fromTimeInput = document.getElementById('fromTime');
        const toTimeInput = document.getElementById('toTime');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const noDataFoundDiv = document.getElementById('noDataFound');
        const chartsContainer = document.getElementById('chartsContainer');

        // Metrics to display as charts
        const chartMetrics = [
            'Température (°C)', 'Humidité (%)', 'Accélération X', 'Accélération Y',
            'Accélération Z', 'Gyroscope X', 'Gyroscope Y', 'Gyroscope Z',
            'Vibration', 'Temp. NTC (°C)', 'Courant (V Bruts)', 'Batterie (V)'
        ];

        /**
         * Helper function to parse a date/time string into a Date object.
         * Handles various ISO-like formats, including those with "Z" (UTC).
         * @param {string} dateString - The date part (e.g., "2025-06-22T23:00:00.000Z" or "2025-06-22").
         * @param {string} timeString - The time part (e.g., "1899-12-30T17:27:03.000Z" or "17:27:03").
         * @returns {Date | null} A Date object in local timezone, or null if invalid.
         */
        function parseDateTimeToLocalDate(dateString, timeString) {
            let parsedDatePart = String(dateString).split('T')[0]; // Get YYYY-MM-DD from 'Date' column
            let parsedTimePart = String(timeString);
            if (parsedTimePart.includes('T')) {
                parsedTimePart = parsedTimePart.split('T')[1].substring(0, 8); // Get HH:MM:SS from 'Heure' column
            } else {
                parsedTimePart = parsedTimePart.substring(0, 8); // Ensure HH:MM:SS format
            }

            // Construct an ISO 8601 string assuming UTC, then convert to local Date object
            // By default, new Date('YYYY-MM-DDTHH:MM:SSZ') will parse as UTC and then display in local time.
            const isoString = `${parsedDatePart}T${parsedTimePart}Z`;
            const date = new Date(isoString);

            return isNaN(date.getTime()) ? null : date;
        }

        /**
         * Helper function to get only the date part (e.g., "2025-06-23") formatted for local display.
         * @param {Date | string} dateTimeValue - The Date object or original string value.
         * @param {string} timeValue - The original time string (Heure column).
         * @returns {string} Formatted local date string (YYYY-MM-DD).
         */
        function getFormattedDateForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Return YYYY-MM-DD in local time
                return dateObj.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
            }
            return 'تاريخ غير صالح';
        }

        /**
         * Helper function to get only the time part (e.g., "16:56:43") formatted for local display.
         * @param {Date | string} dateValue - The original date string (Date column).
         * @param {string} timeValue - The Date object or original string value.
         * @returns {string} Formatted local time string (HH:MM:SS).
         */
        function getFormattedTimeForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Return HH:MM:SS in local time
                return dateObj.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
            return 'وقت غير صالح';
        }
        
        /**
         * Helper function to format numeric values (e.g., temperature, humidity, acceleration).
         * @param {string | number} value - The numeric value.
         * @returns {string} Formatted number string or 'غير صالح'.
         */
        function formatNumericValue(value) {
            const parsedValue = parseFloat(value);
            if (!isNaN(parsedValue)) {
                return parsedValue.toFixed(2); // Format to 2 decimal places
            }
            return 'غير صالح'; // Indicate invalid data
        }


        /**
         * Shows a specific page section and hides others.
         * Destroys existing chart instances to prevent memory leaks when switching away from charts.
         * @param {string} pageId - The ID of the page section to show.
         */
        function showPage(pageId) {
            document.querySelectorAll('.page-content').forEach(section => {
                section.classList.add('hidden');
            });
            document.getElementById(pageId).classList.remove('hidden');

            // Destroy existing charts if switching away from charts page
            if (pageId !== 'charts') {
                for (const chartId in chartInstances) {
                    if (chartInstances[chartId]) {
                        chartInstances[chartId].destroy();
                        delete chartInstances[chartId];
                    }
                }
            } else {
                // If navigating to charts, render them
                renderCharts(sensorData);
            }

            // If navigating to full table, ensure it's rendered with current filters
            if (pageId === 'fullTable') {
                renderFullTable(sensorData);
            }
        }

        /**
         * Fetches data from the Google Sheets API.
         * Now includes filter parameters for server-side filtering.
         * @param {Object} [filters={}] - Optional filter parameters (fromDate, toDate, fromTime, toTime).
         */
        async function fetchData(filters = {}) {
            loadingIndicator.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');

            // Build URL with filter parameters
            let url = new URL(GOOGLE_SHEETS_API_URL);
            for (const key in filters) {
                if (filters[key]) {
                    url.searchParams.append(key, filters[key]);
                }
            }

            try {
                const response = await fetch(url.toString());
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                let actualData = [];
                // Check if the data is directly an array (expected format for this API)
                if (Array.isArray(data) && data.length > 0) {
                    actualData = data;
                } 
                // Fallback: check if data is nested under a 'data' key (less likely but good for robustness)
                else if (data && Array.isArray(data.data) && data.data.length > 0) {
                    actualData = data.data;
                } else {
                    // If no data or invalid format, set sensorData to empty array
                    actualData = []; 
                    console.warn('Data format is invalid or no data found.');
                }
                
                // Sort the data by 'Date' then 'Heure' to ensure the latest data is at the end
                actualData.sort((a, b) => {
                    const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                    const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                    // Handle invalid dates by pushing them to the end or beginning
                    if (!dateA || isNaN(dateA.getTime())) return 1;
                    if (!dateB || isNaN(dateB.getTime())) return -1;
                    return dateA.getTime() - dateB.getTime();
                });

                sensorData = actualData; // Store the fetched (and potentially filtered) data
                
                // Re-render based on the currently active page after fetching new data
                const activePageId = document.querySelector('.page-content:not(.hidden)').id;
                if (activePageId === 'latestData') {
                    renderLatestData(sensorData);
                } else if (activePageId === 'fullTable') {
                    renderFullTable(sensorData); // Render table with the newly fetched data
                } else if (activePageId === 'charts') {
                    renderCharts(sensorData);
                }

            } catch (error) {
                console.error('Error fetching data:', error);
                errorTextSpan.textContent = `تعذر تحميل البيانات: ${error.message}. يرجى التأكد من أن مصدر البيانات متاح و Apps Script منشور بشكل صحيح.`;
                errorMessageDiv.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Renders the latest sensor data on the main page.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderLatestData(data) {
            latestDataContent.innerHTML = ''; // Clear previous content
            if (data.length === 0) {
                latestDataContent.innerHTML = '<p class="text-gray-500 text-center col-span-full">لا توجد بيانات لعرضها.</p>';
                return;
            }

            const latestEntry = data[data.length - 1]; // Get the last entry (after sorting in fetchData)

            // Arabic labels mapping
            const labels = {
                'Timestamp': 'الختم الزمني',
                'Date': 'التاريخ',
                'Heure': 'التوقيت', // Use 'Heure' as the key for time
                'Température (°C)': 'درجة الحرارة (°C)',
                'Humidité (%)': 'الرطوبة (%)',
                'Accélération X': 'التسارع X',
                'Accélération Y': 'التسارع Y', 
                'Accélération Z': 'التسارع Z',
                'Gyroscope X': 'جيروسكوب X',
                'Gyroscope Y': 'جيروسكوب Y',
                'Gyroscope Z': 'جيروسكوب Z',
                'Vibration': 'الاهتزاز',
                'Temp. NTC (°C)': 'درجة حرارة NTC (°C)',
                'Courant (V Bruts)': 'التيار (فولت خام)',
                'Batterie (V)': 'البطارية (فولت)'
            };

            for (const key in latestEntry) {
                if (latestEntry.hasOwnProperty(key)) {
                    let valueToDisplay = latestEntry[key];
                    if (key === 'Date') {
                        valueToDisplay = getFormattedDateForDisplay(valueToDisplay, latestEntry['Heure']);
                    } else if (key === 'Heure') {
                        valueToDisplay = getFormattedTimeForDisplay(latestEntry['Date'], valueToDisplay);
                    } else if (chartMetrics.includes(key)) { // Apply formatNumericValue to all chartMetrics
                        valueToDisplay = formatNumericValue(valueToDisplay);
                    }

                    const displayLabel = labels[key] || key; // Use Arabic label if available, else original key

                    const dataCard = document.createElement('div');
                    dataCard.className = 'bg-white p-6 rounded-lg shadow-md border border-gray-100 transform hover:scale-102 transition duration-300';
                    dataCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-blue-700 mb-2">${displayLabel}</h3>
                        <p class="text-2xl font-bold text-gray-900">${valueToDisplay}</p>
                    `;
                    latestDataContent.appendChild(dataCard);
                }
            }
        }

        /**
         * Renders the full data table, applying filters if provided.
         * @param {Array<Object>} data - The data array (already filtered if fetchData was called with filters).
         */
        function renderFullTable(data) { 
            tableHeaderRow.innerHTML = '';
            tableBody.innerHTML = '';
            noDataFoundDiv.classList.add('hidden');

            if (data.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="100%" class="text-center py-4 text-gray-500">لا توجد بيانات لعرضها أو لا توجد بيانات مطابقة لمعايير التصفية.</td></tr>';
                noDataFoundDiv.classList.remove('hidden'); // Show no data message
                return;
            }

            // Create table headers
            const headers = Object.keys(data[0]);
            const arabicHeaders = {
                'Timestamp': 'الختم الزمني',
                'Date': 'التاريخ',
                'Heure': 'التوقيت', // Use 'Heure' as the key for time
                'Température (°C)': 'درجة الحرارة (°C)',
                'Humidité (%)': 'الرطوبة (%)',
                'Accélération X': 'التسارع X',
                'Accélération Y': 'التسارع Y', 
                'Accélération Z': 'التسارع Z',
                'Gyroscope X': 'جيروسكوب X',
                'Gyroscope Y': 'جيروسكوب Y',
                'Gyroscope Z': 'جيروسكوب Z',
                'Vibration': 'الاهتزاز',
                'Temp. NTC (°C)': 'درجة حرارة NTC (°C)',
                'Courant (V Bruts)': 'التيار (فولت خام)',
                'Batterie (V)': 'البطارية (فولت)'
            };

            headers.forEach(header => {
                const th = document.createElement('th');
                th.className = 'px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-right'; // text-right for RTL
                th.textContent = arabicHeaders[header] || header;
                tableHeaderRow.appendChild(th);
            });

            // Populate table body with filtered data
            data.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-900';
                    
                    let cellValue = row[header];
                    if (header === 'Date') {
                        cellValue = getFormattedDateForDisplay(cellValue, row['Heure']);
                    } else if (header === 'Heure') {
                        cellValue = getFormattedTimeForDisplay(row['Date'], cellValue);
                    } else if (chartMetrics.includes(header)) { // Apply formatNumericValue to all chartMetrics
                        cellValue = formatNumericValue(cellValue);
                    }
                    td.textContent = cellValue;
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });
        }

        /**
         * Applies filters by re-fetching data from the server with filter parameters.
         */
        function applyFilters() {
            const filters = {
                fromDate: fromDateInput.value,
                toDate: toDateInput.value,
                fromTime: fromTimeInput.value,
                toTime: toTimeInput.value
            };
            fetchData(filters); // Fetch data with filters
        }

        /**
         * Resets all filter inputs and re-fetches all data from the server.
         */
        function resetFilters() {
            fromDateInput.value = '';
            toDateInput.value = '';
            fromTimeInput.value = '';
            toTimeInput.value = '';
            fetchData(); // Fetch all data (no filters)
        }

        /**
         * Renders charts for the specified metrics.
         * @param {Array<Object>} data - The data array (already filtered if fetchData was called with filters).
         */
        function renderCharts(data) {
            chartsContainer.innerHTML = ''; // Clear previous charts
            if (data.length === 0) {
                chartsContainer.innerHTML = '<p class="text-gray-500 text-center col-span-full">لا توجد بيانات لإنشاء الرسوم البيانية.</p>';
                return;
            }

            // Sort data by Timestamp to ensure correct chart rendering
            const sortedData = [...data].sort((a, b) => {
                const dateA = parseDateTimeToLocalDate(a.Date, a.Heure); 
                const dateB = parseDateTimeToLocalDate(b.Date, b.Heure); 
                // Handle invalid dates by pushing them to the end or beginning
                if (!dateA || isNaN(dateA.getTime())) return 1;
                if (!dateB || isNaN(dateB.getTime())) return -1;
                return dateA.getTime() - dateB.getTime();
            });

            // Extract labels (timestamps)
            const labels = sortedData.map(entry => {
                const date = parseDateTimeToLocalDate(entry.Date, entry.Heure);
                if (date && !isNaN(date.getTime())) {
                    return date.toLocaleString('ar-EG', {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false
                    });
                }
                return 'تاريخ/وقت غير صالح'; // Fallback for invalid dates
            });

            chartMetrics.forEach(metric => {
                // Destroy existing chart instance before creating a new one
                if (chartInstances[metric]) {
                    chartInstances[metric].destroy();
                    delete chartInstances[metric];
                }

                const chartDiv = document.createElement('div');
                chartDiv.className = 'bg-white p-6 rounded-lg shadow-md border border-gray-100';
                chartDiv.innerHTML = `<h3 class="text-xl font-semibold text-blue-700 mb-4 text-center">${metric}</h3><canvas id="chart-${metric.replace(/[^a-zA-Z0-9]/g, '-')}" class="w-full"></canvas>`;
                chartsContainer.appendChild(chartDiv);

                const ctx = document.getElementById(`chart-${metric.replace(/[^a-zA-Z0-9]/g, '-')}`).getContext('2d');
                // Ensure values are numbers for charts, fallback to 0 if parsing fails
                const datasets = sortedData.map(entry => parseFloat(entry[metric]) || 0); 

                chartInstances[metric] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: metric,
                            data: datasets,
                            borderColor: '#3B82F6', // Blue-500
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderWidth: 2,
                            tension: 0.3,
                            pointRadius: 3,
                            pointBackgroundColor: '#2563EB' // Blue-600
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false // Hide legend as label is in title
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        return `التاريخ/الوقت: ${context[0].label}`;
                                    },
                                    label: function(context) {
                                        return `${metric}: ${context.raw}`;
                                    }
                                },
                                rtl: true // Enable RTL for tooltips
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'الختم الزمني',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 10,
                                    font: { size: 10 }
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: metric,
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: {
                                    font: { size: 10 }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                    }
                });
            });
        }


        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            fetchData(); // Fetch data on page load
            showPage('latestData'); // Show the latest data page by default

            document.querySelectorAll('.nav-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const targetPage = event.target.dataset.target;
                    showPage(targetPage);
                });
            });

            applyFiltersBtn.addEventListener('click', applyFilters);
            resetFiltersBtn.addEventListener('click', resetFilters);
        });

        // The ResizeObserver block has been removed as Chart.js's responsive property
        // should handle resizing automatically, reducing potential layout thrashing.
        // If charts do not resize as expected, a debounced resize function might be reconsidered.

    </script>
</body>
</html>
