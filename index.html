<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>بيانات جوجل شيت ورسوم بيانية</title>
    <!-- تضمين Tailwind CSS لتصميم عصري ومتجاوب -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- تضمين مكتبة D3.js للرسوم البيانية -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* خط "Inter" لتحسين المظهر العام */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* لون خلفية خفيف */
            display: flex; /* استخدام فليكس بوكس لتحديد تخطيط الشريط الجانبي والمحتوى الرئيسي */
            flex-direction: row; /* الشريط الجانبي والمحتوى في صف واحد */
        }
        /* تصميم مخصص لأزرار الفلاتر والأزرار العامة */
        button {
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* تحسينات إضافية لتصميم الجدول */
        table {
            border-collapse: separate; /* مهم لـ border-radius */
            border-spacing: 0;
            border-radius: 0.75rem; /* حواف مستديرة أكثر */
            overflow: hidden; /* لضمان أن الحواف المستديرة تعمل بشكل صحيح مع المحتوى */
            box-shadow: 0 10px 20px rgba(0,0,0,0.1); /* ظل أكبر وأكثر وضوحًا */
        }

        th, td {
            border: none; /* إزالة الحدود الافتراضية للخلايا */
            padding: 1rem 1.25rem; /* مسافة بادئة محسّنة */
            font-size: 0.95rem; /* حجم خط مناسب */
            text-align: center; /* محاذاة النص إلى الوسط */
        }

        th {
            background-color: #4f46e5; /* لون أزرق داكن لرؤوس الجدول */
            color: white; /* لون الكتابة أبيض */
            font-weight: 700; /* خط أثقل وأكثر بروزًا */
            text-transform: uppercase;
            padding-top: 0.875rem;
            padding-bottom: 0.875rem;
            position: sticky; /* لجعل الرؤوس ثابتة عند التمرير الأفقي */
            top: 0; /* مهم لـ sticky */
            z-index: 20; /* لضمان ظهور الرؤوس فوق محتوى الجدول عند التمرير */
        }

        /* إضافة فاصل سفلي خفيف لرؤوس الأعمدة */
        th:not(:last-child) {
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.1); /* فاصل عمودي بين الرؤوس */
        }
        th:last-child {
             border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* حواف مستديرة لزوايا رؤوس الجدول العلوية */
        th:first-child {
            border-top-right-radius: 0.75rem;
        }
        th:last-child {
            border-top-left-radius: 0.75rem;
        }

        tbody tr:nth-child(even) {
            background-color: #f9fafb; /* لون خلفية فاتح للصفوف الزوجية */
        }

        tbody tr:hover {
            background-color: #eef2ff; /* لون أزرق فاتح عند التمرير فوق الصف */
            transition: background-color 0.2s ease-in-out;
        }

        /* إضافة فاصل خفيف بين خلايا البيانات */
        td:not(:last-child) {
            border-right: 1px solid #e5e7eb;
        }

        /* أنماط D3.js للرسم البياني */
        .axis path,
        .axis line {
            fill: none;
            stroke: #cbd5e1; /* لون رمادي خفيف للمحاور */
            shape-rendering: crispEdges;
        }

        .axis text {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            fill: #4b5563; /* لون نص المحاور */
        }

        .line {
            fill: none;
            stroke: #4f46e5; /* لون الخط الأزرق */
            stroke-width: 3px; /* خط أثخن قليلاً */
        }

        .dot {
            fill: #4f46e5;
            stroke: #fff;
            stroke-width: 2px; /* حدود النقطة أثخن قليلاً */
            r: 5px; /* نقاط أكبر قليلاً */
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 8px;
            font: 12px sans-serif;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 100; /* لضمان ظهور التلميح فوق كل شيء */
        }

        /* أنماط لخطوط الشبكة */
        .grid line {
            stroke: #e0e7ff; /* لون خفيف لخطوط الشبكة */
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }
        .grid path {
            stroke-width: 0;
        }

        /* تصميم القائمة الجانبية (الآن على اليسار) */
        .sidebar {
            width: 250px;
            background-color: #374151; /* لون رمادي داكن للخلفية */
            color: #fff;
            position: fixed;
            top: 0;
            left: -250px; /* مخفية في البداية على اليسار */
            height: 100%;
            padding-top: 4rem; /* مسافة للرأس */
            transition: left 0.3s ease-in-out; /* انتقال للجانب الأيسر */
            z-index: 50; /* فوق المحتوى ولكن تحت التلميح */
            box-shadow: 2px 0 5px rgba(0,0,0,0.2); /* ظل لليمين */
            display: flex;
            flex-direction: column;
        }
        .sidebar.open {
            left: 0; /* تظهر عند الفتح على اليسار */
        }
        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sidebar ul li a {
            display: block;
            padding: 1rem 1.5rem;
            text-decoration: none;
            color: #d1d5db; /* لون نص خفيف */
            transition: background-color 0.2s ease;
        }
        .sidebar ul li a:hover {
            background-color: #4b5563; /* لون عند التمرير */
            color: #fff;
        }
        .sidebar .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem; /* زر الإغلاق على اليمين في القائمة الجانبية اليسرى */
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            display: none; /* مخفي افتراضياً، يظهر على الجوال */
        }

        /* زر الهامبرغر (الآن على اليسار) */
        .hamburger-btn {
            position: fixed;
            top: 1rem;
            left: 1rem; /* زر الهامبرغر على اليسار */
            z-index: 60; /* فوق الشريط الجانبي */
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* إخفاء زر الهامبرغر والقائمة الجانبية على الشاشات الكبيرة */
        @media (min-width: 1024px) { /* نقطة توقف للشاشات الكبيرة */
            .sidebar {
                position: static; /* ليست ثابتة */
                width: 200px; /* عرض ثابت على الشاشات الكبيرة */
                height: auto;
                padding-top: 0;
                box-shadow: none;
                background-color: transparent; /* خلفية شفافة */
                display: block; /* مرئية دائمًا */
                margin-right: 1.5rem; /* مسافة عن المحتوى الرئيسي على اليمين */
                order: -1; /* لجعلها تظهر قبل المحتوى الرئيسي في تخطيط الفليكس بوكس */
            }
            .sidebar ul li a {
                color: #4b5563; /* لون نص داكن على الخلفية الفاتحة */
            }
            .sidebar ul li a:hover {
                background-color: #e0e7ff; /* لون عند التمرير */
                color: #4f46e5; /* لون نص أزرق */
            }
            .hamburger-btn {
                display: none; /* إخفاء زر الهامبرغر */
            }
            .sidebar .close-btn {
                display: none; /* إخفاء زر الإغلاق */
            }

            /* Adjust main content for large screens */
            main {
                margin-left: 1.5rem; /* لتوفير مساحة بجانب الشريط الجانبي الأيسر */
                flex-grow: 1; /* للسماح للمحتوى الرئيسي بالتوسع */
            }
        }

        /* على الشاشات الصغيرة، المحتوى الرئيسي يبدأ بعد زر الهامبرغر */
        @media (max-width: 1023px) {
            body {
                flex-direction: column; /* المحتوى يكون عموديًا على الشاشات الصغيرة */
            }
            main {
                padding-top: 4rem; /* لتجنب تداخل المحتوى مع زر الهامبرغر */
            }
        }
    </style>
</head>
<body class="p-4 bg-gray-100 min-h-screen">

    <!-- زر الهامبرغر (يظهر على الجوال فقط) -->
    <button id="hamburgerBtn" class="hamburger-btn lg:hidden">
        ☰
    </button>

    <!-- القائمة الجانبية -->
    <aside id="sidebar" class="sidebar lg:relative lg:block">
        <button id="closeSidebarBtn" class="close-btn lg:hidden">✕</button>
        <div class="p-4 text-2xl font-bold text-white mb-4 lg:text-gray-800 lg:p-0 lg:mb-6 lg:text-center">
            لوحة التحكم
        </div>
        <ul>
            <li><a href="#" id="showTableBtn" class="bg-indigo-700 lg:bg-indigo-100">عرض البيانات</a></li>
            <li><a href="#" id="showChartBtn" class="">الرسم البياني</a></li>
        </ul>
    </aside>

    <!-- المحتوى الرئيسي للصفحة -->
    <main class="flex-1 flex flex-col items-center p-4">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6 text-center">
            بيانات من جدول جوجل
        </h1>

        <!-- قسم فلاتر البيانات -->
        <div class="mb-6 w-full max-w-5xl bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold text-gray-700 mb-4 text-center">فلاتر البيانات</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
                <div>
                    <label for="filterDateFrom" class="block text-sm font-medium text-gray-700 text-right">تاريخ من:</label>
                    <input type="date" id="filterDateFrom" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 p-2 text-right dir-rtl">
                </div>
                <div>
                    <label for="filterDateTo" class="block text-sm font-medium text-gray-700 text-right">تاريخ إلى:</label>
                    <input type="date" id="filterDateTo" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 p-2 text-right dir-rtl">
                </div>
                <div>
                    <label for="filterTimeFrom" class="block text-sm font-medium text-gray-700 text-right">توقيت من:</label>
                    <input type="time" id="filterTimeFrom" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 p-2 text-right dir-rtl">
                </div>
                <div>
                    <label for="filterTimeTo" class="block text-sm font-medium text-gray-700 text-right">توقيت إلى:</label>
                    <input type="time" id="filterTimeTo" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 p-2 text-right dir-rtl">
                </div>
            </div>
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="applyFilterBtn" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition duration-150 ease-in-out">
                    تطبيق الفلتر
                </button>
                <button id="clearFilterBtn" class="flex-1 px-4 py-2 bg-gray-400 text-white font-semibold rounded-md shadow-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-offset-2 transition duration-150 ease-in-out">
                    مسح الفلاتر
                </button>
            </div>
        </div>

        <!-- رسالة التحميل (عامة لكل من الجدول والرسم البياني) -->
        <div id="loading" class="text-lg text-gray-600 mb-4 animate-pulse">
            جاري تحميل البيانات...
        </div>

        <!-- حاوية الجدول -->
        <div id="table-view" class="w-full max-w-5xl bg-white shadow-lg rounded-lg overflow-x-auto">
            <!-- سيتم إدراج الجدول هنا بواسطة JavaScript -->
        </div>

        <!-- حاوية الرسم البياني (مخفية افتراضياً) -->
        <div id="chart-view" class="w-full max-w-5xl bg-white shadow-lg rounded-lg p-6 flex justify-center items-center hidden">
            <!-- سيتم إدراج الرسم البياني هنا بواسطة JavaScript -->
            <svg class="chart"></svg>
        </div>
    </main>

    <script>
        // رابط Google Apps Script الخاص بك
        const SCRIPT_URL = "https://script.googleusercontent.com/macros/echo?user_content_key=AehSKLiU-W7n7T4VpfLUNKsQwjCH1smHhHPTfZgRnZ8izioCny4R0S36aNMmQQwfdlM98DWwVgcE4KkMiohRixcODrNym0uRriEbIkwJxdtJIsV5w71W4MGb2j4-S4nQf27YXavHO-RqjX1S69aSy5V2bJtFOoknjjyl-r3Npdu0eFwmi85UecADqup3-CmtfXIkeIGy0uLRmnSXzZyr4fFr1v1gXnCZPDro1cUL21MBEcByO5r47j9-7izvX2H0vtqHKc6oSKnvVync9TeLvCWnBk99i9A5J2dMROS7Lycj&lib=M4KMr7SB6nroV6p0oLzbJNWtZyck6V9xg";

        // متغير لتخزين جميع البيانات التي تم جلبها من جدول جوجل
        let allSheetData = [];
        // لتتبع عرض الصفحة الحالي
        let currentPage = 'table'; // الافتراضي هو عرض الجدول

        // ******** إعدادات الأعمدة (يرجى تعديلها حسب أسماء الأعمدة في جدولك) ********
        // بناءً على صور وحدة التحكم (Console) التي أرسلتها، أسماء الأعمدة هي "Date" و "Heure" و "Température (°C)".
        // تأكد من مطابقة حالة الأحرف تمامًا!
        const DATE_COLUMN_NAME = "Date";
        const TIME_COLUMN_NAME = "Heure";
        const TEMPERATURE_COLUMN_NAME = "Température (°C)"; // اسم عمود درجة الحرارة
        // *******************************************************************

        /**
         * دالة مساعدة لتنسيق التاريخ إلىYYYY-MM-DD
         * @param {Date} date - كائن التاريخ.
         * @returns {string} التاريخ المنسق.
         */
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        /**
         * دالة مساعدة لتنسيق التوقيت إلى HH:MM
         * @param {Date} date - كائن التاريخ (يحتوي على التوقيت).
         * @returns {string} التوقيت المنسق.
         */
        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        /**
         * دالة لتحويل سلسلة ISO Date/Time إلى تنسيق تاريخ فقط (YYYY-MM-DD).
         * @param {string} isoString - سلسلة تاريخ ISO (مثل "2025-06-22T23:00:00.000Z").
         * @returns {string} التاريخ المنسق (YYYY-MM-DD).
         */
        function formatIsoDateOnly(isoString) {
            if (!isoString) return '';
            try {
                const date = new Date(isoString);
                if (isNaN(date.getTime())) {
                    const datePart = isoString.split('T')[0];
                    const recheckedDate = new Date(datePart);
                    if (!isNaN(recheckedDate.getTime())) {
                        return datePart;
                    }
                    return isoString;
                }
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch (e) {
                console.error("Error parsing ISO date string:", isoString, e);
                return isoString;
            }
        }

        /**
         * دالة لتحويل سلسلة ISO Date/Time إلى تنسيق وقت فقط (HH:MM:SS).
         * @param {string} isoString - سلسلة تاريخ ISO (مثل "1899-12-30T17:27:03.000Z").
         * @returns {string} التوقيت المنسق (HH:MM:SS).
         */
        function formatIsoTimeOnly(isoString) {
            if (!isoString) return '';
            try {
                const date = new Date(isoString);
                if (isNaN(date.getTime())) {
                    const timePart = isoString.split('T')[1];
                    if (timePart) {
                        const timeSegments = timePart.split(':');
                        if (timeSegments.length >= 2) {
                            const hours = timeSegments[0].padStart(2, '0');
                            const minutes = timeSegments[1].padStart(2, '0');
                            const seconds = timeSegments.length > 2 ? timeSegments[2].substring(0,2).padStart(2, '0') : '00';
                            return `${hours}:${minutes}:${seconds}`;
                        }
                    }
                    return isoString;
                }
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                return `${hours}:${minutes}:${seconds}`;
            } catch (e) {
                console.error("Error parsing ISO time string:", isoString, e);
                return isoString;
            }
        }

        /**
         * دالة لتحويل سلسلة التاريخ والوقت من جدول بيانات Google إلى كائن Date صالح.
         * تحاول التعامل مع التنسيقات المختلفة التي قد تأتي بها البيانات (ISO, DD/MM/YYYY, YYYY-MM-DD).
         * @param {string} dateStr - سلسلة التاريخ (مثل "2025-06-22" أو "22/06/2025" أو "2025-06-22T...").
         * @param {string} timeStr - سلسلة الوقت (مثل "HH:MM" أو "HH:MM:SS").
         * @returns {Date | null} كائن Date أو null إذا فشل التحويل.
         */
        function parseDateTime(dateStr, timeStr) {
            if (!dateStr) return null; // Ensure dateStr exists

            let year, month, day;

            // First, try to parse DD/MM/YYYY format explicitly if it contains '/'
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                day = parseInt(parts[0]);
                month = parseInt(parts[1]) - 1; // Month is 0-indexed
                year = parseInt(parts[2]);
            } else {
                // If not DD/MM/YYYY, assume YYYY-MM-DD or extract from ISO
                const isoDateParts = dateStr.split('T')[0].split('-'); // Get YYYY-MM-DD part from ISO or direct
                if (isoDateParts.length === 3) {
                    year = parseInt(isoDateParts[0]);
                    month = parseInt(isoDateParts[1]) - 1;
                    day = parseInt(isoDateParts[2]);
                } else {
                    console.warn(`Could not determine date format for dateStr: ${dateStr}`);
                    return null;
                }
            }

            let hours = 0, minutes = 0, seconds = 0;
            if (timeStr && typeof timeStr === 'string') {
                const timeParts = timeStr.split(':');
                if (timeParts.length >= 2) {
                    hours = parseInt(timeParts[0]) || 0;
                    minutes = parseInt(timeParts[1]) || 0;
                    seconds = timeParts.length > 2 ? parseInt(timeParts[2]) || 0 : 0;
                }
            }

            const date = new Date(year, month, day, hours, minutes, seconds);

            if (isNaN(date.getTime())) {
                console.warn(`Failed to create Date object from: dateStr='${dateStr}', timeStr='${timeStr}'. Resulting date: ${date}`);
                return null;
            }
            return date;
        }

        /**
         * دالة لجلب البيانات من Google Apps Script API.
         * تُظهر رسالة تحميل وتُخفيها بعد اكتمال الجلب.
         */
        async function fetchData() {
            const loadingElement = document.getElementById("loading");
            loadingElement.style.display = "block";

            try {
                const response = await fetch(SCRIPT_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log("Fetched raw data:", data); // Log raw data
                
                allSheetData = data.map(d => {
                    // معالجة البيانات الخام لتحويلها إلى تنسيقات صالحة للاستخدام
                    const dateTime = parseDateTime(d[DATE_COLUMN_NAME], d[TIME_COLUMN_NAME]);
                    
                    let temperatureValue = d[TEMPERATURE_COLUMN_NAME];
                    // Replace comma with dot for decimal parsing if needed
                    if (typeof temperatureValue === 'string' && temperatureValue.includes(',')) {
                        temperatureValue = temperatureValue.replace(',', '.');
                    }
                    const temperature = Number(temperatureValue); // Use Number() for more robust parsing

                    // Log invalid temperature values
                    if (isNaN(temperature)) {
                         console.warn(`Invalid temperature value found for row: ${JSON.stringify(d)}. Original temperature string: '${d[TEMPERATURE_COLUMN_NAME]}'. Check if 'Température (°C)' column in your sheet contains non-numeric data.`);
                    }
                    
                    return {
                        ...d, // الاحتفاظ بجميع البيانات الأصلية
                        parsedDateTime: dateTime,
                        parsedTemperature: isNaN(temperature) ? null : temperature // تعيين null إذا كانت غير صالحة
                    };
                }).filter(d => {
                    const isValid = d.parsedDateTime !== null && d.parsedTemperature !== null;
                    if (!isValid) {
                        console.warn("Filtering out invalid row (either date/time or temperature is null):", d); // Log filtered out rows
                    }
                    return isValid;
                });

                console.log("Parsed and filtered initial data (allSheetData.length):", allSheetData.length, allSheetData); // Log parsed data
                showPage(currentPage); // عرض الصفحة الافتراضية بعد جلب البيانات
            } catch (error) {
                console.error("Error fetching data:", error);
                document.getElementById("table-view").innerHTML = `
                    <div class="p-6 text-red-600 text-center">
                        <p class="font-semibold mb-2">فشل تحميل البيانات.</p>
                        <p>يرجى التحقق من رابط السكربت وأذونات النشر.</p>
                        <p>تفاصيل الخطأ: ${error.message}</p>
                    </div>
                `;
                 document.getElementById("chart-view").innerHTML = `
                    <div class="p-6 text-red-600 text-center">
                        <p class="font-semibold mb-2">فشل تحميل بيانات الرسم البياني.</p>
                        <p>تفاصيل الخطأ: ${error.message}</p>
                    </div>
                `;
            } finally {
                loadingElement.style.display = "none";
            }
        }

        /**
         * دالة لتطبيق الفلاتر (التاريخ والتوقيت) على البيانات.
         * تقرأ القيم من حقول الإدخال وتقوم بتصفية البيانات المخزنة.
         */
        function applyFilters() {
            const filterDateFromValue = document.getElementById("filterDateFrom").value;
            const filterDateToValue = document.getElementById("filterDateTo").value;
            const filterTimeFromValue = document.getElementById("filterTimeFrom").value;
            const filterTimeToValue = document.getElementById("filterTimeTo").value;

            console.log("Applying filters with values:", {
                filterDateFromValue: filterDateFromValue,
                filterDateToValue: filterDateToValue,
                filterTimeFromValue: filterTimeFromValue,
                filterTimeToValue: filterTimeToValue
            });

            if (allSheetData.length === 0) {
                console.warn("No data to filter. Please wait for data to load.");
                showPage(currentPage);
                return;
            }

            let filteredData = [...allSheetData];

            filteredData = filteredData.filter(d => {
                const rowDateTime = d.parsedDateTime;
                if (!rowDateTime) {
                    console.log(`  Filtering out row because parsedDateTime is null for row: ${JSON.stringify(d)}`);
                    return false;
                }

                let dateMatch = true;
                let timeMatch = true;

                // Date filtering
                let fromDateObj = null;
                if (filterDateFromValue) {
                    fromDateObj = new Date(filterDateFromValue);
                    if (isNaN(fromDateObj.getTime())) {
                        console.warn("Invalid 'Date From' filter value, ignoring filter:", filterDateFromValue);
                        fromDateObj = null; // Invalidate filter if value is bad
                    } else {
                        fromDateObj.setHours(0, 0, 0, 0); // Start of the day
                    }
                }

                let toDateObj = null;
                if (filterDateToValue) {
                    toDateObj = new Date(filterDateToValue);
                    if (isNaN(toDateObj.getTime())) {
                        console.warn("Invalid 'Date To' filter value, ignoring filter:", filterDateToValue);
                        toDateObj = null; // Invalidate filter if value is bad
                    } else {
                        toDateObj.setHours(23, 59, 59, 999); // End of the day
                    }
                }

                if (fromDateObj && rowDateTime < fromDateObj) {
                    dateMatch = false;
                    console.log(`  Row Date (${formatDate(rowDateTime)}) < From Date (${formatDate(fromDateObj)}) -> dateMatch = false for row: ${JSON.stringify(d[DATE_COLUMN_NAME])}`);
                }
                if (toDateObj && rowDateTime > toDateObj) {
                    dateMatch = false;
                    console.log(`  Row Date (${formatDate(rowDateTime)}) > To Date (${formatDate(toDateObj)}) -> dateMatch = false for row: ${JSON.stringify(d[DATE_COLUMN_NAME])}`);
                }


                // Time filtering, only if dateMatch is true
                if (dateMatch && (filterTimeFromValue || filterTimeToValue)) {
                    // Create a dummy date for time comparisons to isolate time component
                    const dummyTimeCompareDate = new Date('2000-01-01T00:00:00'); // Fixed dummy date/time

                    const rowTimeOnly = new Date(dummyTimeCompareDate);
                    rowTimeOnly.setHours(rowDateTime.getHours(), rowDateTime.getMinutes(), rowDateTime.getSeconds(), rowDateTime.getMilliseconds());

                    console.log(`  Row Time Only for row ${JSON.stringify(d[DATE_COLUMN_NAME])} ${JSON.stringify(d[TIME_COLUMN_NAME])}: ${formatTime(rowTimeOnly)}`);

                    let fromTimeOnly = null;
                    if (filterTimeFromValue) {
                        const [fromHours, fromMinutes] = filterTimeFromValue.split(':').map(Number);
                        if (isNaN(fromHours) || isNaN(fromMinutes)) {
                            console.warn("Invalid 'Time From' filter value, ignoring filter:", filterTimeFromValue);
                        } else {
                            fromTimeOnly = new Date(dummyTimeCompareDate);
                            fromTimeOnly.setHours(fromHours, fromMinutes, 0, 0); // From HH:MM:00.000
                        }
                    }

                    let toTimeOnly = null;
                    if (filterTimeToValue) {
                        const [toHours, toMinutes] = filterTimeToValue.split(':').map(Number);
                        if (isNaN(toHours) || isNaN(toMinutes)) {
                            console.warn("Invalid 'Time To' filter value, ignoring filter:", filterTimeToValue);
                        } else {
                            toTimeOnly = new Date(dummyTimeCompareDate);
                            toTimeOnly.setHours(toHours, toMinutes, 59, 999); // To HH:MM:59.999 (end of minute)
                        }
                    }

                    if (fromTimeOnly && rowTimeOnly < fromTimeOnly) {
                        timeMatch = false;
                        console.log(`    Row Time (${formatTime(rowTimeOnly)}) < From Time (${formatTime(fromTimeOnly)}) -> timeMatch = false for row: ${JSON.stringify(d[TIME_COLUMN_NAME])}`);
                    }

                    if (toTimeOnly && timeMatch && rowTimeOnly > toTimeOnly) { // Only check if fromTime filter still allows
                        timeMatch = false;
                        console.log(`    Row Time (${formatTime(rowTimeOnly)}) > To Time (${formatTime(toTimeOnly)}) -> timeMatch = false for row: ${JSON.stringify(d[TIME_COLUMN_NAME])}`);
                    }
                }
                
                // Log final decision for each row
                if (!(dateMatch && timeMatch)) {
                    console.log(`Filtering out row ${JSON.stringify(d[DATE_COLUMN_NAME])} ${JSON.stringify(d[TIME_COLUMN_NAME])} - Final decision: dateMatch=${dateMatch}, timeMatch=${timeMatch}`);
                }

                return dateMatch && timeMatch;
            });
            console.log("Data after filtering in applyFilters (filteredData.length):", filteredData.length, filteredData); // Log filtered data
            showPage(currentPage, filteredData);
        }

        /**
         * دالة لمسح جميع قيم الفلاتر وإعادة عرض البيانات الأصلية.
         */
        function clearFilters() {
            document.getElementById("filterDateFrom").value = "";
            document.getElementById("filterDateTo").value = "";
            document.getElementById("filterTimeFrom").value = "";
            document.getElementById("filterTimeTo").value = "";
            console.log("Clearing filters. Displaying all original data (allSheetData.length):", allSheetData.length); // Log clear filters
            showPage(currentPage, allSheetData); // عرض الصفحة الحالية بجميع البيانات الأصلية
        }

        /**
         * دالة لعرض الجدول.
         * @param {Array<Object>} data - البيانات المراد عرضها.
         */
        function renderTable(data) {
            const tableContainer = document.getElementById("table-view");
            tableContainer.innerHTML = ''; // مسح أي محتوى سابق

            if (!data || data.length === 0) {
                tableContainer.innerHTML = `
                    <div class="p-6 text-gray-600 text-center">
                        <p>لا توجد بيانات متاحة لعرضها في الجدول.</p>
                    </div>
                `;
                return;
            }

            const table = document.createElement("table");
            table.className = "min-w-full divide-y divide-gray-200 rounded-lg";

            const thead = document.createElement("thead");
            thead.className = "bg-gray-50";

            const tbody = document.createElement("tbody");
            tbody.className = "bg-white divide-y divide-gray-200";

            const headers = Object.keys(data[0]);
            const headerRow = document.createElement("tr");
            headers.forEach(headerText => {
                const th = document.createElement("th");
                th.textContent = headerText;
                th.className = "px-6 py-3 text-center text-xs font-bold text-white uppercase tracking-wider";
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            data.forEach((rowData, index) => {
                const tr = document.createElement("tr");
                tr.className = index % 2 === 0 ? "bg-white" : "bg-gray-50";

                headers.forEach(headerText => {
                    const td = document.createElement("td");
                    let cellContent = rowData[headerText];

                    // تطبيق التنسيق للتاريخ والتوقيت
                    if (headerText === DATE_COLUMN_NAME) {
                        cellContent = formatIsoDateOnly(cellContent);
                    } else if (headerText === TIME_COLUMN_NAME) {
                        cellContent = formatIsoTimeOnly(cellContent);
                    } else if (typeof cellContent === 'string' && cellContent.includes('T') && cellContent.includes('Z')) {
                        const formattedDateInOtherColumn = formatIsoDateOnly(cellContent);
                        if (formattedDateInOtherColumn !== cellContent) {
                            cellContent = formattedDateInOtherColumn;
                        }
                    }
                    
                    td.textContent = cellContent;
                    td.className = "px-6 py-4 whitespace-nowrap text-sm text-gray-900 text-center";
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            tableContainer.appendChild(table);
        }

        /**
         * دالة لرسم الرسم البياني لدرجة الحرارة باستخدام D3.js.
         * @param {Array<Object>} data - البيانات المراد رسمها. يجب أن تحتوي على parsedDateTime و parsedTemperature.
         */
        function renderChart(data) {
            const chartContainer = document.getElementById("chart-view");
            chartContainer.innerHTML = ''; // مسح أي محتوى سابق

            const filteredChartData = data.filter(d => d.parsedDateTime && d.parsedTemperature !== null);
            console.log("Data provided to renderChart (filteredChartData.length):", filteredChartData.length, filteredChartData); // Log data for chart

            if (!filteredChartData || filteredChartData.length === 0) {
                chartContainer.innerHTML = `
                    <div class="p-6 text-gray-600 text-center">
                        <p>لا توجد بيانات متاحة للرسم البياني بعد التصفية.</p>
                    </div>
                `;
                return;
            }

            // Ensure valid domain for scales to avoid D3 errors with very small ranges
            const minTemp = d3.min(filteredChartData, d => d.parsedTemperature);
            const maxTemp = d3.max(filteredChartData, d => d.parsedTemperature);
            
            // Add some padding to min/max temperature for better visualization
            // Ensure yDomainMin is not greater than yDomainMax, especially if minTemp === maxTemp
            let yDomainMin = (minTemp !== undefined && minTemp !== null) ? minTemp * 0.9 : 0;
            let yDomainMax = (maxTemp !== undefined && maxTemp !== null) ? maxTemp * 1.1 : 100;

            // If all temperatures are the same, adjust the domain slightly to show a visible line
            if (yDomainMin === yDomainMax) {
                yDomainMin = minTemp - 1;
                yDomainMax = maxTemp + 1;
            }


            const margin = { top: 20, right: 30, bottom: 60, left: 60 };
            const containerWidth = chartContainer.offsetWidth; // استخدام عرض الحاوية الفعلية
            const containerHeight = 400; // ارتفاع ثابت للرسم البياني

            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            // مسح أي SVG موجودة وإعادة إنشائها
            const svg = d3.select(chartContainer).append("svg")
                .attr("class", "chart")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // تعريف المقاييس (Scales)
            const xScale = d3.scaleTime()
                .domain(d3.extent(filteredChartData, d => d.parsedDateTime))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([yDomainMin, yDomainMax])
                .range([height, 0]);

            // إضافة خطوط الشبكة الأفقية
            svg.append("g")
                .attr("class", "grid")
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat("")
                );

            // إضافة خطوط الشبكة العمودية
            svg.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat("")
                );

            // إضافة المحاور (Axes)
            const xAxis = svg.append("g")
                .attr("class", "axis x-axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y-%m-%d %H:%M"))); // تنسيق التاريخ والوقت
            
            // تدوير تسميات المحور X إذا كانت متداخلة
            xAxis.selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            svg.append("g")
                .attr("class", "axis y-axis")
                .call(d3.axisLeft(yScale));

            // إضافة تسمية للمحور Y
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("fill", "#4b5563")
                .text("درجة الحرارة (°C)");

            // تعريف منشئ الخط (Line generator)
            const line = d3.line()
                .x(d => xScale(d.parsedDateTime))
                .y(d => yScale(d.parsedTemperature));

            // رسم الخط
            svg.append("path")
                .datum(filteredChartData)
                .attr("class", "line")
                .attr("d", line);

            // إضافة نقاط البيانات وتأثير التلميح (Tooltip)
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            svg.selectAll(".dot")
                .data(filteredChartData)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("cx", d => xScale(d.parsedDateTime))
                .attr("cy", d => yScale(d.parsedTemperature))
                /* تم تعديل نصف قطر النقطة وحافة النقطة في CSS */
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`التاريخ: ${d3.timeFormat("%Y-%m-%d %H:%M")(d.parsedDateTime)}<br/>درجة الحرارة: ${d.parsedTemperature}°C`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });
        }

        /**
         * دالة لتبديل عرض الصفحة بين الجدول والرسم البياني.
         * @param {string} page - اسم الصفحة ('table' أو 'chart').
         * @param {Array<Object>} [dataToDisplay] - البيانات المراد عرضها (إذا كانت مصفاة).
         */
        function showPage(page, dataToDisplay = allSheetData) {
            currentPage = page;
            const tableView = document.getElementById('table-view');
            const chartView = document.getElementById('chart-view');
            const showTableBtn = document.getElementById('showTableBtn');
            const showChartBtn = document.getElementById('showChartBtn');
            const sidebar = document.getElementById('sidebar');

            // إغلاق القائمة الجانبية على الجوال بعد اختيار الصفحة
            if (window.innerWidth < 1024) { // 1024px هو نقطة توقف Tailwind 'lg'
                sidebar.classList.remove('open');
            }

            // تحديث حالة الأزرار في القائمة الجانبية
            // إزالة الفئات النشطة أولاً
            showTableBtn.classList.remove('bg-indigo-700', 'lg:bg-indigo-100', 'text-white', 'lg:text-indigo-600');
            showChartBtn.classList.remove('bg-indigo-700', 'lg:bg-indigo-100', 'text-white', 'lg:text-indigo-600');
            // إضافة الفئات غير النشطة
            showTableBtn.classList.add('bg-transparent', 'lg:bg-transparent', 'text-gray-300', 'lg:text-gray-700');
            showChartBtn.classList.add('bg-transparent', 'lg:bg-transparent', 'text-gray-300', 'lg:text-gray-700');


            if (page === 'table') {
                tableView.classList.remove('hidden');
                chartView.classList.add('hidden');
                // إضافة الفئات النشطة لزر الجدول
                showTableBtn.classList.add('bg-indigo-700', 'lg:bg-indigo-100', 'text-white', 'lg:text-indigo-600');
                showTableBtn.classList.remove('bg-transparent', 'lg:bg-transparent', 'text-gray-300', 'lg:text-gray-700');

                renderTable(dataToDisplay);
            } else if (page === 'chart') {
                tableView.classList.add('hidden');
                chartView.classList.remove('hidden');
                // إضافة الفئات النشطة لزر الرسم البياني
                showChartBtn.classList.add('bg-indigo-700', 'lg:bg-indigo-100', 'text-white', 'lg:text-indigo-600');
                showChartBtn.classList.remove('bg-transparent', 'lg:bg-transparent', 'text-gray-300', 'lg:text-gray-700');
                
                renderChart(dataToDisplay);
            }
        }

        // استدعاء دالة جلب البيانات عند تحميل محتوى DOM بالكامل
        document.addEventListener("DOMContentLoaded", () => {
            fetchData(); // جلب البيانات أولاً

            // إضافة مستمعي الأحداث لأزرار الفلاتر
            document.getElementById("applyFilterBtn").addEventListener("click", applyFilters);
            document.getElementById("clearFilterBtn").addEventListener("click", clearFilters);

            // مستمعي أحداث أزرار القائمة الجانبية
            document.getElementById("showTableBtn").addEventListener("click", (e) => {
                e.preventDefault(); // منع الانتقال إلى رابط #
                showPage('table');
            });
            document.getElementById("showChartBtn").addEventListener("click", (e) => {
                e.preventDefault(); // منع الانتقال إلى رابط #
                showPage('chart');
            });

            // منطق تبديل القائمة الجانبية على الجوال
            const sidebar = document.getElementById('sidebar');
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const closeSidebarBtn = document.getElementById('closeSidebarBtn');

            hamburgerBtn.addEventListener('click', () => {
                sidebar.classList.add('open');
            });

            closeSidebarBtn.addEventListener('click', () => {
                sidebar.classList.remove('open');
            });

            // إغلاق القائمة الجانبية عند النقر خارجها على الجوال
            document.body.addEventListener('click', (event) => {
                if (window.innerWidth < 1024 && sidebar.classList.contains('open') &&
                    !sidebar.contains(event.target) && !hamburgerBtn.contains(event.target)) {
                    sidebar.classList.remove('open');
                }
            });
            
            // إعادة رسم الرسم البياني عند تغيير حجم الشاشة لضمان تجاوبه
            // أزلت المستمع من renderChart ووضعته هنا للتحكم المركزي
            window.addEventListener('resize', () => {
                if (currentPage === 'chart') {
                    applyFilters(); // لإعادة تطبيق الفلاتر وإعادة الرسم بناءً على الحجم الجديد
                }
            });
        });
    </script>
</body>
</html>
