<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±</title>
    <!-- Favicon - Added to fix 404 error -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“Š</text></svg>">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- jsPDF CDN for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas CDN for capturing HTML content -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            direction: rtl; /* Default to RTL for Arabic initially, will be changed by JS for LTR languages */
            text-align: right; /* Default to right for Arabic, will be changed by JS for LTR languages */
            /* Modern gradient background for the body */
            background: linear-gradient(to bottom right, #e0f2fe, #eef2ff); /* from-blue-50 to-indigo-50 equivalent */
            min-height: 100vh; /* Ensure the gradient covers the entire viewport height */
        }
        .container {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding: 1rem;
        }
        .hidden {
            display: none;
        }
        /* Custom scrollbar for table */
        .overflow-x-auto::-webkit-scrollbar {
            height: 8px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Glassmorphism effect for cards */
        .glassmorphism-card {
            background-color: rgba(255, 255, 255, 0.15); /* Slightly transparent white */
            backdrop-filter: blur(10px); /* Blur behind the element */
            -webkit-backdrop-filter: blur(10px); /* For Safari support */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle white border */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2); /* Softer shadow for depth */
            border-radius: 0.75rem; /* Matches Tailwind's rounded-lg */
        }
        /* Enhanced interactivity for cards */
        .data-card-interactive {
            transform: scale(1);
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .data-card-interactive:hover {
            transform: scale(1.03);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body class="text-gray-800"> <!-- Removed bg-gray-100 as custom gradient is applied -->
    <!-- Header and Navigation -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 shadow-lg py-4">
        <nav class="container flex justify-between items-center flex-wrap gap-4">
            <h1 id="dashboardTitle" class="text-white text-3xl font-bold rounded-lg px-3 py-1 bg-opacity-20 bg-white">
                Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            </h1>
            <!-- Current Date and Time Display -->
            <div class="flex items-center space-x-4 space-x-reverse text-white text-lg font-semibold">
                <div id="currentDate" class="px-3 py-1 rounded-full bg-blue-500 bg-opacity-40 shadow-md"></div>
                <div id="currentTime" class="px-3 py-1 rounded-full bg-indigo-500 bg-opacity-40 shadow-md"></div>
            </div>
            <!-- Language Selector -->
            <div class="flex space-x-2">
                <button class="lang-button px-4 py-2 rounded-full text-sm font-semibold text-white bg-gray-600 hover:bg-gray-500 transition duration-300" data-lang="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</button>
                <button class="lang-button px-4 py-2 rounded-full text-sm font-semibold text-white bg-gray-600 hover:bg-gray-500 transition duration-300" data-lang="en">English</button>
                <button class="lang-button px-4 py-2 rounded-full text-sm font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300" data-lang="fr">FranÃ§ais</button>
            </div>
            <div class="flex space-x-4 space-x-reverse flex-wrap justify-center sm:justify-start"> <!-- space-x-reverse for RTL -->
                <button id="latestDataBtn" class="nav-button px-4 py-2 text-base sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md">
                    Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©
                </button>
                <button id="accelGyroBtn" class="nav-button px-4 py-2 text-base sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="accelGyroData">
                    ØªØ³Ø§Ø±Ø¹ ÙˆØ¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨
                </button>
                <button id="fullTableBtn" class="nav-button px-4 py-2 text-base sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="fullTable">
                    Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„
                </button>
                <button id="chartsBtn" class="nav-button px-4 py-2 text-base sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-blue-500 hover:bg-blue-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="charts">
                    Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©
                </button>
                <button id="thresholdSettingsBtn" class="nav-button px-4 py-2 text-base sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-purple-500 hover:bg-purple-400 transition duration-300 transform hover:scale-105 shadow-md" data-target="thresholdSettings">
                    Ø§Ù„Ø¹Ø¯Ø§Ø¯Ø§Øª
                </button>
                <!-- Auto Refresh Toggle Button -->
                <button id="autoRefreshToggleBtn" class="px-4 py-2 text-base sm:px-6 sm:py-2 sm:text-lg rounded-full font-semibold text-white bg-green-500 hover:bg-green-400 transition duration-300 transform hover:scale-105 shadow-md">
                    ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ: ØªØ´ØºÙŠÙ„
                </button>
            </div>
        </nav>
    </header>

    <!-- Main Content Area -->
    <main class="container my-8" id="mainContentArea">
        <!-- New wrapper div for main content styling -->
        <div class="bg-white p-8 rounded-lg shadow-xl border border-gray-200">
            <!-- Loading Indicator -->
            <div id="loading" class="text-center text-xl font-semibold text-blue-600 my-10 hidden">
                <div class="flex items-center justify-center space-x-2 space-x-reverse">
                    <svg class="animate-spin h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="loadingText">Ø¬Ø§Ø±Ù ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...</span>
                </div>
            </div>

            <!-- Error Message -->
            <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative my-6 hidden" role="alert">
                <strong id="errorTitle" class="font-bold">Ø®Ø·Ø£!</strong>
                <span class="block sm:inline" id="errorText">ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­ Ùˆ Apps Script Ù…Ù†Ø´ÙˆØ± Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.</span>
                <span class="absolute top-0 bottom-0 left-0 px-4 py-3">
                    <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="document.getElementById('errorMessage').classList.add('hidden')">
                        <title>Ø¥ØºÙ„Ø§Ù‚</title>
                        <path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/>
                    </svg>
                </span>
            </div>

            <!-- Latest Data Section -->
            <section id="latestData" class="page-content"> <!-- Removed bg-white, p-8 etc. as they are on the parent wrapper -->
                <h2 id="latestDataTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    Ø£Ø­Ø¯Ø« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±
                </h2>
                <div class="flex justify-start mb-6"> <!-- Aligned to right for RTL, left for LTR -->
                    <button id="generateInsightBtn" class="px-6 py-2 rounded-full text-lg font-semibold text-white bg-purple-600 hover:bg-purple-500 transition duration-300 transform hover:scale-105 shadow-md">
                        Generate Insight âœ¨
                    </button>
                </div>
                <div id="latestDataContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Latest data will be injected here by JavaScript -->
                </div>
                <!-- This div will be shown/hidden by JS when insight is generated -->
                <!-- Glassmorphism applied to insight card -->
                <div id="insightCard" class="glassmorphism-card p-6 col-span-full mt-6 hidden">
                    <h3 id="insightCardTitle" class="text-xl font-semibold text-purple-700 mb-4"></h3>
                    <p id="insightContent" class="text-gray-800 text-base leading-relaxed"></p>
                    <div class="flex justify-end mt-4">
                        <button id="copyInsightBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 text-sm">
                            Ù†Ø³Ø® Ø§Ù„Ø±Ø¤ÙŠØ©
                        </button>
                    </div>
                    <div id="insightLoading" class="text-center text-sm text-purple-600 mt-4 hidden">
                        <svg class="animate-spin h-5 w-5 inline-block text-purple-600 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span id="insightLoadingText"></span>
                    </div>
                </div>
            </section>

            <!-- Acceleration and Gyroscope Data Section -->
            <section id="accelGyroData" class="page-content hidden"> <!-- Removed bg-white, p-8 etc. -->
                <h2 id="accelGyroTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ³Ø§Ø±Ø¹ ÙˆØ§Ù„Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨
                </h2>
                <div id="accelGyroContent" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Acceleration and Gyroscope data will be injected here by JavaScript -->
                </div>
            </section>

            <!-- Full Table Section -->
            <section id="fullTable" class="page-content hidden"> <!-- Removed bg-white, p-8 etc. -->
                <h2 id="fullTableTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø§Ù„ØªØµÙÙŠØ©
                </h2>

                <!-- Filters -->
                <div class="mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-4"> <!-- Restored 4 columns for time filters -->
                        <div>
                            <label id="fromDateLabel" for="fromDate" class="block text-gray-700 text-sm font-medium mb-2">Ù…Ù† ØªØ§Ø±ÙŠØ®:</label>
                            <input type="date" id="fromDate" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                        <div>
                            <label id="toDateLabel" for="toDate" class="block text-gray-700 text-sm font-medium mb-2">Ø¥Ù„Ù‰ ØªØ§Ø±ÙŠØ®:</label>
                            <input type="date" id="toDate" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                        <div>
                            <label id="fromTimeLabel" for="fromTime" class="block text-gray-700 text-sm font-medium mb-2">Ù…Ù† ØªÙˆÙ‚ÙŠØª:</label>
                            <input type="time" id="fromTime" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                        <div>
                            <label id="toTimeLabel" for="toTime" class="block text-gray-700 text-sm font-medium mb-2">Ø¥Ù„Ù‰ ØªÙˆÙ‚ÙŠØª:</label>
                            <input type="time" id="toTime" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        </div>
                    </div>
                    <div class="flex justify-start space-x-4 space-x-reverse flex-wrap">
                        <button id="applyFiltersBtn" class="px-6 py-2 text-base sm:px-8 sm:py-3 sm:text-lg bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-300 transform hover:scale-105 shadow-lg">
                            ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØµÙÙŠØ©
                        </button>
                        <button id="resetFiltersBtn" class="px-6 py-2 text-base sm:px-8 sm:py-3 sm:text-lg bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition duration-300 transform hover:scale-105 shadow-lg">
                            Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†
                        </button>
                        <button id="exportCsvBtn" class="px-6 py-2 text-base sm:px-8 sm:py-3 sm:text-lg bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 shadow-lg">
                            ØªØµØ¯ÙŠØ± CSV
                        </button>
                         <button id="exportPdfBtn" class="px-6 py-2 text-base sm:px-8 sm:py-3 sm:text-lg bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition duration-300 transform hover:scale-105 shadow-lg">
                            ØªØµØ¯ÙŠØ± PDF
                        </button>
                    </div>
                </div>

                <!-- Data Table -->
                <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                    <table id="dataTable" class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-100">
                            <tr id="tableHeaderRow">
                                <!-- Headers will be injected here -->
                            </tr>
                        </thead>
                        <tbody id="tableBody" class="bg-white divide-y divide-gray-200">
                            <!-- Data rows will be injected here -->
                        </tbody>
                    </table>
                    <div id="noDataFound" class="hidden text-center py-8 text-gray-500 text-lg">
                        Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø·Ø§Ø¨Ù‚Ø© Ù„Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„ØªØµÙÙŠØ©.
                    </div>
                </div>
                <!-- Pagination Controls -->
                <div id="paginationControls" class="flex justify-center items-center space-x-4 mt-6">
                    <button id="prevPageBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Ø§Ù„Ø³Ø§Ø¨Ù‚</button>
                    <span id="pageInfo" class="text-gray-700">ØµÙØ­Ø© 1 Ù…Ù† 1</span>
                    <button id="nextPageBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Ø§Ù„ØªØ§Ù„ÙŠ</button>
                </div>
            </section>

            <!-- Charts Section -->
            <section id="charts" class="page-content hidden"> <!-- Removed bg-white, p-8 etc. -->
                <h2 id="chartsTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-blue-500">
                    Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ© Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±
                </h2>
                <!-- Chart Controls (Dropdown for Metric Selection) -->
                <div class="mb-6 p-4 bg-gray-50 rounded-lg shadow-inner flex flex-col sm:flex-row items-start sm:items-center gap-4">
                    <label for="chartMetricSelect" id="chartMetricLabel" class="text-gray-700 font-medium whitespace-nowrap">Ø§Ø®ØªØ± Ø§Ù„Ù…Ù‚ÙŠØ§Ø³:</label>
                    <select id="chartMetricSelect" class="form-select flex-grow p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>

                <!-- Single Chart Canvas -->
                <div id="singleChartContainer" class="glassmorphism-card p-6 flex flex-col justify-center items-center">
                    <h3 id="currentChartTitle" class="text-xl font-semibold text-blue-700 mb-4 text-center"></h3>
                    <canvas id="mainChartCanvas"></canvas> <!-- Removed fixed width/height -->
                    <!-- Min/Max/Avg Display -->
                    <div id="chartStats" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-4 w-full text-center">
                        <div class="p-2 bg-blue-50 rounded-md">
                            <p id="minVal" class="text-sm font-semibold text-gray-700">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: N/A</p>
                        </div>
                        <div class="p-2 bg-blue-50 rounded-md">
                            <p id="avgVal" class="text-sm font-semibold text-gray-700">Ø§Ù„Ù…ØªÙˆØ³Ø·: N/A</p>
                        </div>
                        <div class="p-2 bg-blue-50 rounded-md">
                            <p id="maxVal" class="text-sm font-semibold text-gray-700">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: N/A</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Threshold Settings Section (New Page) -->
            <section id="thresholdSettings" class="page-content hidden">
                <h2 id="thresholdSettingsTitle" class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-3 border-purple-500">
                    Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡
                </h2>
                <div id="thresholdSettingsContent" class="grid grid-cols-1 gap-6">
                    <!-- Threshold settings will be injected here by JavaScript -->
                </div>
                <div class="flex justify-start mt-8 space-x-4 space-x-reverse">
                    <button id="saveThresholdsBtn" class="px-8 py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-300 transform hover:scale-105 shadow-lg">
                        Ø­ÙØ¸ Ø§Ù„Ø­Ø¯ÙˆØ¯
                    </button>
                    <button id="resetThresholdsBtn" class="px-8 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 shadow-lg">
                        Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø¯ÙˆØ¯
                    </button>
                </div>
                <div id="thresholdMessage" class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative my-6 hidden" role="alert">
                    <span id="thresholdMessageText" class="block sm:inline"></span>
                    <span class="absolute top-0 bottom-0 left-0 px-4 py-3">
                        <svg class="fill-current h-6 w-6 text-green-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="document.getElementById('thresholdMessage').classList.add('hidden')">
                            <title>Ø¥ØºÙ„Ø§Ù‚</title>
                            <path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/>
                        </svg>
                    </span>
                </div>
            </section>
        </div> <!-- End of new wrapper div -->
    </main>

    <script>
        // Google Sheets API URL - Ensure this URL is correct and published to 'Anyone' access
        const GOOGLE_SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbxO7soutfxNmG1Vy6KvuZ4ZS96qWg9nJouY-vjvKt3_i-kQh4wa3hBbU0-vuqgU8jF02g/exec';

        // Global variables
        let sensorData = []; // To store ALL fetched data
        let previousLatestEntry = {}; // To store the previous latest data for change indicators
        let chartInstance = null; // Single Chart.js instance for the main chart
        let currentLanguage = 'ar'; // Default language is Arabic
        let autoRefreshIntervalId = null; // Stores the ID of the setInterval for auto-refresh
        let currentPage = 1;
        const itemsPerPage = 20; // Number of rows per page for the full table

        // DOM Elements
        const loadingIndicator = document.getElementById('loading');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorTextSpan = document.getElementById('errorText');
        const latestDataSection = document.getElementById('latestData');
        const latestDataContent = document.getElementById('latestDataContent');
        const fullTableSection = document.getElementById('fullTable');
        const chartsSection = document.getElementById('charts');
        const dataTable = document.getElementById('dataTable');
        const tableHeaderRow = document.getElementById('tableHeaderRow');
        const tableBody = document.getElementById('tableBody');
        const fromDateInput = document.getElementById('fromDate');
        const toDateInput = document.getElementById('toDate');
        const fromTimeInput = document.getElementById('fromTime');
        const toTimeInput = document.getElementById('toTime');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const noDataFoundDiv = document.getElementById('noDataFound');
        const chartsContainer = document.getElementById('chartsContainer'); // Now holds dropdown and single chart
        const mainChartCanvas = document.getElementById('mainChartCanvas'); // The single chart canvas
        const chartMetricSelect = document.getElementById('chartMetricSelect'); // Dropdown for metric selection
        const currentChartTitle = document.getElementById('currentChartTitle'); // Title for the selected chart
        const chartStats = document.getElementById('chartStats'); // Div to display min/avg/max
        const minVal = document.getElementById('minVal');
        const avgVal = document.getElementById('avgVal');
        const maxVal = document.getElementById('maxVal');


        // Elements for current date/time display
        const currentDateDisplay = document.getElementById('currentDate');
        const currentTimeDisplay = document.getElementById('currentTime');

        // Elements for language update
        const dashboardTitle = document.getElementById('dashboardTitle');
        const latestDataTitle = document.getElementById('latestDataTitle');
        const fullTableTitle = document.getElementById('fullTableTitle');
        const chartsTitle = document.getElementById('chartsTitle');
        const fromDateLabel = document.getElementById('fromDateLabel');
        const toDateLabel = document.getElementById('toDateLabel');
        const fromTimeLabel = document.getElementById('fromTimeLabel');
        const toTimeLabel = document.getElementById('toTimeLabel');
        const loadingText = document.getElementById('loadingText');
        const errorTitle = document.getElementById('errorTitle');

        // New elements for Acceleration and Gyroscope section
        const accelGyroDataSection = document.getElementById('accelGyroData');
        const accelGyroTitle = document.getElementById('accelGyroTitle');
        const accelGyroContent = document.getElementById('accelGyroContent');

        // New element for auto-refresh button
        const autoRefreshToggleBtn = document.getElementById('autoRefreshToggleBtn');

        // New elements for LLM insight
        const insightCard = document.getElementById('insightCard');
        const insightCardTitle = document.getElementById('insightCardTitle');
        const insightContent = document.getElementById('insightContent');
        const insightLoading = document.getElementById('insightLoading');
        const insightLoadingText = document.getElementById('insightLoadingText');
        const generateInsightBtn = document.getElementById('generateInsightBtn');
        const copyInsightBtn = document.getElementById('copyInsightBtn'); // New copy insight button

        // Pagination elements
        const paginationControls = document.getElementById('paginationControls');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn'); // New PDF export button

        // New elements for threshold settings page
        const thresholdSettingsBtn = document.getElementById('thresholdSettingsBtn');
        const thresholdSettingsSection = document.getElementById('thresholdSettings');
        const thresholdSettingsTitle = document.getElementById('thresholdSettingsTitle');
        const thresholdSettingsContent = document.getElementById('thresholdSettingsContent');
        const saveThresholdsBtn = document.getElementById('saveThresholdsBtn');
        const resetThresholdsBtn = document.getElementById('resetThresholdsBtn');
        const thresholdMessage = document.getElementById('thresholdMessage');
        const thresholdMessageText = document.getElementById('thresholdMessageText');

        // Element to capture for PDF export (the main content div)
        const mainContentArea = document.getElementById('mainContentArea');


        // Metrics to display as charts (including Accel & Gyro)
        const chartMetrics = [
            'TempÃ©rature (Â°C)', 
            'HumiditÃ© (%)', 
            'AccÃ©lÃ©ration', // Combined metric for X, Y, Z
            'Vibration', 
            'Temp. NTC (Â°C)', 
            'Courant (V Bruts)', 
            'Batterie (V)',
            'Gyroscope' // Combined metric for X, Y, Z
        ];

        // Define a set of appealing colors for charts
        // Expanded color palette for individual lines within combined charts
        const chartColors = [
            'rgb(75, 192, 192)', // Teal
            'rgb(255, 99, 132)', // Red
            'rgb(54, 162, 235)', // Blue
            'rgb(255, 205, 86)', // Yellow
            'rgb(153, 102, 255)',// Purple
            'rgb(255, 159, 64)', // Orange
            'rgb(201, 203, 207)',// Grey
            'rgb(102, 204, 0)',  // Lime Green
            'rgb(255, 102, 204)',// Pink
            'rgb(0, 153, 153)',  // Dark Teal
            'rgb(204, 51, 0)',   // Dark Red-Orange
            'rgb(51, 102, 255)', // Royal Blue
            'rgb(255, 0, 255)',  // Magenta (new)
            'rgb(0, 255, 255)',  // Cyan (new)
            'rgb(128, 0, 0)'     // Dark Green (new)
        ];

        // Define a set of different point styles for charts
        const pointStyles = [
            'circle',
            'triangle',
            'rect',
            'star',
            'cross',
            'crossRot',
            'dash',
            'line',
            'rectRounded',
            'rectRot',
            'triangle', // Repeat for more options if needed
            'circle', // Additional styles
            'rect',
            'star'
        ];

        // Define thresholds for sensor values (for alert indicators)
        // Store a copy of original thresholds to allow reset
        let THRESHOLDS = {
            'TempÃ©rature (Â°C)': { min: 10, max: 35, warningMin: 15, warningMax: 30 },
            'HumiditÃ© (%)': { min: 20, max: 80, warningMin: 30, warningMax: 70 },
            'Vibration': { min: 0, max: 100, warningMin: 50, warningMax: 80 }, // Example values
            'Temp. NTC (Â°C)': { min: 5, max: 40, warningMin: 10, warningMax: 35 },
            'Courant (V Bruts)': { min: 0.1, max: 5.0, warningMin: 0.5, warningMax: 4.5 },
            'Batterie (V)': { min: 3.0, max: 4.2, warningMin: 3.2, warningMax: 4.0 },
            'AccÃ©lÃ©ration X': { min: -5, max: 5, warningMin: -3, warningMax: 3 },
            'AccÃ©lÃ©ration Y': { min: -5, max: 5, warningMin: -3, warningMax: 3 },
            'AccÃ©lÃ©ration Z': { min: -15, max: 15, warningMin: -12, warningMax: 12 }, // Assuming Z is gravity
            'Gyroscope X': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
            'Gyroscope Y': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
            'Gyroscope Z': { min: -100, max: 100, warningMin: -50, warningMax: 50 },
        };
        const ORIGINAL_THRESHOLDS = JSON.parse(JSON.stringify(THRESHOLDS)); // Deep copy for reset


        // Translation object
        const translations = {
            'ar': {
                dashboardTitle: 'Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
                latestDataBtn: 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©',
                accelGyroBtn: 'ØªØ³Ø§Ø±Ø¹ ÙˆØ¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨',
                fullTableBtn: 'Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„',
                chartsBtn: 'Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©',
                settingsBtn: 'Ø§Ù„Ø¹Ø¯Ø§Ø¯Ø§Øª', 
                loadingText: 'Ø¬Ø§Ø±Ù ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...',
                errorTitle: 'Ø®Ø·Ø£!',
                errorText: 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­ Ùˆ Apps Script Ù…Ù†Ø´ÙˆØ± Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.',
                latestDataTitle: 'Ø£Ø­Ø¯Ø« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±',
                accelGyroTitle: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ³Ø§Ø±Ø¹ ÙˆØ§Ù„Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨',
                fullTableTitle: 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø§Ù„ØªØµÙÙŠØ©',
                fromDateLabel: 'Ù…Ù† ØªØ§Ø±ÙŠØ®:',
                toDateLabel: 'Ø¥Ù„Ù‰ ØªØ§Ø±ÙŠØ®:',
                fromTimeLabel: 'Ù…Ù† ØªÙˆÙ‚ÙŠØª:',
                toTimeLabel: 'Ø¥Ù„Ù‰ ØªÙˆÙ‚ÙŠØª:',
                applyFiltersBtn: 'ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØµÙÙŠØ©',
                resetFiltersBtn: 'Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†',
                exportCsvBtn: 'ØªØµØ¯ÙŠØ± CSV', 
                exportPdfBtn: 'ØªØµØ¯ÙŠØ± PDF', // New translation
                noDataFound: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§ Ø£Ùˆ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø·Ø§Ø¨Ù‚Ø© Ù„Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„ØªØµÙÙŠØ©.',
                chartsTitle: 'Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ© Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±',
                chartMetricLabel: 'Ø§Ø®ØªØ± Ø§Ù„Ù…Ù‚ÙŠØ§Ø³:', 
                minLabel: 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰:', 
                avgLabel: 'Ø§Ù„Ù…ØªÙˆØ³Ø·:', 
                maxLabel: 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰:', 
                invalidDate: 'ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­',
                invalidTime: 'ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­',
                invalidValue: 'ØºÙŠØ± ØµØ§Ù„Ø­',
                autoRefreshOn: 'ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ: ØªØ´ØºÙŠÙ„',
                autoRefreshOff: 'ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ: Ø¥ÙŠÙ‚Ø§Ù',
                generateInsightBtn: 'ØªÙˆÙ„ÙŠØ¯ Ø±Ø¤Ù‰ âœ¨',
                insightCardTitle: 'Ø±Ø¤Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
                noDataForInsight: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø±Ø¤Ù‰.',
                generatingInsight: 'Ø¬Ø§Ø±Ù ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø±Ø¤Ù‰...',
                insightError: 'ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø±Ø¤Ù‰. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.',
                insightFetchError: 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø¤Ù‰ Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
                copyInsightBtn: 'Ù†Ø³Ø® Ø§Ù„Ø±Ø¤ÙŠØ©', 
                copiedSuccess: 'ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ø¤ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!', 
                copyFailed: 'ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®.', 
                healthNormal: 'Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: Ø·Ø¨ÙŠØ¹ÙŠØ© âœ…', 
                healthWarning: 'Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ØªØ­Ø°ÙŠØ± âš ï¸', 
                healthCritical: 'Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: Ø­Ø±Ø¬ âŒ', 
                healthUnknown: 'Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ â“', 
                totalEntries: 'Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù„Ù„Ø¥Ø¯Ø®Ø§Ù„Ø§Øª:', 
                criticalAlerts: 'ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø­Ø±Ø¬Ø©:', 
                warningAlerts: 'ØªÙ†Ø¨ÙŠÙ‡Ø§Øª ØªØ­Ø°ÙŠØ±ÙŠØ©:', 
                thresholdSettingsTitle: 'Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡', 
                minThresholdLabel: 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰:', 
                maxThresholdLabel: 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰:', 
                warningMinThresholdLabel: 'ØªØ­Ø°ÙŠØ± (Ø£Ø¯Ù†Ù‰):', 
                warningMaxThresholdLabel: 'ØªØ­Ø°ÙŠØ± (Ø£Ù‚ØµÙ‰):', 
                saveThresholdsBtn: 'Ø­ÙØ¸ Ø§Ù„Ø­Ø¯ÙˆØ¯', 
                resetThresholdsBtn: 'Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø¯ÙˆØ¯', 
                thresholdsSavedSuccess: 'ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø¨Ù†Ø¬Ø§Ø­!', 
                thresholdsSaveError: 'Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø­Ø¯ÙˆØ¯. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ….', 
                exportPdfError: 'ÙØ´Ù„ ØªØµØ¯ÙŠØ± PDF.', // New translation
                chartLabels: {
                    'Timestamp': 'Ø§Ù„Ø®ØªÙ… Ø§Ù„Ø²Ù…Ù†ÙŠ',
                    'Date': 'Ø§Ù„ØªØ§Ø±ÙŠØ®',
                    'Heure': 'Ø§Ù„ØªÙˆÙ‚ÙŠØª',
                    'TempÃ©rature (Â°C)': 'Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø© (Â°C)',
                    'HumiditÃ© (%)': 'Ø§Ù„Ø±Ø·ÙˆØ¨Ø© (%)',
                    'AccÃ©lÃ©ration': 'Ø§Ù„ØªØ³Ø§Ø±Ø¹', 
                    'AccÃ©lÃ©ration X': 'Ø§Ù„ØªØ³Ø§Ø±Ø¹ X',
                    'AccÃ©lÃ©ration Y': 'Ø§Ù„ØªØ³Ø§Ø±Ø¹ Y',
                    'AccÃ©lÃ©ration Z': 'Ø§Ù„ØªØ³Ø§Ø±Ø¹ Z',
                    'Vibration': 'Ø§Ù„Ø§Ù‡ØªØ²Ø§Ø²',
                    'Temp. NTC (Â°C)': 'Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© NTC (Â°C)',
                    'Courant (V Bruts)': 'Ø§Ù„ØªÙŠØ§Ø± (ÙÙˆÙ„Øª Ø®Ø§Ù…)',
                    'Batterie (V)': 'Ø§Ù„Ø¨Ø·Ø§Ø±ÙŠØ© (ÙÙˆÙ„Øª)',
                    'Gyroscope': 'Ø§Ù„Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨', 
                    'Gyroscope X': 'Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨ X',
                    'Gyroscope Y': 'Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨ Y',
                    'Gyroscope Z': 'Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨ Z'
                },
                prevPage: 'Ø§Ù„Ø³Ø§Ø¨Ù‚',
                nextPage: 'Ø§Ù„ØªØ§Ù„ÙŠ',
                pageInfo: (currentPage, totalPages) => `ØµÙØ­Ø© ${currentPage} Ù…Ù† ${totalPages}`
            },
            'en': {
                dashboardTitle: 'Data Dashboard',
                latestDataBtn: 'Latest Data',
                accelGyroBtn: 'Acceleration & Gyro',
                fullTableBtn: 'Full Table',
                chartsBtn: 'Charts',
                settingsBtn: 'Settings', 
                loadingText: 'Loading data...',
                errorTitle: 'Error!',
                errorText: 'Failed to load data. Please ensure the data source is available and Apps Script is correctly deployed.',
                latestDataTitle: 'Latest Sensor Data',
                accelGyroTitle: 'Acceleration and Gyroscope Data',
                fullTableTitle: 'Full Data with Filters',
                fromDateLabel: 'From Date:',
                toDateLabel: 'To Date:',
                fromTimeLabel: 'From Time:',
                toTimeLabel: 'To Time:',
                applyFiltersBtn: 'Apply Filter',
                resetFiltersBtn: 'Reset',
                exportCsvBtn: 'Export CSV', 
                exportPdfBtn: 'Export PDF', // New translation
                noDataFound: 'No data to display or no data matching filter criteria.',
                chartsTitle: 'Sensor Data Charts',
                chartMetricLabel: 'Select Metric:', 
                minLabel: 'Min:', 
                avgLabel: 'Avg:', 
                maxLabel: 'Max:', 
                invalidDate: 'Invalid Date',
                invalidTime: 'Invalid Time',
                invalidValue: 'Invalid',
                autoRefreshOn: 'Auto Refresh: ON',
                autoRefreshOff: 'Auto Refresh: OFF',
                generateInsightBtn: 'Generate Insight âœ¨',
                insightCardTitle: 'Data Insight',
                noDataForInsight: 'No data available to generate insights.',
                generatingInsight: 'Generating insight...',
                insightError: 'Failed to generate insight. Please try again.',
                insightFetchError: 'Error fetching insight from AI',
                copyInsightBtn: 'Copy Insight', 
                copiedSuccess: 'Insight copied successfully!', 
                copyFailed: 'Failed to copy.', 
                healthNormal: 'Data Health: Normal âœ…', 
                healthWarning: 'Data Health: Warning âš ï¸', 
                healthCritical: 'Data Health: Critical âŒ', 
                healthUnknown: 'Data Health: Unknown â“', 
                totalEntries: 'Total Entries:', 
                criticalAlerts: 'Critical Alerts:', 
                warningAlerts: 'Warning Alerts:', 
                thresholdSettingsTitle: 'Alert Threshold Settings', 
                minThresholdLabel: 'Min Threshold:', 
                maxThresholdLabel: 'Max Threshold:', 
                warningMinThresholdLabel: 'Warning (Min):', 
                warningMaxThresholdLabel: 'Warning (Max):', 
                saveThresholdsBtn: 'Save Thresholds', 
                resetThresholdsBtn: 'Reset Thresholds', 
                thresholdsSavedSuccess: 'Thresholds saved successfully!', 
                thresholdsSaveError: 'Error saving thresholds. Please check values.', 
                exportPdfError: 'Failed to export PDF.', // New translation
                chartLabels: {
                    'Timestamp': 'Timestamp',
                    'Date': 'Date',
                    'Heure': 'Time',
                    'TempÃ©rature (Â°C)': 'Temperature (Â°C)',
                    'HumiditÃ© (%)': 'Humidity (%)',
                    'AccÃ©lÃ©ration': 'Acceleration', 
                    'AccÃ©lÃ©ration X': 'Acceleration X',
                    'AccÃ©lÃ©ration Y': 'Acceleration Y',
                    'AccÃ©lÃ©ration Z': 'Acceleration Z',
                    'Vibration': 'Vibration',
                    'Temp. NTC (Â°C)': 'NTC Temp (Â°C)',
                    'Courant (V Bruts)': 'Current (Raw V)',
                    'Batterie (V)': 'Battery (V)',
                    'Gyroscope': 'Gyroscope', 
                    'Gyroscope X': 'Gyroscope X',
                    'Gyroscope Y': 'Gyroscope Y',
                    'Gyroscope Z': 'Gyroscope Z'
                },
                prevPage: 'Previous',
                nextPage: 'Next',
                pageInfo: (currentPage, totalPages) => `Page ${currentPage} of ${totalPages}`
            },
            'fr': {
                dashboardTitle: 'Tableau de Bord des DonnÃ©es',
                latestDataBtn: 'DerniÃ¨res DonnÃ©es',
                accelGyroBtn: 'AccÃ©lÃ©ration & Gyro',
                fullTableBtn: 'Tableau Complet',
                chartsBtn: 'Graphiques',
                settingsBtn: 'ParamÃ¨tres', 
                loadingText: 'Chargement des donnÃ©es...',
                errorTitle: 'Erreur!',
                errorText: 'Ã‰chec du chargement des donnÃ©es. Veuillez vous assurer que la source de donnÃ©es est disponible et que le script Apps Script est correctement dÃ©ploye.',
                latestDataTitle: 'DerniÃ¨res DonnÃ©es des Capteurs',
                accelGyroTitle: 'DonnÃ©es d\'AccÃ©lÃ©ration et de Gyroscope',
                fullTableTitle: 'Tableau Complet des DonnÃ©es avec Filtres',
                fromDateLabel: 'Du Date:',
                toDateLabel: 'Au Date:',
                fromTimeLabel: 'Du Temps:',
                toTimeLabel: 'Au Temps:',
                applyFiltersBtn: 'Appliquer le Filtre',
                resetFiltersBtn: 'RÃ©initialiser',
                exportCsvBtn: 'Exporter CSV', 
                exportPdfBtn: 'Exporter PDF', // New translation
                noDataFound: 'Aucune donnÃ©e Ã  afficher ou aucune donnÃ©e ne correspond aux critÃ¨res de filtre.',
                chartsTitle: 'Graphiques des DonnÃ©es des Capteurs',
                chartMetricLabel: 'SÃ©lectionner une mÃ©trique:', 
                minLabel: 'Min:', 
                avgLabel: 'Moy:', 
                maxLabel: 'Max:', 
                invalidDate: 'Date Invalide',
                invalidTime: 'Heure Invalide',
                invalidValue: 'Invalide',
                autoRefreshOn: 'Actualisation automatique: ON',
                autoRefreshOff: 'Actualisation automatique: OFF',
                generateInsightBtn: 'GÃ©nÃ©rer une perspicacitÃ© âœ¨',
                insightCardTitle: 'PerspicacitÃ© des DonnÃ©es',
                noDataForInsight: 'Aucune donnÃ©e disponible pour gÃ©nÃ©rer des perspicacitÃ©s.',
                generatingInsight: 'GÃ©nÃ©ration de la perspicacitÃ©...',
                insightError: 'Ã‰chec de la gÃ©nÃ©ration de la perspicacitÃ©. Veuillez rÃ©essayer.',
                insightFetchError: 'Erreur lors de la rÃ©cupÃ©ration de la perspicacitÃ© Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
                copyInsightBtn: 'Copier la perspicacitÃ©', 
                copiedSuccess: 'PerspicacitÃ© copiÃ©e Ø¨Ù†Ø¬Ø§Ø­!', 
                copyFailed: 'Ã‰chec de la copie.', 
                healthNormal: 'Ã‰tat des donnÃ©es: Normal âœ…', 
                healthWarning: 'Ã‰tat des donnÃ©es: Avertissement âš ï¸', 
                healthCritical: 'Ã‰tat des donnÃ©es: Critique âŒ', 
                healthUnknown: 'Ã‰tat des donnÃ©es: Inconnu â“', 
                totalEntries: 'Total des entrÃ©es:', 
                criticalAlerts: 'Alertes critiques:', 
                warningAlerts: 'Alertes d\'avertissement:', 
                thresholdSettingsTitle: 'ParamÃ¨tres des seuils d\'alerte', 
                minThresholdLabel: 'Seuil Min:', 
                maxThresholdLabel: 'Seuil Max:', 
                warningMinThresholdLabel: 'Avertissement (Min):', 
                warningMaxThresholdLabel: 'Avertissement (Max):', 
                saveThresholdsBtn: 'Enregistrer les seuils', 
                resetThresholdsBtn: 'RÃ©initialiser les seuils', 
                thresholdsSavedSuccess: 'Seuils enregistrÃ©s avec succÃ¨s!', 
                thresholdsSaveError: 'Erreur lors de l\'enregistrement des seuils. Veuillez vÃ©rifier les valeurs.', 
                exportPdfError: 'Ã‰chec de l\'exportation PDF.', // New translation
                chartLabels: {
                    'Timestamp': 'Horodatage',
                    'Date': 'Date',
                    'Heure': 'Heure',
                    'TempÃ©rature (Â°C)': 'TempÃ©rature (Â°C)',
                    'HumiditÃ© (%)': 'HumiditÃ© (%)',
                    'AccÃ©lÃ©ration': 'AccÃ©lÃ©ration', 
                    'AccÃ©lÃ©ration X': 'AccÃ©lÃ©ration X',
                    'AccÃ©lÃ©ration Y': 'AccÃ©lÃ©ration Y',
                    'AccÃ©lÃ©ration Z': 'AccÃ©lÃ©ration Z',
                    'Vibration': 'Vibration',
                    'Temp. NTC (Â°C)': 'Temp. NTC (Â°C)',
                    'Courant (V Bruts)': 'Courant (V bruts)',
                    'Batterie (V)': 'Batterie (V)',
                    'Gyroscope': 'Gyroscope', 
                    'Gyroscope X': 'Gyroscope X',
                    'Gyroscope Y': 'Gyroscope Y',
                    'Gyroscope Z': 'Gyroscope Z'
                },
                prevPage: 'PrÃ©cÃ©dent',
                nextPage: 'Suivant',
                pageInfo: (currentPage, totalPages) => `Page ${currentPage} sur ${totalPages}`
            }
        };

        /**
         * Helper function to parse a date/time string into a Date object.
         * This function assumes the input dateString is in 'YYYY-MM-DD' format and timeString is 'HH:MM:SS'.
         * It constructs an ISO 8601 string and creates a Date object.
         * The 'Z' indicates UTC, so JavaScript will convert it to the local timezone automatically.
         * @param {string} dateString - The date part (e.g., "2025-06-22").
         * @param {string} timeString - The time part (e.g., "17:27:03").
         * @returns {Date | null} A Date object in local timezone, or null if invalid.
         */
        function parseDateTimeToLocalDate(dateString, timeString) {
            // Ensure dateString is justgetFullYear-MM-DD
            let parsedDatePart = String(dateString).split('T')[0];
            // Ensure timeString is just HH:MM:SS
            let parsedTimePart = String(timeString);
            if (parsedTimePart.includes('T')) {
                parsedTimePart = parsedTimePart.split('T')[1].substring(0, 8);
            } else {
                parsedTimePart = parsedTimePart.substring(0, 8);
            }

            // Combine and assume UTC for parsing, then JS converts to local time
            const isoString = `${parsedDatePart}T${parsedTimePart}Z`;
            const date = new Date(isoString);

            return isNaN(date.getTime()) ? null : date;
        }


        /**
         * Helper function to get only the date part formatted for local display.
         * @param {string} dateValue - The original date string from 'Date' column.
         * @param {string} timeValue - The original time string from 'Heure' column.
         * @returns {string} Formatted local date string (e.g., "06/27/2025" for en-US).
         */
        function getFormattedDateForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Use currentLanguage for locale formatting (e.g., 'fr' for dd/mm/yyyy)
                return dateObj.toLocaleDateString(currentLanguage, { year: 'numeric', month: '2-digit', day: '2-digit' });
            }
            return translations[currentLanguage].invalidDate;
        }

        /**
         * Helper function to get only the time part formatted for local display.
         * @param {string} dateValue - The original date string from 'Date' column.
         * @param {string} timeValue - The original time string from 'Heure' column.
         * @returns {string} Formatted local time string (e.g., "14:02:03").
         */
        function getFormattedTimeForDisplay(dateValue, timeValue) {
            const dateObj = parseDateTimeToLocalDate(dateValue, timeValue);
            if (dateObj) {
                // Use currentLanguage for locale formatting (e.g., 'fr' for 24-hour format)
                return dateObj.toLocaleTimeString(currentLanguage, { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
            return translations[currentLanguage].invalidTime;
        }
        
        /**
         * Helper function to format numeric values (e.g., temperature, humidity, acceleration).
         * @param {string | number} value - The numeric value.
         * @param {number} [decimalPlaces=2] - Number of decimal places to format to.
         * @returns {string} Formatted number string or 'Invalid'.
         */
        function formatNumericValue(value, decimalPlaces = 2) {
            const parsedValue = parseFloat(value);
            if (!isNaN(parsedValue)) {
                // Use currentLanguage for locale-specific number formatting (e.g., French uses comma for decimal)
                return parsedValue.toLocaleString(currentLanguage, { minimumFractionDigits: decimalPlaces, maximumFractionDigits: decimalPlaces });
            }
            return translations[currentLanguage].invalidValue;
        }

        /**
         * Updates the display with the current local date and time based on currentLanguage.
         */
        function updateCurrentDateTimeDisplay() {
            const now = new Date();
            const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

            currentDateDisplay.textContent = now.toLocaleDateString(currentLanguage, dateOptions);
            currentTimeDisplay.textContent = now.toLocaleTimeString(currentLanguage, timeOptions);
        }

        /**
         * Shows a specific page section and hides others.
         * Destroys existing chart instances to prevent memory leaks when switching away from charts.
         * @param {string} pageId - The ID of the page section to show.
         */
        function showPage(pageId) {
            // Hide all content sections
            document.querySelectorAll('.page-content').forEach(section => {
                section.classList.add('hidden');
            });
            // Show the requested content section
            document.getElementById(pageId).classList.remove('hidden');

            // Destroy existing single chart instance when leaving charts page
            if (pageId !== 'charts' && chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            
            // Re-render the specific section that is now visible to apply any latest data or language changes
            const filteredData = getFilteredSensorData(); // Get filtered data for the current UI state
            if (pageId === 'latestData') {
                renderLatestData(sensorData); // Latest data always uses full data to find last entry
            } else if (pageId === 'fullTable') {
                currentPage = 1; // Reset to first page when navigating to table
                renderFullTable(filteredData); // Render table with filtered data
            } else if (pageId === 'charts') {
                // Render the selected chart based on the dropdown, or the first one by default
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, filteredData); // Render charts with filtered data
            } else if (pageId === 'accelGyroData') {
                renderAccelGyroData(sensorData);
            } else if (pageId === 'thresholdSettings') {
                renderThresholdSettings(); // Render the settings page
            }
        }

        /**
         * Fetches all data from the Google Sheets API.
         * No longer accepts filters, always fetches full dataset.
         */
        async function fetchData() {
            loadingIndicator.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');

            try {
                const response = await fetch(GOOGLE_SHEETS_API_URL); // Fetch all data
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                const data = await response.json();
                
                let actualData = [];
                if (Array.isArray(data) && data.length > 0) {
                    actualData = data;
                } else if (data && Array.isArray(data.data) && data.data.length > 0) {
                    actualData = data.data;
                } else {
                    actualData = []; 
                    console.warn('Data format is invalid or no data found.');
                }
                
                // Sort the data by 'Date' then 'Heure' to ensure the latest data is at the end
                actualData.sort((a, b) => {
                    const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                    const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                    if (!dateA || isNaN(dateA.getTime())) return 1;
                    if (!dateB || isNaN(dateB.getTime())) return -1;
                    return dateA.getTime() - dateB.getTime();
                });

                // Store previous latest entry for comparison before updating sensorData
                if (sensorData.length > 0) {
                    previousLatestEntry = sensorData[sensorData.length - 1];
                } else {
                    previousLatestEntry = {};
                }

                sensorData = actualData; // Store the FULL fetched data
                
                // Re-render based on the currently active page after fetching new data
                const activePageId = document.querySelector('.page-content:not(.hidden)').id;
                const filteredData = getFilteredSensorData(); // Get filtered data for active page if needed

                if (activePageId === 'latestData') {
                    renderLatestData(sensorData);
                } else if (activePageId === 'fullTable') {
                    // Re-render table, staying on the current page if possible
                    renderFullTable(filteredData); 
                } else if (activePageId === 'charts') {
                    const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                    renderChart(selectedMetric, filteredData); // Render selected chart with new data
                } else if (activePageId === 'accelGyroData') {
                    renderAccelGyroData(sensorData);
                }

            } catch (error) {
                console.error('Error fetching data:', error); // Log the full error object
                errorTextSpan.textContent = translations[currentLanguage].errorText + ` (${error.message || error})`;
                errorMessageDiv.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Determines the status of a value against its thresholds.
         * @param {string} metricName - The name of the metric.
         * @param {number} value - The current value.
         * @returns {string} 'normal', 'warning', 'critical', or 'unknown'.
         */
        function getValueStatus(metricName, value) {
            const thresholds = THRESHOLDS[metricName];
            if (!thresholds || isNaN(value)) {
                return 'unknown';
            }

            if (value < thresholds.min || value > thresholds.max) {
                return 'critical';
            } else if (value < thresholds.warningMin || value > thresholds.warningMax) {
                return 'warning';
            } else {
                return 'normal';
            }
        }

        /**
         * Renders the latest sensor data on the main page.
         * Includes value change indicators and threshold alerts.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderLatestData(data) {
            latestDataContent.innerHTML = '';
            
            if (data.length === 0) {
                latestDataContent.innerHTML = `<p class="text-gray-500 text-center col-span-full">${translations[currentLanguage].noDataFound}</p>`;
                insightCard.classList.add('hidden');
                return;
            }

            const latestEntry = data[data.length - 1];
            const labels = translations[currentLanguage].chartLabels;

            // Calculate overall data health and alerts
            let criticalAlertCount = 0;
            let warningAlertCount = 0;
            let overallHealth = 'normal';

            data.forEach(entry => {
                for (const key in entry) {
                    if (entry.hasOwnProperty(key) && THRESHOLDS[key]) {
                        const value = parseFloat(entry[key]);
                        const status = getValueStatus(key, value);
                        if (status === 'critical') {
                            criticalAlertCount++;
                        } else if (status === 'warning') {
                            warningAlertCount++;
                        }
                    }
                }
            });

            if (criticalAlertCount > 0) {
                overallHealth = 'critical';
            } else if (warningAlertCount > 0) {
                overallHealth = 'warning';
            }

            // Create and append Total Entries card
            const totalEntriesCard = document.createElement('div');
            totalEntriesCard.className = 'glassmorphism-card p-6 data-card-interactive';
            totalEntriesCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-2">${translations[currentLanguage].totalEntries}</h3>
                <p class="text-2xl font-bold text-gray-900">${data.length}</p>
            `;
            latestDataContent.appendChild(totalEntriesCard);

            // Create and append Data Health card
            const dataHealthCard = document.createElement('div');
            let healthText = '';
            let healthColor = '';
            if (overallHealth === 'critical') {
                healthText = translations[currentLanguage].healthCritical;
                healthColor = 'text-red-600';
            } else if (overallHealth === 'warning') {
                healthText = translations[currentLanguage].healthWarning;
                healthColor = 'text-orange-500';
            } else {
                healthText = translations[currentLanguage].healthNormal;
                healthColor = 'text-green-600';
            }

            dataHealthCard.className = 'glassmorphism-card p-6 data-card-interactive';
            dataHealthCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-2">Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©</h3>
                <p class="text-2xl font-bold ${healthColor} mb-2">${healthText}</p>
                <p class="text-lg text-gray-800">${translations[currentLanguage].criticalAlerts} <span class="font-bold text-red-600">${criticalAlertCount}</span></p>
                <p class="text-lg text-gray-800">${translations[currentLanguage].warningAlerts} <span class="font-bold text-orange-500">${warningAlertCount}</span></p>
            `;
            latestDataContent.appendChild(dataHealthCard);


            for (const key in latestEntry) {
                // Exclude the individual Accel and Gyro components from this section, as they are now grouped
                if (latestEntry.hasOwnProperty(key) && 
                    !['AccÃ©lÃ©ration X', 'AccÃ©lÃ©ration Y', 'AccÃ©lÃ©ration Z', 
                       'Gyroscope X', 'Gyroscope Y', 'Gyroscope Z', 'Timestamp', 'Date', 'Heure'].includes(key) &&
                    !['AccÃ©lÃ©ration', 'Gyroscope'].includes(key) // Also exclude the combined metrics to avoid duplicates
                    ) {
                    let valueToDisplay = latestEntry[key];
                    let changeIndicator = '';
                    let alertIndicator = '';

                    const displayLabel = labels[key] || key;

                    if (chartMetrics.includes(key) || 
                                (key.startsWith('AccÃ©lÃ©ration') && chartMetrics.includes('AccÃ©lÃ©ration')) ||
                                (key.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        const numericValue = parseFloat(valueToDisplay);
                        valueToDisplay = formatNumericValue(numericValue);

                        // Value Change Indicator
                        if (previousLatestEntry[key] !== undefined && !isNaN(parseFloat(previousLatestEntry[key]))) {
                            const prevValue = parseFloat(previousLatestEntry[key]);
                            const change = numericValue - prevValue;
                            if (prevValue !== 0) { // Avoid division by zero
                                const percentageChange = (change / prevValue) * 100;
                                let arrow = '';
                                let color = 'text-gray-500';
                                if (change > 0) {
                                    arrow = 'â–²'; // Up arrow
                                    color = 'text-green-500';
                                } else if (change < 0) {
                                    arrow = 'â–¼'; // Down arrow
                                    color = 'text-red-500';
                                }
                                changeIndicator = `<span class="${color} text-sm font-semibold ml-2">${arrow} ${Math.abs(percentageChange).toFixed(1)}%</span>`;
                            }
                        }

                        // Threshold Alert Indicator
                        const status = getValueStatus(key, numericValue);
                        if (status === 'warning') {
                            alertIndicator = '<span class="text-orange-500 ml-2 text-xl" title="Warning: Value near limit">âš ï¸</span>';
                        } else if (status === 'critical') {
                            alertIndicator = '<span class="text-red-600 ml-2 text-xl" title="Critical: Value out of limit">âŒ</span>';
                        }
                    } else if (key === 'Date') {
                        valueToDisplay = getFormattedDateForDisplay(valueToDisplay, latestEntry['Heure']);
                    } else if (key === 'Heure') {
                        valueToDisplay = getFormattedTimeForDisplay(latestEntry['Date'], valueToDisplay);
                    }

                    const dataCard = document.createElement('div');
                    // Added data-card-interactive for animations
                    dataCard.className = 'glassmorphism-card p-6 data-card-interactive';
                    dataCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-blue-700 mb-2">${displayLabel}</h3>
                        <p class="text-2xl font-bold text-gray-900 flex items-center">
                            ${valueToDisplay}
                            ${changeIndicator}
                            ${alertIndicator}
                        </p>
                    `;
                    latestDataContent.appendChild(dataCard);
                }
            }
            insightCard.classList.add('hidden');
            insightContent.textContent = '';
        }

        /**
         * Renders acceleration and gyroscope data in dedicated cards.
         * @param {Array<Object>} data - The full sensor data array.
         */
        function renderAccelGyroData(data) {
            accelGyroContent.innerHTML = '';
            if (data.length === 0) {
                accelGyroContent.innerHTML = `<p class="text-gray-500 text-center col-span-full">${translations[currentLanguage].noDataFound}</p>`;
                return;
            }

            const latestEntry = data[data.length - 1];
            const labels = translations[currentLanguage].chartLabels;

            // Create Acceleration Card
            const accelCard = document.createElement('div');
            // Added data-card-interactive for animations
            accelCard.className = 'glassmorphism-card p-6 data-card-interactive';
            accelCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-4">${labels['AccÃ©lÃ©ration']}</h3>
                <div class="space-y-2">
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['AccÃ©lÃ©ration X']}:</span> ${formatNumericValue(latestEntry['AccÃ©lÃ©ration X'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'AccÃ©lÃ©ration X')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['AccÃ©lÃ©ration Y']}:</span> ${formatNumericValue(latestEntry['AccÃ©lÃ©ration Y'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'AccÃ©lÃ©ration Y')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['AccÃ©lÃ©ration Z']}:</span> ${formatNumericValue(latestEntry['AccÃ©lÃ©ration Z'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'AccÃ©lÃ©ration Z')}</p>
                </div>
            `;
            accelGyroContent.appendChild(accelCard);

            // Create Gyroscope Card
            const gyroCard = document.createElement('div');
            // Added data-card-interactive for animations
            gyroCard.className = 'glassmorphism-card p-6 data-card-interactive';
            gyroCard.innerHTML = `
                <h3 class="text-xl font-semibold text-blue-700 mb-4">${labels['Gyroscope']}</h3>
                <div class="space-y-2">
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope X']}:</span> ${formatNumericValue(latestEntry['Gyroscope X'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope X')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope Y']}:</span> ${formatNumericValue(latestEntry['Gyroscope Y'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope Y')}</p>
                    <p class="text-lg text-gray-800 flex items-center"><span class="font-semibold">${labels['Gyroscope Z']}:</span> ${formatNumericValue(latestEntry['Gyroscope Z'])} ${getChangeAndAlert(latestEntry, previousLatestEntry, 'Gyroscope Z')}</p>
                </div>
            `;
            accelGyroContent.appendChild(gyroCard);
        }

        /**
         * Helper function to generate change indicator and alert for a metric.
         * @param {Object} currentData - The current data entry.
         * @param {Object} prevData - The previous data entry.
         * @param {string} key - The metric key.
         * @returns {string} HTML string for change and alert indicators.
         */
        function getChangeAndAlert(currentData, prevData, key) {
            let changeIndicator = '';
            let alertIndicator = '';
            const numericValue = parseFloat(currentData[key]);

            // Value Change Indicator
            if (prevData[key] !== undefined && !isNaN(parseFloat(prevData[key]))) {
                const prevValue = parseFloat(prevData[key]);
                const change = numericValue - prevValue;
                if (prevValue !== 0) {
                    const percentageChange = (change / prevValue) * 100;
                    let arrow = '';
                    let color = 'text-gray-500';
                    if (change > 0) {
                        arrow = 'â–²';
                        color = 'text-green-500';
                    } else if (change < 0) {
                        arrow = 'â–¼';
                        color = 'text-red-500';
                    }
                    changeIndicator = `<span class="${color} text-sm font-semibold mr-1">${arrow} ${Math.abs(percentageChange).toFixed(1)}%</span>`;
                }
            }

            // Threshold Alert Indicator
            const status = getValueStatus(key, numericValue);
            if (status === 'warning') {
                alertIndicator = '<span class="text-orange-500 ml-1 text-xl" title="Warning: Value near limit">âš ï¸</span>';
            } else if (status === 'critical') {
                alertIndicator = '<span class="text-red-600 ml-1 text-xl" title="Critical: Value out of limit">âŒ</span>';
            }
            return `${changeIndicator}${alertIndicator}`;
        }

        /**
         * Returns a filtered subset of sensorData based on current filter inputs.
         * This function centralizes the filtering logic for both table and charts.
         * @returns {Array<Object>} The filtered data.
         */
        function getFilteredSensorData() {
            let filteredClientData = [...sensorData]; // Start with a copy of all data
            const fromDateVal = fromDateInput.value;
            const toDateVal = toDateInput.value;
            const fromTimeVal = fromTimeInput.value;
            const toTimeVal = toTimeInput.value;

            if (fromDateVal || toDateVal || fromTimeVal || toTimeVal) {
                let filterStartDateTime = null;
                let filterEndDateTime = null;

                // Construct filter start date/time
                if (fromDateVal) {
                    const timePart = fromTimeVal || '00:00:00'; // Default to start of day if no time
                    filterStartDateTime = parseDateTimeToLocalDate(fromDateVal, timePart);
                    if (isNaN(filterStartDateTime.getTime())) filterStartDateTime = null;
                } else if (fromTimeVal) {
                    const today = new Date().toISOString().split('T')[0];
                    filterStartDateTime = parseDateTimeToLocalDate(today, fromTimeVal);
                    if (isNaN(filterStartDateTime.getTime())) filterStartDateTime = null;
                }

                // Construct filter end date/time
                if (toDateVal) {
                    const timePart = toTimeVal || '23:59:59'; // Default to end of day if no time
                    filterEndDateTime = parseDateTimeToLocalDate(toDateVal, timePart);
                    if (isNaN(filterEndDateTime.getTime())) filterEndDateTime = null;
                } else if (toTimeVal) {
                    const today = new Date().toISOString().split('T')[0];
                    filterEndDateTime = parseDateTimeToLocalDate(today, toTimeVal);
                    if (isNaN(filterEndDateTime.getTime())) filterEndDateTime = null;
                }

                filteredClientData = filteredClientData.filter(row => {
                    const rowDateTime = parseDateTimeToLocalDate(row.Date, row.Heure);

                    if (!rowDateTime || isNaN(rowDateTime.getTime())) {
                        return false;
                    }

                    let pass = true;
                    if (filterStartDateTime && rowDateTime < filterStartDateTime) {
                        pass = false;
                    }
                    if (pass && filterEndDateTime && rowDateTime > filterEndDateTime) {
                        pass = false;
                    }
                    return pass;
                });
            }
            return filteredClientData;
        }

        /**
         * Renders the full data table, applying client-side filters and pagination.
         * @param {Array<Object>} dataToRender - The data (already filtered by getFilteredSensorData).
         */
        function renderFullTable(dataToRender) {
            tableHeaderRow.innerHTML = '';
            tableBody.innerHTML = '';
            noDataFoundDiv.classList.add('hidden');

            if (dataToRender.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="100%" class="text-center py-4 text-gray-500">${translations[currentLanguage].noDataFound}</td></tr>`;
                noDataFoundDiv.classList.remove('hidden');
                paginationControls.classList.add('hidden');
                return;
            }

            const headers = Object.keys(dataToRender[0]);
            const translatedHeaders = translations[currentLanguage].chartLabels;

            // Render headers only once
            if (tableHeaderRow.children.length === 0) {
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-right';
                    th.textContent = translatedHeaders[header] || header;
                    tableHeaderRow.appendChild(th);
                });
            }

            // Implement pagination
            const totalPages = Math.ceil(dataToRender.length / itemsPerPage);
            currentPage = Math.min(Math.max(1, currentPage), totalPages); // Ensure currentPage is valid

            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedData = dataToRender.slice(startIndex, endIndex);

            paginatedData.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-900';
                    
                    let cellValue = row[header];
                    if (header === 'Date') {
                        cellValue = getFormattedDateForDisplay(cellValue, row['Heure']);
                    } else if (header === 'Heure') {
                        cellValue = getFormattedTimeForDisplay(row['Date'], cellValue);
                    } else if (chartMetrics.includes(header) || 
                                (header.startsWith('AccÃ©lÃ©ration') && chartMetrics.includes('AccÃ©lÃ©ration')) ||
                                (header.startsWith('Gyroscope') && chartMetrics.includes('Gyroscope'))
                            ) {
                        cellValue = formatNumericValue(cellValue);
                    }
                    td.textContent = cellValue;
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });

            // Update pagination controls
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;
            pageInfo.textContent = translations[currentLanguage].pageInfo(currentPage, totalPages);
            paginationControls.classList.remove('hidden');
        }

        /**
         * Applies filters by re-rendering the currently active relevant page (table or charts).
         */
        function applyFilters() {
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            const filteredData = getFilteredSensorData(); // Get newly filtered data

            if (activePageId === 'fullTable') {
                currentPage = 1; // Reset to first page on filter change
                renderFullTable(filteredData); // Re-render table
            } else if (activePageId === 'charts') {
                const selectedMetric = chartMetricSelect.value || chartMetrics[0]; // Use current selection or default
                renderChart(selectedMetric, filteredData); // Re-render charts
            }
        }

        /**
         * Resets all filter inputs and re-renders the relevant page with all data.
         */
        function resetFilters() {
            fromDateInput.value = '';
            toDateInput.value = '';
            fromTimeInput.value = '';
            toTimeInput.value = '';
            
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            // When resetting, we effectively want to show all data, so filter with empty criteria
            const allData = getFilteredSensorData(); // This will return sensorData as inputs are empty
            
            if (activePageId === 'fullTable') {
                currentPage = 1; // Reset to first page on filter reset
                renderFullTable(allData); // Re-render table with all data
            } else if (activePageId === 'charts') {
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, allData); // Re-render charts with all data
            }
        }

        /**
         * Populates the chart metric dropdown.
         */
        function populateChartMetricSelect() {
            chartMetricSelect.innerHTML = ''; // Clear existing options
            // Combine chartMetrics with individual Accel/Gyro axes
            const allMetrics = [...new Set(chartMetrics.concat(
                Object.keys(sensorData.length > 0 ? sensorData[0] : {}).filter(key => 
                    key.startsWith('AccÃ©lÃ©ration') || key.startsWith('Gyroscope')
                )
            ))].filter(m => m !== 'Timestamp' && m !== 'Date' && m !== 'Heure'); // Filter out date/time for dropdown
            
            // Reorder to put combined metrics first if they exist
            const orderedMetrics = [];
            if (allMetrics.includes('AccÃ©lÃ©ration')) orderedMetrics.push('AccÃ©lÃ©ration');
            if (allMetrics.includes('Gyroscope')) orderedMetrics.push('Gyroscope');

            // Add other unique metrics that are not combined
            allMetrics.forEach(metric => {
                if (!orderedMetrics.includes(metric) && !metric.startsWith('AccÃ©lÃ©ration ') && !metric.startsWith('Gyroscope ')) {
                    orderedMetrics.push(metric);
                }
            });
            // Add individual Accel/Gyro axes at the end
            allMetrics.forEach(metric => {
                if (!orderedMetrics.includes(metric) && (metric.startsWith('AccÃ©lÃ©ration ') || metric.startsWith('Gyroscope '))) {
                    orderedMetrics.push(metric);
                }
            });


            orderedMetrics.forEach(metric => {
                const option = document.createElement('option');
                option.value = metric;
                option.textContent = translations[currentLanguage].chartLabels[metric] || metric;
                chartMetricSelect.appendChild(option);
            });

            // Set default selection if a value was previously selected
            if (chartMetricSelect.dataset.selected) {
                chartMetricSelect.value = chartMetricSelect.dataset.selected;
            } else {
                chartMetricSelect.value = orderedMetrics[0] || '';
            }
        }


        /**
         * Renders a single chart for the specified metric.
         * @param {string} selectedMetric - The metric to render (e.g., 'TempÃ©rature (Â°C)', 'AccÃ©lÃ©ration').
         * @param {Array<Object>} dataToRender - The data to use for rendering the chart (already filtered).
         */
        function renderChart(selectedMetric, dataToRender) {
            if (dataToRender.length === 0) {
                mainChartCanvas.classList.add('hidden');
                currentChartTitle.textContent = translations[currentLanguage].noDataFound;
                chartStats.classList.add('hidden');
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                return;
            } else {
                mainChartCanvas.classList.remove('hidden');
                chartStats.classList.remove('hidden');
            }

            const sortedData = [...dataToRender].sort((a, b) => {
                const dateA = parseDateTimeToLocalDate(a.Date, a.Heure);
                const dateB = parseDateTimeToLocalDate(b.Date, b.Heure);
                if (!dateA || isNaN(dateA.getTime())) return 1;
                if (!dateB || isNaN(dateB.getTime())) return -1;
                return dateA.getTime() - dateB.getTime();
            });

            const labels = sortedData.map(entry => {
                const date = parseDateTimeToLocalDate(entry.Date, entry.Heure);
                if (date && !isNaN(date.getTime())) {
                    return date.toLocaleString(currentLanguage, {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false
                    });
                }
                return translations[currentLanguage].invalidDate + '/' + translations[currentLanguage].invalidTime;
            });

            let datasets = [];
            let chartMetricLabel = translations[currentLanguage].chartLabels[selectedMetric] || selectedMetric;
            currentChartTitle.textContent = chartMetricLabel;

            let values = []; // To store values for min/max/avg calculation

            if (selectedMetric === 'AccÃ©lÃ©ration') {
                ['X', 'Y', 'Z'].forEach((axis, i) => {
                    const componentMetric = `AccÃ©lÃ©ration ${axis}`;
                    const color = chartColors[i % chartColors.length]; // Use limited colors for combined chart
                    const pointStyle = pointStyles[i % pointStyles.length];

                    const dataForAxis = sortedData.map(entry => {
                        const val = parseFloat(entry[componentMetric]);
                        if (!isNaN(val)) values.push(val); // Add to values for stats
                        return val || 0;
                    });

                    datasets.push({
                        label: translations[currentLanguage].chartLabels[componentMetric] || componentMetric,
                        data: dataForAxis,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3, // Smaller points for multi-line
                        pointBackgroundColor: color,
                        pointStyle: pointStyle,
                        fill: false
                    });
                });
            } else if (selectedMetric === 'Gyroscope') {
                ['X', 'Y', 'Z'].forEach((axis, i) => {
                    const componentMetric = `Gyroscope ${axis}`;
                    const color = chartColors[(i + 3) % chartColors.length]; // Offset colors
                    const pointStyle = pointStyles[(i + 3) % pointStyles.length];

                    const dataForAxis = sortedData.map(entry => {
                        const val = parseFloat(entry[componentMetric]);
                        if (!isNaN(val)) values.push(val); // Add to values for stats
                        return val || 0;
                    });

                    datasets.push({
                        label: translations[currentLanguage].chartLabels[componentMetric] || componentMetric,
                        data: dataForAxis,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3, // Smaller points for multi-line
                        pointBackgroundColor: color,
                        pointStyle: pointStyle,
                        fill: false
                    });
                });
            } else {
                // Single metric chart
                const color = chartColors[0]; // Use first color for single charts
                const pointStyle = pointStyles[0];

                const dataForMetric = sortedData.map(entry => {
                    const val = parseFloat(entry[selectedMetric]);
                    if (!isNaN(val)) values.push(val); // Add to values for stats
                    return val || 0;
                });

                datasets.push({
                    label: chartMetricLabel,
                    data: dataForMetric,
                    borderColor: color,
                    backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 5,
                    pointBackgroundColor: color,
                    pointStyle: pointStyle,
                    fill: true
                });
            }

            // Calculate Min, Max, Average
            let min = values.length > 0 ? Math.min(...values) : NaN;
            let max = values.length > 0 ? Math.max(...values) : NaN;
            let sum = values.reduce((a, b) => a + b, 0);
            let avg = values.length > 0 ? sum / values.length : NaN;

            minVal.textContent = `${translations[currentLanguage].minLabel} ${formatNumericValue(min)}`;
            avgVal.textContent = `${translations[currentLanguage].avgLabel} ${formatNumericValue(avg)}`;
            maxVal.textContent = `${translations[currentLanguage].maxLabel} ${formatNumericValue(max)}`;


            if (chartInstance) {
                chartInstance.destroy();
            }

            const ctx = mainChartCanvas.getContext('2d');
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true, // Changed to true for responsiveness
                    maintainAspectRatio: true, // Changed to true for responsiveness
                    plugins: {
                        legend: {
                            display: (selectedMetric === 'AccÃ©lÃ©ration' || selectedMetric === 'Gyroscope'), // Only display legend for combined charts
                            rtl: (currentLanguage === 'ar'),
                            labels: {
                                font: {
                                    size: 12
                                },
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `${translations[currentLanguage].chartLabels['Timestamp']}: ${context[0].label}`;
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toLocaleString(currentLanguage, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                }
                            },
                            rtl: (currentLanguage === 'ar')
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: translations[currentLanguage].chartLabels['Timestamp'],
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 10,
                                font: { size: 10 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: chartMetricLabel,
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                font: { size: 10 },
                                callback: function(value) {
                                    return value.toLocaleString(currentLanguage);
                                }
                            }
                        }
                    },
                    indexAxis: 'x',
                    rtl: (currentLanguage === 'ar') 
                }
            });
        }

        /**
         * Renders the threshold settings page.
         */
        function renderThresholdSettings() {
            thresholdSettingsContent.innerHTML = ''; // Clear previous content
            thresholdMessage.classList.add('hidden'); // Hide any previous messages

            const labels = translations[currentLanguage].chartLabels;
            const t = translations[currentLanguage];

            for (const metric in THRESHOLDS) {
                if (THRESHOLDS.hasOwnProperty(metric)) {
                    const thresholds = THRESHOLDS[metric];
                    const metricLabel = labels[metric] || metric;

                    const metricCard = document.createElement('div');
                    metricCard.className = 'glassmorphism-card p-6 data-card-interactive';
                    metricCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-blue-700 mb-4">${metricLabel}</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="${metric}-min" class="block text-gray-700 text-sm font-medium mb-2">${t.minThresholdLabel}</label>
                                <input type="number" id="${metric}-min" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.min}" step="any">
                            </div>
                            <div>
                                <label for="${metric}-max" class="block text-gray-700 text-sm font-medium mb-2">${t.maxThresholdLabel}</label>
                                <input type="number" id="${metric}-max" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.max}" step="any">
                            </div>
                            <div>
                                <label for="${metric}-warning-min" class="block text-gray-700 text-sm font-medium mb-2">${t.warningMinThresholdLabel}</label>
                                <input type="number" id="${metric}-warning-min" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.warningMin}" step="any">
                            </div>
                            <div>
                                <label for="${metric}-warning-max" class="block text-gray-700 text-sm font-medium mb-2">${t.warningMaxThresholdLabel}</label>
                                <input type="number" id="${metric}-warning-max" class="form-input w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-200" value="${thresholds.warningMax}" step="any">
                            </div>
                        </div>
                    `;
                    thresholdSettingsContent.appendChild(metricCard);
                }
            }
        }

        /**
         * Saves the updated thresholds from the input fields.
         */
        function saveThresholds() {
            let allValid = true;
            const newThresholds = {};
            const t = translations[currentLanguage];

            for (const metric in THRESHOLDS) {
                if (THRESHOLDS.hasOwnProperty(metric)) {
                    const minVal = parseFloat(document.getElementById(`${metric}-min`).value);
                    const maxVal = parseFloat(document.getElementById(`${metric}-max`).value);
                    const warningMinVal = parseFloat(document.getElementById(`${metric}-warning-min`).value);
                    const warningMaxVal = parseFloat(document.getElementById(`${metric}-warning-max`).value);

                    // Basic validation: ensure numbers and min <= warningMin <= warningMax <= max
                    if (isNaN(minVal) || isNaN(maxVal) || isNaN(warningMinVal) || isNaN(warningMaxVal) ||
                        minVal > warningMinVal || warningMinVal > warningMaxVal || warningMaxVal > maxVal) {
                        allValid = false;
                        // Optionally, highlight invalid fields or show specific error per field
                        console.error(`Invalid thresholds for ${metric}`);
                        // Break if any invalid, or collect all errors
                        // For now, just mark allValid as false and continue to show general error
                    }

                    newThresholds[metric] = {
                        min: minVal,
                        max: maxVal,
                        warningMin: warningMinVal,
                        warningMax: warningMaxVal
                    };
                }
            }

            if (allValid) {
                THRESHOLDS = newThresholds; // Update the global THRESHOLDS object
                // In a real application, you'd save this to local storage or a backend
                // For now, we update in memory and re-render.
                
                showThresholdMessage(t.thresholdsSavedSuccess, 'success');
                // Re-render the relevant sections to apply new thresholds
                renderLatestData(sensorData);
                const activePageId = document.querySelector('.page-content:not(.hidden)').id;
                if (activePageId === 'charts') {
                    renderChart(chartMetricSelect.value || chartMetrics[0], getFilteredSensorData());
                }
                renderThresholdSettings(); // Re-render settings to show updated values
            } else {
                showThresholdMessage(t.thresholdsSaveError, 'error');
            }
        }

        /**
         * Resets the thresholds to their original default values.
         */
        function resetThresholds() {
            THRESHOLDS = JSON.parse(JSON.stringify(ORIGINAL_THRESHOLDS)); // Restore from original copy
            renderThresholdSettings(); // Re-render the settings page with original values
            
            // Re-render the relevant sections to apply reset thresholds
            renderLatestData(sensorData);
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            if (activePageId === 'charts') {
                renderChart(chartMetricSelect.value || chartMetrics[0], getFilteredSensorData());
            }
            showThresholdMessage(translations[currentLanguage].thresholdsSavedSuccess, 'success'); // Re-using success message for reset
        }


        /**
         * Displays a temporary message (success or error) on the threshold settings page.
         * @param {string} message - The message to display.
         * @param {'success' | 'error'} type - The type of message to determine styling.
         */
        function showThresholdMessage(message, type) {
            thresholdMessageText.textContent = message;
            thresholdMessage.classList.remove('hidden', 'bg-green-100', 'border-green-400', 'text-green-700', 'bg-red-100', 'border-red-400', 'text-red-700');
            
            if (type === 'success') {
                thresholdMessage.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
            } else if (type === 'error') {
                thresholdMessage.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            }
            // Automatically hide message after 5 seconds
            setTimeout(() => {
                thresholdMessage.classList.add('hidden');
            }, 5000);
        }

        /**
         * Exports the current active content section to a PDF file.
         */
        async function exportToPDF() {
            try {
                // Determine which section is currently visible
                const activeSection = document.querySelector('.page-content:not(.hidden)');
                if (!activeSection) {
                    alert('No content to export to PDF.');
                    return;
                }

                // If the active section is 'charts', we need to capture the canvas directly
                // to ensure high-quality chart image in the PDF.
                if (activeSection.id === 'charts' && chartInstance) {
                    const chartCanvas = document.getElementById('mainChartCanvas');
                    if (chartCanvas) {
                        const imgData = chartCanvas.toDataURL('image/png');
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF('p', 'mm', 'a4'); // 'p' for portrait, 'mm' for millimeters, 'a4' for A4 size

                        const imgWidth = 200; // A4 width approx 210mm, leave some margin
                        const pageHeight = pdf.internal.pageSize.height;
                        const imgHeight = (chartCanvas.height * imgWidth) / chartCanvas.width;
                        let heightLeft = imgHeight;

                        let position = 10; // Initial Y position for image

                        pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;

                        while (heightLeft >= 0) {
                            position = heightLeft - imgHeight + 10;
                            pdf.addPage();
                            pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                            heightLeft -= pageHeight;
                        }
                        pdf.save('sensor_chart.pdf');
                        return;
                    }
                }

                // For other sections, use html2canvas to capture the active section
                // and then add it to PDF.
                const canvas = await html2canvas(activeSection, {
                    scale: 2, // Increase scale for better resolution
                    logging: false, // Disable logging
                    useCORS: true // Enable CORS for images if any
                });

                const imgData = canvas.toDataURL('image/png');
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4'); // 'p' for portrait, 'mm' for millimeters, 'a4' for A4 size

                const imgWidth = 200; // A4 width approx 210mm, leave some margin
                const pageHeight = pdf.internal.pageSize.height;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                let heightLeft = imgHeight;

                let position = 10; // Initial Y position for image

                pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;

                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight + 10;
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 5, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }

                const filename = `${activeSection.id}_report.pdf`;
                pdf.save(filename);

            } catch (error) {
                console.error('Error exporting to PDF:', error);
                alert(translations[currentLanguage].exportPdfError + `\n${error.message}`);
            }
        }


        /**
         * Toggles auto-refresh functionality.
         */
        function toggleAutoRefresh() {
            if (autoRefreshIntervalId) {
                // If auto-refresh is active, stop it
                clearInterval(autoRefreshIntervalId);
                autoRefreshIntervalId = null;
                autoRefreshToggleBtn.textContent = translations[currentLanguage].autoRefreshOff;
                autoRefreshToggleBtn.classList.remove('bg-green-500');
                autoRefreshToggleBtn.classList.add('bg-red-500');
            } else {
                // If auto-refresh is inactive, start it
                // Fetch data every 15 seconds
                autoRefreshIntervalId = setInterval(fetchData, 15000); 
                autoRefreshToggleBtn.textContent = translations[currentLanguage].autoRefreshOn;
                autoRefreshToggleBtn.classList.remove('bg-red-500');
                autoRefreshToggleBtn.classList.add('bg-green-500');
            }
        }
        
        /**
         * Translates all text content in the UI based on the selected language.
         * @param {string} lang - The language code ('ar', 'en', 'fr').
         */
        function updateUIForLanguage(lang) {
            currentLanguage = lang;
            const t = translations[currentLanguage];

            // Update header and navigation buttons
            dashboardTitle.textContent = t.dashboardTitle;
            document.getElementById('latestDataBtn').textContent = t.latestDataBtn;
            document.getElementById('accelGyroBtn').textContent = t.accelGyroBtn;
            document.getElementById('fullTableBtn').textContent = t.fullTableBtn;
            document.getElementById('chartsBtn').textContent = t.chartsBtn;
            document.getElementById('thresholdSettingsBtn').textContent = t.settingsBtn;

            // Update main content titles
            latestDataTitle.textContent = t.latestDataTitle;
            accelGyroTitle.textContent = t.accelGyroTitle;
            fullTableTitle.textContent = t.fullTableTitle;
            chartsTitle.textContent = t.chartsTitle;
            thresholdSettingsTitle.textContent = t.thresholdSettingsTitle;

            // Update filter labels and buttons
            fromDateLabel.textContent = t.fromDateLabel;
            toDateLabel.textContent = t.toDateLabel;
            fromTimeLabel.textContent = t.fromTimeLabel;
            toTimeLabel.textContent = t.toTimeLabel;
            applyFiltersBtn.textContent = t.applyFiltersBtn;
            resetFiltersBtn.textContent = t.resetFiltersBtn;
            exportCsvBtn.textContent = t.exportCsvBtn;
            exportPdfBtn.textContent = t.exportPdfBtn;

            // Update loading and error messages
            loadingText.textContent = t.loadingText;
            errorTitle.textContent = t.errorTitle;
            errorTextSpan.textContent = t.errorText;
            noDataFoundDiv.textContent = t.noDataFound;

            // Update chart labels and stats
            chartMetricSelect.labels = t.chartMetricLabel; // This might not work directly, adjust if needed
            minVal.textContent = `${t.minLabel} N/A`; // Reset and update on renderChart
            avgVal.textContent = `${t.avgLabel} N/A`;
            maxVal.textContent = `${t.maxLabel} N/A`;
            chartMetricSelect.labels[0] = t.chartMetricLabel;


            // Update auto-refresh button text
            if (autoRefreshIntervalId) {
                autoRefreshToggleBtn.textContent = t.autoRefreshOn;
            } else {
                autoRefreshToggleBtn.textContent = t.autoRefreshOff;
            }

            // Update LLM insight elements
            generateInsightBtn.textContent = t.generateInsightBtn;
            insightCardTitle.textContent = t.insightCardTitle;
            insightLoadingText.textContent = t.generatingInsight;
            copyInsightBtn.textContent = t.copyInsightBtn;

            // Update threshold settings buttons
            saveThresholdsBtn.textContent = t.saveThresholdsBtn;
            resetThresholdsBtn.textContent = t.resetThresholdsBtn;

            // Adjust text alignment and direction based on language
            const body = document.body;
            if (lang === 'ar') {
                body.style.direction = 'rtl';
                body.style.textAlign = 'right';
                document.querySelectorAll('th').forEach(th => th.style.textAlign = 'right');
            } else {
                body.style.direction = 'ltr';
                body.style.textAlign = 'left';
                document.querySelectorAll('th').forEach(th => th.style.textAlign = 'left');
            }

            // Re-render current page to apply language changes to dynamic content
            const activePageId = document.querySelector('.page-content:not(.hidden)').id;
            const filteredData = getFilteredSensorData(); // Get filtered data for active page if needed

            if (activePageId === 'latestData') {
                renderLatestData(sensorData);
            } else if (activePageId === 'fullTable') {
                // Re-render table headers and content
                tableHeaderRow.innerHTML = ''; // Clear existing headers before re-rendering
                const headers = Object.keys(sensorData.length > 0 ? sensorData[0] : {});
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-right'; // Assume RTL initially for header, then adjust with body style
                    th.textContent = t.chartLabels[header] || header;
                    tableHeaderRow.appendChild(th);
                });
                renderFullTable(filteredData);
            } else if (activePageId === 'charts') {
                populateChartMetricSelect(); // Re-populate dropdown with translated options
                const selectedMetric = chartMetricSelect.value || chartMetrics[0];
                renderChart(selectedMetric, filteredData);
            } else if (activePageId === 'accelGyroData') {
                renderAccelGyroData(sensorData);
            } else if (activePageId === 'thresholdSettings') {
                renderThresholdSettings();
            }

            // Update pagination text
            const totalPages = Math.ceil(getFilteredSensorData().length / itemsPerPage);
            pageInfo.textContent = t.pageInfo(currentPage, totalPages);
        }

        // Functions for LLM insight
        async function generateInsight() {
            if (sensorData.length === 0) {
                insightContent.textContent = translations[currentLanguage].noDataForInsight;
                insightCard.classList.remove('hidden');
                return;
            }

            insightLoading.classList.remove('hidden');
            insightLoadingText.textContent = translations[currentLanguage].generatingInsight;
            insightContent.textContent = '';
            insightCard.classList.remove('hidden'); // Show card during loading

            const latestData = sensorData[sensorData.length - 1];
            const dataToAnalyze = {
                temperature: latestData['TempÃ©rature (Â°C)'],
                humidity: latestData['HumiditÃ© (%)'],
                vibration: latestData['Vibration'],
                ntcTemp: latestData['Temp. NTC (Â°C)'],
                current: latestData['Courant (V Bruts)'],
                battery: latestData['Batterie (V)'],
                accelX: latestData['AccÃ©lÃ©ration X'],
                accelY: latestData['AccÃ©lÃ©ration Y'],
                accelZ: latestData['AccÃ©lÃ©ration Z'],
                gyroX: latestData['Gyroscope X'],
                gyroY: latestData['Gyroscope Y'],
                gyroZ: latestData['Gyroscope Z'],
                timestamp: `${latestData['Date']} ${latestData['Heure']}`
            };

            const prompt = `Based on the following sensor data, provide a concise and insightful summary of the current status of the system. Highlight any anomalies, trends, or critical readings. Also, mention the overall health of the system based on these readings. Data: ${JSON.stringify(dataToAnalyze)}.
            Use a helpful and professional tone. Keep it within 3-4 sentences.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(`API error: ${response.status} - ${JSON.stringify(errorResponse)}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const insightText = result.candidates[0].content.parts[0].text;
                    insightContent.textContent = insightText;
                } else {
                    insightContent.textContent = translations[currentLanguage].insightError;
                    console.error('Unexpected API response structure:', result);
                }
            } catch (error) {
                console.error('Error fetching insight from AI:', error);
                insightContent.textContent = translations[currentLanguage].insightFetchError;
            } finally {
                insightLoading.classList.add('hidden');
            }
        }

        function exportToCSV() {
            if (sensorData.length === 0) {
                alert(translations[currentLanguage].noDataFound);
                return;
            }

            const filteredData = getFilteredSensorData(); // Use filtered data for CSV export
            if (filteredData.length === 0) {
                alert(translations[currentLanguage].noDataFound);
                return;
            }

            // Get headers from the first object, and map them to translated headers
            const headers = Object.keys(filteredData[0]);
            const translatedHeaders = headers.map(header => translations[currentLanguage].chartLabels[header] || header);
            
            let csvContent = translatedHeaders.join(',') + '\n';

            filteredData.forEach(row => {
                const rowValues = headers.map(header => {
                    let value = row[header];
                    if (header === 'Date') {
                        value = getFormattedDateForDisplay(value, row['Heure']);
                    } else if (header === 'Heure') {
                        value = getFormattedTimeForDisplay(row['Date'], value);
                    } else if (typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)))) {
                        value = formatNumericValue(value);
                    }
                    // Handle commas within values by enclosing them in double quotes
                    if (typeof value === 'string' && value.includes(',')) {
                        value = `"${value.replace(/"/g, '""')}"`; // Escape double quotes and enclose
                    }
                    return value;
                });
                csvContent += rowValues.join(',') + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'sensor_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Function to copy insight to clipboard
        function copyInsight() {
            const insightText = insightContent.textContent;
            if (!insightText) {
                return;
            }

            // Use document.execCommand('copy') as navigator.clipboard.writeText() might not work in some iframe environments
            const textArea = document.createElement('textarea');
            textArea.value = insightText;
            textArea.style.position = 'fixed'; // Prevents scrolling to bottom
            textArea.style.opacity = '0'; // Make it invisible
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showThresholdMessage(translations[currentLanguage].copiedSuccess, 'success');
                } else {
                    showThresholdMessage(translations[currentLanguage].copyFailed, 'error');
                }
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showThresholdMessage(translations[currentLanguage].copyFailed, 'error');
            } finally {
                document.body.removeChild(textArea);
            }
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initial UI update before anything else, so translations are applied early
            updateUIForLanguage(currentLanguage);

            fetchData(); // Fetch all data on page load
            showPage('latestData'); // Show the latest data page by default

            populateChartMetricSelect(); // Populate chart dropdown on load

            // Start auto-refresh by default AFTER toggleAutoRefresh is defined
            toggleAutoRefresh();

            setInterval(updateCurrentDateTimeDisplay, 1000); // Update current date and time every second 

            document.querySelectorAll('.nav-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const targetPage = event.target.dataset.target;
                    showPage(targetPage);
                });
            });

            document.querySelectorAll('.lang-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const lang = event.target.dataset.lang;
                    updateUIForLanguage(lang);
                });
            });

            autoRefreshToggleBtn.addEventListener('click', toggleAutoRefresh);
            generateInsightBtn.addEventListener('click', generateInsight);
            copyInsightBtn.addEventListener('click', copyInsight); // New event listener for copy insight

            applyFiltersBtn.addEventListener('click', applyFilters); // Client-side filter application
            resetFiltersBtn.addEventListener('click', resetFilters); // Client-side filter reset
            exportCsvBtn.addEventListener('click', exportToCSV); // New event listener for CSV export
            exportPdfBtn.addEventListener('click', exportToPDF); // New event listener for PDF export

            // Pagination event listeners
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderFullTable(getFilteredSensorData());
                }
            });
            nextPageBtn.addEventListener('click', () => {
                const filteredData = getFilteredSensorData();
                const totalPages = Math.ceil(filteredData.length / itemsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderFullTable(filteredData);
                }
            });

            // Chart metric selection event listener
            chartMetricSelect.addEventListener('change', () => {
                const selectedMetric = chartMetricSelect.value;
                chartMetricSelect.dataset.selected = selectedMetric; // Store selection
                renderChart(selectedMetric, getFilteredSensorData());
            });

            // Event listeners for threshold settings page
            saveThresholdsBtn.addEventListener('click', saveThresholds);
            resetThresholdsBtn.addEventListener('click', resetThresholds);
        });

    </script>
</body>
</html>
